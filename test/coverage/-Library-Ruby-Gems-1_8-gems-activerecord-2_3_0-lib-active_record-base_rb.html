<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.0/lib/active_record/base.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Apr 10 14:55:45 -0500 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_3_0-lib-active_record-base_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.0/lib/active_record/base.rb</a>
        </td>
      <td class='lines_total'><tt>3149</tt>
        </td>
      <td class='lines_code'><tt>1461</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>58.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='58'/>
                  <td class='uncovered' width='42'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>20.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='20'/>
                  <td class='uncovered' width='80'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked0"><a name="line1"></a>   1 require 'yaml'
</span><span class="marked1"><a name="line2"></a>   2 require 'set'
</span><span class="inferred0"><a name="line3"></a>   3 
</span><span class="marked1"><a name="line4"></a>   4 module ActiveRecord #:nodoc:
</span><span class="inferred0"><a name="line5"></a>   5   # Generic Active Record exception class.
</span><span class="marked1"><a name="line6"></a>   6   class ActiveRecordError &lt; StandardError
</span><span class="inferred0"><a name="line7"></a>   7   end
</span><span class="inferred1"><a name="line8"></a>   8 
</span><span class="inferred0"><a name="line9"></a>   9   # Raised when the single-table inheritance mechanism fails to locate the subclass
</span><span class="inferred1"><a name="line10"></a>  10   # (for example due to improper usage of column that +inheritance_column+ points to).
</span><span class="marked0"><a name="line11"></a>  11   class SubclassNotFound &lt; ActiveRecordError #:nodoc:
</span><span class="inferred1"><a name="line12"></a>  12   end
</span><span class="inferred0"><a name="line13"></a>  13 
</span><span class="inferred1"><a name="line14"></a>  14   # Raised when an object assigned to an association has an incorrect type.
</span><span class="inferred0"><a name="line15"></a>  15   #
</span><span class="inferred1"><a name="line16"></a>  16   #   class Ticket &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line17"></a>  17   #     has_many :patches
</span><span class="inferred1"><a name="line18"></a>  18   #   end
</span><span class="inferred0"><a name="line19"></a>  19   #
</span><span class="inferred1"><a name="line20"></a>  20   #   class Patch &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line21"></a>  21   #     belongs_to :ticket
</span><span class="inferred1"><a name="line22"></a>  22   #   end
</span><span class="inferred0"><a name="line23"></a>  23   #
</span><span class="inferred1"><a name="line24"></a>  24   #   # Comments are not patches, this assignment raises AssociationTypeMismatch.
</span><span class="inferred0"><a name="line25"></a>  25   #   @ticket.patches &lt;&lt; Comment.new(:content =&gt; &quot;Please attach tests to your patch.&quot;)
</span><span class="marked1"><a name="line26"></a>  26   class AssociationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred0"><a name="line27"></a>  27   end
</span><span class="inferred1"><a name="line28"></a>  28 
</span><span class="inferred0"><a name="line29"></a>  29   # Raised when unserialized object's type mismatches one specified for serializable field.
</span><span class="marked1"><a name="line30"></a>  30   class SerializationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred0"><a name="line31"></a>  31   end
</span><span class="inferred1"><a name="line32"></a>  32 
</span><span class="inferred0"><a name="line33"></a>  33   # Raised when adapter not specified on connection (or configuration file &lt;tt&gt;config/database.yml&lt;/tt&gt; misses adapter field).
</span><span class="marked1"><a name="line34"></a>  34   class AdapterNotSpecified &lt; ActiveRecordError
</span><span class="inferred0"><a name="line35"></a>  35   end
</span><span class="inferred1"><a name="line36"></a>  36 
</span><span class="inferred0"><a name="line37"></a>  37   # Raised when Active Record cannot find database adapter specified in &lt;tt&gt;config/database.yml&lt;/tt&gt; or programmatically.
</span><span class="marked1"><a name="line38"></a>  38   class AdapterNotFound &lt; ActiveRecordError
</span><span class="inferred0"><a name="line39"></a>  39   end
</span><span class="inferred1"><a name="line40"></a>  40 
</span><span class="inferred0"><a name="line41"></a>  41   # Raised when connection to the database could not been established (for example when &lt;tt&gt;connection=&lt;/tt&gt; is given a nil object).
</span><span class="marked1"><a name="line42"></a>  42   class ConnectionNotEstablished &lt; ActiveRecordError
</span><span class="inferred0"><a name="line43"></a>  43   end
</span><span class="inferred1"><a name="line44"></a>  44 
</span><span class="inferred0"><a name="line45"></a>  45   # Raised when Active Record cannot find record by given id or set of ids.
</span><span class="marked1"><a name="line46"></a>  46   class RecordNotFound &lt; ActiveRecordError
</span><span class="inferred0"><a name="line47"></a>  47   end
</span><span class="inferred1"><a name="line48"></a>  48 
</span><span class="inferred0"><a name="line49"></a>  49   # Raised by ActiveRecord::Base.save! and ActiveRecord::Base.create! methods when record cannot be
</span><span class="inferred1"><a name="line50"></a>  50   # saved because record is invalid.
</span><span class="marked0"><a name="line51"></a>  51   class RecordNotSaved &lt; ActiveRecordError
</span><span class="inferred1"><a name="line52"></a>  52   end
</span><span class="inferred0"><a name="line53"></a>  53 
</span><span class="inferred1"><a name="line54"></a>  54   # Raised when SQL statement cannot be executed by the database (for example, it's often the case for MySQL when Ruby driver used is too old).
</span><span class="marked0"><a name="line55"></a>  55   class StatementInvalid &lt; ActiveRecordError
</span><span class="inferred1"><a name="line56"></a>  56   end
</span><span class="inferred0"><a name="line57"></a>  57 
</span><span class="inferred1"><a name="line58"></a>  58   # Raised when number of bind variables in statement given to &lt;tt&gt;:condition&lt;/tt&gt; key (for example, when using +find+ method)
</span><span class="inferred0"><a name="line59"></a>  59   # does not match number of expected variables.
</span><span class="inferred1"><a name="line60"></a>  60   #
</span><span class="inferred0"><a name="line61"></a>  61   # For example, in
</span><span class="inferred1"><a name="line62"></a>  62   #
</span><span class="inferred0"><a name="line63"></a>  63   #   Location.find :all, :conditions =&gt; [&quot;lat = ? AND lng = ?&quot;, 53.7362]
</span><span class="inferred1"><a name="line64"></a>  64   #
</span><span class="inferred0"><a name="line65"></a>  65   # two placeholders are given but only one variable to fill them.
</span><span class="marked1"><a name="line66"></a>  66   class PreparedStatementInvalid &lt; ActiveRecordError
</span><span class="inferred0"><a name="line67"></a>  67   end
</span><span class="inferred1"><a name="line68"></a>  68 
</span><span class="inferred0"><a name="line69"></a>  69   # Raised on attempt to save stale record. Record is stale when it's being saved in another query after
</span><span class="inferred1"><a name="line70"></a>  70   # instantiation, for example, when two users edit the same wiki page and one starts editing and saves
</span><span class="inferred0"><a name="line71"></a>  71   # the page before the other.
</span><span class="inferred1"><a name="line72"></a>  72   #
</span><span class="inferred0"><a name="line73"></a>  73   # Read more about optimistic locking in ActiveRecord::Locking module RDoc.
</span><span class="marked1"><a name="line74"></a>  74   class StaleObjectError &lt; ActiveRecordError
</span><span class="inferred0"><a name="line75"></a>  75   end
</span><span class="inferred1"><a name="line76"></a>  76 
</span><span class="inferred0"><a name="line77"></a>  77   # Raised when association is being configured improperly or
</span><span class="inferred1"><a name="line78"></a>  78   # user tries to use offset and limit together with has_many or has_and_belongs_to_many associations.
</span><span class="marked0"><a name="line79"></a>  79   class ConfigurationError &lt; ActiveRecordError
</span><span class="inferred1"><a name="line80"></a>  80   end
</span><span class="inferred0"><a name="line81"></a>  81 
</span><span class="inferred1"><a name="line82"></a>  82   # Raised on attempt to update record that is instantiated as read only.
</span><span class="marked0"><a name="line83"></a>  83   class ReadOnlyRecord &lt; ActiveRecordError
</span><span class="inferred1"><a name="line84"></a>  84   end
</span><span class="inferred0"><a name="line85"></a>  85 
</span><span class="inferred1"><a name="line86"></a>  86   # ActiveRecord::Transactions::ClassMethods.transaction uses this exception
</span><span class="inferred0"><a name="line87"></a>  87   # to distinguish a deliberate rollback from other exceptional situations.
</span><span class="inferred1"><a name="line88"></a>  88   # Normally, raising an exception will cause the +transaction+ method to rollback
</span><span class="inferred0"><a name="line89"></a>  89   # the database transaction *and* pass on the exception. But if you raise an
</span><span class="inferred1"><a name="line90"></a>  90   # ActiveRecord::Rollback exception, then the database transaction will be rolled back,
</span><span class="inferred0"><a name="line91"></a>  91   # without passing on the exception.
</span><span class="inferred1"><a name="line92"></a>  92   #
</span><span class="inferred0"><a name="line93"></a>  93   # For example, you could do this in your controller to rollback a transaction:
</span><span class="inferred1"><a name="line94"></a>  94   #
</span><span class="inferred0"><a name="line95"></a>  95   #   class BooksController &lt; ActionController::Base
</span><span class="inferred1"><a name="line96"></a>  96   #     def create
</span><span class="inferred0"><a name="line97"></a>  97   #       Book.transaction do
</span><span class="inferred1"><a name="line98"></a>  98   #         book = Book.new(params[:book])
</span><span class="inferred0"><a name="line99"></a>  99   #         book.save!
</span><span class="inferred1"><a name="line100"></a> 100   #         if today_is_friday?
</span><span class="inferred0"><a name="line101"></a> 101   #           # The system must fail on Friday so that our support department
</span><span class="inferred1"><a name="line102"></a> 102   #           # won't be out of job. We silently rollback this transaction
</span><span class="inferred0"><a name="line103"></a> 103   #           # without telling the user.
</span><span class="inferred1"><a name="line104"></a> 104   #           raise ActiveRecord::Rollback, &quot;Call tech support!&quot;
</span><span class="inferred0"><a name="line105"></a> 105   #         end
</span><span class="inferred1"><a name="line106"></a> 106   #       end
</span><span class="inferred0"><a name="line107"></a> 107   #       # ActiveRecord::Rollback is the only exception that won't be passed on
</span><span class="inferred1"><a name="line108"></a> 108   #       # by ActiveRecord::Base.transaction, so this line will still be reached
</span><span class="inferred0"><a name="line109"></a> 109   #       # even on Friday.
</span><span class="inferred1"><a name="line110"></a> 110   #       redirect_to root_url
</span><span class="inferred0"><a name="line111"></a> 111   #     end
</span><span class="inferred1"><a name="line112"></a> 112   #   end
</span><span class="marked0"><a name="line113"></a> 113   class Rollback &lt; ActiveRecordError
</span><span class="inferred1"><a name="line114"></a> 114   end
</span><span class="inferred0"><a name="line115"></a> 115 
</span><span class="inferred1"><a name="line116"></a> 116   # Raised when attribute has a name reserved by Active Record (when attribute has name of one of Active Record instance methods).
</span><span class="marked0"><a name="line117"></a> 117   class DangerousAttributeError &lt; ActiveRecordError
</span><span class="inferred1"><a name="line118"></a> 118   end
</span><span class="inferred0"><a name="line119"></a> 119 
</span><span class="inferred1"><a name="line120"></a> 120   # Raised when you've tried to access a column which wasn't loaded by your finder.
</span><span class="inferred0"><a name="line121"></a> 121   # Typically this is because &lt;tt&gt;:select&lt;/tt&gt; has been specified.
</span><span class="marked1"><a name="line122"></a> 122   class MissingAttributeError &lt; NoMethodError
</span><span class="inferred0"><a name="line123"></a> 123   end
</span><span class="inferred1"><a name="line124"></a> 124 
</span><span class="inferred0"><a name="line125"></a> 125   # Raised when unknown attributes are supplied via mass assignment.
</span><span class="marked1"><a name="line126"></a> 126   class UnknownAttributeError &lt; NoMethodError
</span><span class="inferred0"><a name="line127"></a> 127   end
</span><span class="inferred1"><a name="line128"></a> 128 
</span><span class="inferred0"><a name="line129"></a> 129   # Raised when an error occurred while doing a mass assignment to an attribute through the
</span><span class="inferred1"><a name="line130"></a> 130   # &lt;tt&gt;attributes=&lt;/tt&gt; method. The exception has an +attribute+ property that is the name of the
</span><span class="inferred0"><a name="line131"></a> 131   # offending attribute.
</span><span class="marked1"><a name="line132"></a> 132   class AttributeAssignmentError &lt; ActiveRecordError
</span><span class="marked0"><a name="line133"></a> 133     attr_reader :exception, :attribute
</span><span class="marked1"><a name="line134"></a> 134     def initialize(message, exception, attribute)
</span><span class="uncovered0"><a name="line135"></a> 135       @exception = exception
</span><span class="uncovered1"><a name="line136"></a> 136       @attribute = attribute
</span><span class="uncovered0"><a name="line137"></a> 137       @message = message
</span><span class="uncovered1"><a name="line138"></a> 138     end
</span><span class="uncovered0"><a name="line139"></a> 139   end
</span><span class="inferred1"><a name="line140"></a> 140 
</span><span class="inferred0"><a name="line141"></a> 141   # Raised when there are multiple errors while doing a mass assignment through the +attributes+
</span><span class="inferred1"><a name="line142"></a> 142   # method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
</span><span class="inferred0"><a name="line143"></a> 143   # objects, each corresponding to the error while assigning to an attribute.
</span><span class="marked1"><a name="line144"></a> 144   class MultiparameterAssignmentErrors &lt; ActiveRecordError
</span><span class="marked0"><a name="line145"></a> 145     attr_reader :errors
</span><span class="marked1"><a name="line146"></a> 146     def initialize(errors)
</span><span class="uncovered0"><a name="line147"></a> 147       @errors = errors
</span><span class="uncovered1"><a name="line148"></a> 148     end
</span><span class="uncovered0"><a name="line149"></a> 149   end
</span><span class="inferred1"><a name="line150"></a> 150 
</span><span class="inferred0"><a name="line151"></a> 151   # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with
</span><span class="inferred1"><a name="line152"></a> 152   # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change
</span><span class="inferred0"><a name="line153"></a> 153   # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain
</span><span class="inferred1"><a name="line154"></a> 154   # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
</span><span class="inferred0"><a name="line155"></a> 155   #
</span><span class="inferred1"><a name="line156"></a> 156   # See the mapping rules in table_name and the full example in link:files/README.html for more insight.
</span><span class="inferred0"><a name="line157"></a> 157   #
</span><span class="inferred1"><a name="line158"></a> 158   # == Creation
</span><span class="inferred0"><a name="line159"></a> 159   #
</span><span class="inferred1"><a name="line160"></a> 160   # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when
</span><span class="inferred0"><a name="line161"></a> 161   # you're receiving the data from somewhere else, like an HTTP request. It works like this:
</span><span class="inferred1"><a name="line162"></a> 162   #
</span><span class="inferred0"><a name="line163"></a> 163   #   user = User.new(:name =&gt; &quot;David&quot;, :occupation =&gt; &quot;Code Artist&quot;)
</span><span class="inferred1"><a name="line164"></a> 164   #   user.name # =&gt; &quot;David&quot;
</span><span class="inferred0"><a name="line165"></a> 165   #
</span><span class="inferred1"><a name="line166"></a> 166   # You can also use block initialization:
</span><span class="inferred0"><a name="line167"></a> 167   #
</span><span class="inferred1"><a name="line168"></a> 168   #   user = User.new do |u|
</span><span class="inferred0"><a name="line169"></a> 169   #     u.name = &quot;David&quot;
</span><span class="inferred1"><a name="line170"></a> 170   #     u.occupation = &quot;Code Artist&quot;
</span><span class="inferred0"><a name="line171"></a> 171   #   end
</span><span class="inferred1"><a name="line172"></a> 172   #
</span><span class="inferred0"><a name="line173"></a> 173   # And of course you can just create a bare object and specify the attributes after the fact:
</span><span class="inferred1"><a name="line174"></a> 174   #
</span><span class="inferred0"><a name="line175"></a> 175   #   user = User.new
</span><span class="inferred1"><a name="line176"></a> 176   #   user.name = &quot;David&quot;
</span><span class="inferred0"><a name="line177"></a> 177   #   user.occupation = &quot;Code Artist&quot;
</span><span class="inferred1"><a name="line178"></a> 178   #
</span><span class="inferred0"><a name="line179"></a> 179   # == Conditions
</span><span class="inferred1"><a name="line180"></a> 180   #
</span><span class="inferred0"><a name="line181"></a> 181   # Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
</span><span class="inferred1"><a name="line182"></a> 182   # The array form is to be used when the condition input is tainted and requires sanitization. The string form can
</span><span class="inferred0"><a name="line183"></a> 183   # be used for statements that don't involve tainted data. The hash form works much like the array form, except
</span><span class="inferred1"><a name="line184"></a> 184   # only equality and range is possible. Examples:
</span><span class="inferred0"><a name="line185"></a> 185   #
</span><span class="inferred1"><a name="line186"></a> 186   #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line187"></a> 187   #     def self.authenticate_unsafely(user_name, password)
</span><span class="inferred1"><a name="line188"></a> 188   #       find(:first, :conditions =&gt; &quot;user_name = '#{user_name}' AND password = '#{password}'&quot;)
</span><span class="inferred0"><a name="line189"></a> 189   #     end
</span><span class="inferred1"><a name="line190"></a> 190   #
</span><span class="inferred0"><a name="line191"></a> 191   #     def self.authenticate_safely(user_name, password)
</span><span class="inferred1"><a name="line192"></a> 192   #       find(:first, :conditions =&gt; [ &quot;user_name = ? AND password = ?&quot;, user_name, password ])
</span><span class="inferred0"><a name="line193"></a> 193   #     end
</span><span class="inferred1"><a name="line194"></a> 194   #
</span><span class="inferred0"><a name="line195"></a> 195   #     def self.authenticate_safely_simply(user_name, password)
</span><span class="inferred1"><a name="line196"></a> 196   #       find(:first, :conditions =&gt; { :user_name =&gt; user_name, :password =&gt; password })
</span><span class="inferred0"><a name="line197"></a> 197   #     end
</span><span class="inferred1"><a name="line198"></a> 198   #   end
</span><span class="inferred0"><a name="line199"></a> 199   #
</span><span class="inferred1"><a name="line200"></a> 200   # The &lt;tt&gt;authenticate_unsafely&lt;/tt&gt; method inserts the parameters directly into the query and is thus susceptible to SQL-injection
</span><span class="inferred0"><a name="line201"></a> 201   # attacks if the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ parameters come directly from an HTTP request. The &lt;tt&gt;authenticate_safely&lt;/tt&gt;  and
</span><span class="inferred1"><a name="line202"></a> 202   # &lt;tt&gt;authenticate_safely_simply&lt;/tt&gt; both will sanitize the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ before inserting them in the query,
</span><span class="inferred0"><a name="line203"></a> 203   # which will ensure that an attacker can't escape the query and fake the login (or worse).
</span><span class="inferred1"><a name="line204"></a> 204   #
</span><span class="inferred0"><a name="line205"></a> 205   # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth
</span><span class="inferred1"><a name="line206"></a> 206   # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing
</span><span class="inferred0"><a name="line207"></a> 207   # the question marks with symbols and supplying a hash with values for the matching symbol keys:
</span><span class="inferred1"><a name="line208"></a> 208   #
</span><span class="inferred0"><a name="line209"></a> 209   #   Company.find(:first, :conditions =&gt; [
</span><span class="inferred1"><a name="line210"></a> 210   #     &quot;id = :id AND name = :name AND division = :division AND created_at &gt; :accounting_date&quot;,
</span><span class="inferred0"><a name="line211"></a> 211   #     { :id =&gt; 3, :name =&gt; &quot;37signals&quot;, :division =&gt; &quot;First&quot;, :accounting_date =&gt; '2005-01-01' }
</span><span class="inferred1"><a name="line212"></a> 212   #   ])
</span><span class="inferred0"><a name="line213"></a> 213   #
</span><span class="inferred1"><a name="line214"></a> 214   # Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
</span><span class="inferred0"><a name="line215"></a> 215   # operator. For instance:
</span><span class="inferred1"><a name="line216"></a> 216   #
</span><span class="inferred0"><a name="line217"></a> 217   #   Student.find(:all, :conditions =&gt; { :first_name =&gt; &quot;Harvey&quot;, :status =&gt; 1 })
</span><span class="inferred1"><a name="line218"></a> 218   #   Student.find(:all, :conditions =&gt; params[:student])
</span><span class="inferred0"><a name="line219"></a> 219   #
</span><span class="inferred1"><a name="line220"></a> 220   # A range may be used in the hash to use the SQL BETWEEN operator:
</span><span class="inferred0"><a name="line221"></a> 221   #
</span><span class="inferred1"><a name="line222"></a> 222   #   Student.find(:all, :conditions =&gt; { :grade =&gt; 9..12 })
</span><span class="inferred0"><a name="line223"></a> 223   #
</span><span class="inferred1"><a name="line224"></a> 224   # An array may be used in the hash to use the SQL IN operator:
</span><span class="inferred0"><a name="line225"></a> 225   #
</span><span class="inferred1"><a name="line226"></a> 226   #   Student.find(:all, :conditions =&gt; { :grade =&gt; [9,11,12] })
</span><span class="inferred0"><a name="line227"></a> 227   #
</span><span class="inferred1"><a name="line228"></a> 228   # == Overwriting default accessors
</span><span class="inferred0"><a name="line229"></a> 229   #
</span><span class="inferred1"><a name="line230"></a> 230   # All column values are automatically available through basic accessors on the Active Record object, but sometimes you
</span><span class="inferred0"><a name="line231"></a> 231   # want to specialize this behavior. This can be done by overwriting the default accessors (using the same
</span><span class="inferred1"><a name="line232"></a> 232   # name as the attribute) and calling &lt;tt&gt;read_attribute(attr_name)&lt;/tt&gt; and &lt;tt&gt;write_attribute(attr_name, value)&lt;/tt&gt; to actually change things.
</span><span class="inferred0"><a name="line233"></a> 233   # Example:
</span><span class="inferred1"><a name="line234"></a> 234   #
</span><span class="inferred0"><a name="line235"></a> 235   #   class Song &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line236"></a> 236   #     # Uses an integer of seconds to hold the length of the song
</span><span class="inferred0"><a name="line237"></a> 237   #
</span><span class="inferred1"><a name="line238"></a> 238   #     def length=(minutes)
</span><span class="inferred0"><a name="line239"></a> 239   #       write_attribute(:length, minutes.to_i * 60)
</span><span class="inferred1"><a name="line240"></a> 240   #     end
</span><span class="inferred0"><a name="line241"></a> 241   #
</span><span class="inferred1"><a name="line242"></a> 242   #     def length
</span><span class="inferred0"><a name="line243"></a> 243   #       read_attribute(:length) / 60
</span><span class="inferred1"><a name="line244"></a> 244   #     end
</span><span class="inferred0"><a name="line245"></a> 245   #   end
</span><span class="inferred1"><a name="line246"></a> 246   #
</span><span class="inferred0"><a name="line247"></a> 247   # You can alternatively use &lt;tt&gt;self[:attribute]=(value)&lt;/tt&gt; and &lt;tt&gt;self[:attribute]&lt;/tt&gt; instead of &lt;tt&gt;write_attribute(:attribute, value)&lt;/tt&gt; and
</span><span class="inferred1"><a name="line248"></a> 248   # &lt;tt&gt;read_attribute(:attribute)&lt;/tt&gt; as a shorter form.
</span><span class="inferred0"><a name="line249"></a> 249   #
</span><span class="inferred1"><a name="line250"></a> 250   # == Attribute query methods
</span><span class="inferred0"><a name="line251"></a> 251   #
</span><span class="inferred1"><a name="line252"></a> 252   # In addition to the basic accessors, query methods are also automatically available on the Active Record object.
</span><span class="inferred0"><a name="line253"></a> 253   # Query methods allow you to test whether an attribute value is present.
</span><span class="inferred1"><a name="line254"></a> 254   #
</span><span class="inferred0"><a name="line255"></a> 255   # For example, an Active Record User with the &lt;tt&gt;name&lt;/tt&gt; attribute has a &lt;tt&gt;name?&lt;/tt&gt; method that you can call
</span><span class="inferred1"><a name="line256"></a> 256   # to determine whether the user has a name:
</span><span class="inferred0"><a name="line257"></a> 257   #
</span><span class="inferred1"><a name="line258"></a> 258   #   user = User.new(:name =&gt; &quot;David&quot;)
</span><span class="inferred0"><a name="line259"></a> 259   #   user.name? # =&gt; true
</span><span class="inferred1"><a name="line260"></a> 260   #
</span><span class="inferred0"><a name="line261"></a> 261   #   anonymous = User.new(:name =&gt; &quot;&quot;)
</span><span class="inferred1"><a name="line262"></a> 262   #   anonymous.name? # =&gt; false
</span><span class="inferred0"><a name="line263"></a> 263   #
</span><span class="inferred1"><a name="line264"></a> 264   # == Accessing attributes before they have been typecasted
</span><span class="inferred0"><a name="line265"></a> 265   #
</span><span class="inferred1"><a name="line266"></a> 266   # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.
</span><span class="inferred0"><a name="line267"></a> 267   # That can be done by using the &lt;tt&gt;&lt;attribute&gt;_before_type_cast&lt;/tt&gt; accessors that all attributes have. For example, if your Account model
</span><span class="inferred1"><a name="line268"></a> 268   # has a &lt;tt&gt;balance&lt;/tt&gt; attribute, you can call &lt;tt&gt;account.balance_before_type_cast&lt;/tt&gt; or &lt;tt&gt;account.id_before_type_cast&lt;/tt&gt;.
</span><span class="inferred0"><a name="line269"></a> 269   #
</span><span class="inferred1"><a name="line270"></a> 270   # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display
</span><span class="inferred0"><a name="line271"></a> 271   # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you
</span><span class="inferred1"><a name="line272"></a> 272   # want.
</span><span class="inferred0"><a name="line273"></a> 273   #
</span><span class="inferred1"><a name="line274"></a> 274   # == Dynamic attribute-based finders
</span><span class="inferred0"><a name="line275"></a> 275   #
</span><span class="inferred1"><a name="line276"></a> 276   # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by
</span><span class="inferred0"><a name="line277"></a> 277   # appending the name of an attribute to &lt;tt&gt;find_by_&lt;/tt&gt;, &lt;tt&gt;find_last_by_&lt;/tt&gt;, or &lt;tt&gt;find_all_by_&lt;/tt&gt;, so you get finders like &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt;,
</span><span class="inferred1"><a name="line278"></a> 278   # &lt;tt&gt;Person.find_all_by_last_name&lt;/tt&gt;, and &lt;tt&gt;Payment.find_by_transaction_id&lt;/tt&gt;. So instead of writing
</span><span class="inferred0"><a name="line279"></a> 279   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_by_user_name(user_name)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line280"></a> 280   # And instead of writing &lt;tt&gt;Person.find(:all, :conditions =&gt; [&quot;last_name = ?&quot;, last_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_all_by_last_name(last_name)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line281"></a> 281   #
</span><span class="inferred1"><a name="line282"></a> 282   # It's also possible to use multiple attributes in the same find by separating them with &quot;_and_&quot;, so you get finders like
</span><span class="inferred0"><a name="line283"></a> 283   # &lt;tt&gt;Person.find_by_user_name_and_password&lt;/tt&gt; or even &lt;tt&gt;Payment.find_by_purchaser_and_state_and_country&lt;/tt&gt;. So instead of writing
</span><span class="inferred1"><a name="line284"></a> 284   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt;, you just do
</span><span class="inferred0"><a name="line285"></a> 285   # &lt;tt&gt;Person.find_by_user_name_and_password(user_name, password)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line286"></a> 286   #
</span><span class="inferred0"><a name="line287"></a> 287   # It's even possible to use all the additional parameters to find. For example, the full interface for &lt;tt&gt;Payment.find_all_by_amount&lt;/tt&gt;
</span><span class="inferred1"><a name="line288"></a> 288   # is actually &lt;tt&gt;Payment.find_all_by_amount(amount, options)&lt;/tt&gt;. And the full interface to &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt; is
</span><span class="inferred0"><a name="line289"></a> 289   # actually &lt;tt&gt;Person.find_by_user_name(user_name, options)&lt;/tt&gt;. So you could call &lt;tt&gt;Payment.find_all_by_amount(50, :order =&gt; &quot;created_on&quot;)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line290"></a> 290   # Also you may call &lt;tt&gt;Payment.find_last_by_amount(amount, options)&lt;/tt&gt; returning the last record matching that amount and options.
</span><span class="inferred0"><a name="line291"></a> 291   #
</span><span class="inferred1"><a name="line292"></a> 292   # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with
</span><span class="inferred0"><a name="line293"></a> 293   # &lt;tt&gt;find_or_create_by_&lt;/tt&gt; and will return the object if it already exists and otherwise creates it, then returns it. Protected attributes won't be set unless they are given in a block. For example:
</span><span class="inferred1"><a name="line294"></a> 294   #
</span><span class="inferred0"><a name="line295"></a> 295   #   # No 'Summer' tag exists
</span><span class="inferred1"><a name="line296"></a> 296   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.create(:name =&gt; &quot;Summer&quot;)
</span><span class="inferred0"><a name="line297"></a> 297   #
</span><span class="inferred1"><a name="line298"></a> 298   #   # Now the 'Summer' tag does exist
</span><span class="inferred0"><a name="line299"></a> 299   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.find_by_name(&quot;Summer&quot;)
</span><span class="inferred1"><a name="line300"></a> 300   #
</span><span class="inferred0"><a name="line301"></a> 301   #   # Now 'Bob' exist and is an 'admin'
</span><span class="inferred1"><a name="line302"></a> 302   #   User.find_or_create_by_name('Bob', :age =&gt; 40) { |u| u.admin = true }
</span><span class="inferred0"><a name="line303"></a> 303   #
</span><span class="inferred1"><a name="line304"></a> 304   # Use the &lt;tt&gt;find_or_initialize_by_&lt;/tt&gt; finder if you want to return a new record without saving it first. Protected attributes won't be set unless they are given in a block. For example:
</span><span class="inferred0"><a name="line305"></a> 305   #
</span><span class="inferred1"><a name="line306"></a> 306   #   # No 'Winter' tag exists
</span><span class="inferred0"><a name="line307"></a> 307   #   winter = Tag.find_or_initialize_by_name(&quot;Winter&quot;)
</span><span class="inferred1"><a name="line308"></a> 308   #   winter.new_record? # true
</span><span class="inferred0"><a name="line309"></a> 309   #
</span><span class="inferred1"><a name="line310"></a> 310   # To find by a subset of the attributes to be used for instantiating a new object, pass a hash instead of
</span><span class="inferred0"><a name="line311"></a> 311   # a list of parameters. For example:
</span><span class="inferred1"><a name="line312"></a> 312   #
</span><span class="inferred0"><a name="line313"></a> 313   #   Tag.find_or_create_by_name(:name =&gt; &quot;rails&quot;, :creator =&gt; current_user)
</span><span class="inferred1"><a name="line314"></a> 314   #
</span><span class="inferred0"><a name="line315"></a> 315   # That will either find an existing tag named &quot;rails&quot;, or create a new one while setting the user that created it.
</span><span class="inferred1"><a name="line316"></a> 316   #
</span><span class="inferred0"><a name="line317"></a> 317   # == Saving arrays, hashes, and other non-mappable objects in text columns
</span><span class="inferred1"><a name="line318"></a> 318   #
</span><span class="inferred0"><a name="line319"></a> 319   # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.
</span><span class="inferred1"><a name="line320"></a> 320   # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:
</span><span class="inferred0"><a name="line321"></a> 321   #
</span><span class="inferred1"><a name="line322"></a> 322   #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line323"></a> 323   #     serialize :preferences
</span><span class="inferred1"><a name="line324"></a> 324   #   end
</span><span class="inferred0"><a name="line325"></a> 325   #
</span><span class="inferred1"><a name="line326"></a> 326   #   user = User.create(:preferences =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large })
</span><span class="inferred0"><a name="line327"></a> 327   #   User.find(user.id).preferences # =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large }
</span><span class="inferred1"><a name="line328"></a> 328   #
</span><span class="inferred0"><a name="line329"></a> 329   # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a
</span><span class="inferred1"><a name="line330"></a> 330   # descendant of a class not in the hierarchy. Example:
</span><span class="inferred0"><a name="line331"></a> 331   #
</span><span class="inferred1"><a name="line332"></a> 332   #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line333"></a> 333   #     serialize :preferences, Hash
</span><span class="inferred1"><a name="line334"></a> 334   #   end
</span><span class="inferred0"><a name="line335"></a> 335   #
</span><span class="inferred1"><a name="line336"></a> 336   #   user = User.create(:preferences =&gt; %w( one two three ))
</span><span class="inferred0"><a name="line337"></a> 337   #   User.find(user.id).preferences    # raises SerializationTypeMismatch
</span><span class="inferred1"><a name="line338"></a> 338   #
</span><span class="inferred0"><a name="line339"></a> 339   # == Single table inheritance
</span><span class="inferred1"><a name="line340"></a> 340   #
</span><span class="inferred0"><a name="line341"></a> 341   # Active Record allows inheritance by storing the name of the class in a column that by default is named &quot;type&quot; (can be changed
</span><span class="inferred1"><a name="line342"></a> 342   # by overwriting &lt;tt&gt;Base.inheritance_column&lt;/tt&gt;). This means that an inheritance looking like this:
</span><span class="inferred0"><a name="line343"></a> 343   #
</span><span class="inferred1"><a name="line344"></a> 344   #   class Company &lt; ActiveRecord::Base; end
</span><span class="inferred0"><a name="line345"></a> 345   #   class Firm &lt; Company; end
</span><span class="inferred1"><a name="line346"></a> 346   #   class Client &lt; Company; end
</span><span class="inferred0"><a name="line347"></a> 347   #   class PriorityClient &lt; Client; end
</span><span class="inferred1"><a name="line348"></a> 348   #
</span><span class="inferred0"><a name="line349"></a> 349   # When you do &lt;tt&gt;Firm.create(:name =&gt; &quot;37signals&quot;)&lt;/tt&gt;, this record will be saved in the companies table with type = &quot;Firm&quot;. You can then
</span><span class="inferred1"><a name="line350"></a> 350   # fetch this row again using &lt;tt&gt;Company.find(:first, &quot;name = '37signals'&quot;)&lt;/tt&gt; and it will return a Firm object.
</span><span class="inferred0"><a name="line351"></a> 351   #
</span><span class="inferred1"><a name="line352"></a> 352   # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just
</span><span class="inferred0"><a name="line353"></a> 353   # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.
</span><span class="inferred1"><a name="line354"></a> 354   #
</span><span class="inferred0"><a name="line355"></a> 355   # Note, all the attributes for all the cases are kept in the same table. Read more:
</span><span class="inferred1"><a name="line356"></a> 356   # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
</span><span class="inferred0"><a name="line357"></a> 357   #
</span><span class="inferred1"><a name="line358"></a> 358   # == Connection to multiple databases in different models
</span><span class="inferred0"><a name="line359"></a> 359   #
</span><span class="inferred1"><a name="line360"></a> 360   # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.
</span><span class="inferred0"><a name="line361"></a> 361   # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.
</span><span class="inferred1"><a name="line362"></a> 362   # For example, if Course is an ActiveRecord::Base, but resides in a different database, you can just say &lt;tt&gt;Course.establish_connection&lt;/tt&gt;
</span><span class="inferred0"><a name="line363"></a> 363   # and Course and all of its subclasses will use this connection instead.
</span><span class="inferred1"><a name="line364"></a> 364   #
</span><span class="inferred0"><a name="line365"></a> 365   # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is
</span><span class="inferred1"><a name="line366"></a> 366   # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.
</span><span class="inferred0"><a name="line367"></a> 367   #
</span><span class="inferred1"><a name="line368"></a> 368   # == Exceptions
</span><span class="inferred0"><a name="line369"></a> 369   #
</span><span class="inferred1"><a name="line370"></a> 370   # * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
</span><span class="inferred0"><a name="line371"></a> 371   # * AdapterNotSpecified - The configuration hash used in &lt;tt&gt;establish_connection&lt;/tt&gt; didn't include an
</span><span class="inferred1"><a name="line372"></a> 372   #   &lt;tt&gt;:adapter&lt;/tt&gt; key.
</span><span class="inferred0"><a name="line373"></a> 373   # * AdapterNotFound - The &lt;tt&gt;:adapter&lt;/tt&gt; key used in &lt;tt&gt;establish_connection&lt;/tt&gt; specified a non-existent adapter
</span><span class="inferred1"><a name="line374"></a> 374   #   (or a bad spelling of an existing one).
</span><span class="inferred0"><a name="line375"></a> 375   # * AssociationTypeMismatch - The object assigned to the association wasn't of the type specified in the association definition.
</span><span class="inferred1"><a name="line376"></a> 376   # * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
</span><span class="inferred0"><a name="line377"></a> 377   # * ConnectionNotEstablished+ - No connection has been established. Use &lt;tt&gt;establish_connection&lt;/tt&gt; before querying.
</span><span class="inferred1"><a name="line378"></a> 378   # * RecordNotFound - No record responded to the +find+ method. Either the row with the given ID doesn't exist
</span><span class="inferred0"><a name="line379"></a> 379   #   or the row didn't meet the additional restrictions. Some +find+ calls do not raise this exception to signal
</span><span class="inferred1"><a name="line380"></a> 380   #   nothing was found, please check its documentation for further details.
</span><span class="inferred0"><a name="line381"></a> 381   # * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
</span><span class="inferred1"><a name="line382"></a> 382   # * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
</span><span class="inferred0"><a name="line383"></a> 383   #   &lt;tt&gt;attributes=&lt;/tt&gt; method. The +errors+ property of this exception contains an array of AttributeAssignmentError
</span><span class="inferred1"><a name="line384"></a> 384   #   objects that should be inspected to determine which attributes triggered the errors.
</span><span class="inferred0"><a name="line385"></a> 385   # * AttributeAssignmentError - An error occurred while doing a mass assignment through the &lt;tt&gt;attributes=&lt;/tt&gt; method.
</span><span class="inferred1"><a name="line386"></a> 386   #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.
</span><span class="inferred0"><a name="line387"></a> 387   #
</span><span class="inferred1"><a name="line388"></a> 388   # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
</span><span class="inferred0"><a name="line389"></a> 389   # So it's possible to assign a logger to the class through &lt;tt&gt;Base.logger=&lt;/tt&gt; which will then be used by all
</span><span class="inferred1"><a name="line390"></a> 390   # instances in the current object space.
</span><span class="marked0"><a name="line391"></a> 391   class Base
</span><span class="inferred1"><a name="line392"></a> 392     ##  
</span><span class="inferred0"><a name="line393"></a> 393     # :singleton-method:
</span><span class="inferred1"><a name="line394"></a> 394     # Accepts a logger conforming to the interface of Log4r or the default Ruby 1.8+ Logger class, which is then passed
</span><span class="inferred0"><a name="line395"></a> 395     # on to any new database connections made and which can be retrieved on both a class and instance level by calling +logger+.
</span><span class="marked1"><a name="line396"></a> 396     cattr_accessor :logger, :instance_writer =&gt; false
</span><span class="inferred0"><a name="line397"></a> 397 
</span><span class="marked1"><a name="line398"></a> 398     def self.inherited(child) #:nodoc:
</span><span class="marked0"><a name="line399"></a> 399       @@subclasses[self] ||= []
</span><span class="marked1"><a name="line400"></a> 400       @@subclasses[self] &lt;&lt; child
</span><span class="marked0"><a name="line401"></a> 401       super
</span><span class="inferred1"><a name="line402"></a> 402     end
</span><span class="inferred0"><a name="line403"></a> 403 
</span><span class="marked1"><a name="line404"></a> 404     def self.reset_subclasses #:nodoc:
</span><span class="uncovered0"><a name="line405"></a> 405       nonreloadables = []
</span><span class="uncovered1"><a name="line406"></a> 406       subclasses.each do |klass|
</span><span class="uncovered0"><a name="line407"></a> 407         unless ActiveSupport::Dependencies.autoloaded? klass
</span><span class="uncovered1"><a name="line408"></a> 408           nonreloadables &lt;&lt; klass
</span><span class="uncovered0"><a name="line409"></a> 409           next
</span><span class="uncovered1"><a name="line410"></a> 410         end
</span><span class="uncovered0"><a name="line411"></a> 411         klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }
</span><span class="uncovered1"><a name="line412"></a> 412         klass.instance_methods(false).each { |m| klass.send :undef_method, m }
</span><span class="uncovered0"><a name="line413"></a> 413       end
</span><span class="uncovered1"><a name="line414"></a> 414       @@subclasses = {}
</span><span class="uncovered0"><a name="line415"></a> 415       nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) &lt;&lt; klass }
</span><span class="uncovered1"><a name="line416"></a> 416     end
</span><span class="inferred0"><a name="line417"></a> 417 
</span><span class="marked1"><a name="line418"></a> 418     @@subclasses = {}
</span><span class="inferred0"><a name="line419"></a> 419     
</span><span class="inferred1"><a name="line420"></a> 420     ##
</span><span class="inferred0"><a name="line421"></a> 421     # :singleton-method:
</span><span class="inferred1"><a name="line422"></a> 422     # Contains the database configuration - as is typically stored in config/database.yml -
</span><span class="inferred0"><a name="line423"></a> 423     # as a Hash.
</span><span class="inferred1"><a name="line424"></a> 424     #
</span><span class="inferred0"><a name="line425"></a> 425     # For example, the following database.yml...
</span><span class="inferred1"><a name="line426"></a> 426     # 
</span><span class="inferred0"><a name="line427"></a> 427     #   development:
</span><span class="inferred1"><a name="line428"></a> 428     #     adapter: sqlite3
</span><span class="inferred0"><a name="line429"></a> 429     #     database: db/development.sqlite3
</span><span class="inferred1"><a name="line430"></a> 430     #   
</span><span class="inferred0"><a name="line431"></a> 431     #   production:
</span><span class="inferred1"><a name="line432"></a> 432     #     adapter: sqlite3
</span><span class="inferred0"><a name="line433"></a> 433     #     database: db/production.sqlite3
</span><span class="inferred1"><a name="line434"></a> 434     #
</span><span class="inferred0"><a name="line435"></a> 435     # ...would result in ActiveRecord::Base.configurations to look like this:
</span><span class="inferred1"><a name="line436"></a> 436     #
</span><span class="inferred0"><a name="line437"></a> 437     #   {
</span><span class="inferred1"><a name="line438"></a> 438     #      'development' =&gt; {
</span><span class="inferred0"><a name="line439"></a> 439     #         'adapter'  =&gt; 'sqlite3',
</span><span class="inferred1"><a name="line440"></a> 440     #         'database' =&gt; 'db/development.sqlite3'
</span><span class="inferred0"><a name="line441"></a> 441     #      },
</span><span class="inferred1"><a name="line442"></a> 442     #      'production' =&gt; {
</span><span class="inferred0"><a name="line443"></a> 443     #         'adapter'  =&gt; 'sqlite3',
</span><span class="inferred1"><a name="line444"></a> 444     #         'database' =&gt; 'db/production.sqlite3'
</span><span class="inferred0"><a name="line445"></a> 445     #      }
</span><span class="inferred1"><a name="line446"></a> 446     #   }
</span><span class="marked0"><a name="line447"></a> 447     cattr_accessor :configurations, :instance_writer =&gt; false
</span><span class="marked1"><a name="line448"></a> 448     @@configurations = {}
</span><span class="inferred0"><a name="line449"></a> 449 
</span><span class="inferred1"><a name="line450"></a> 450     ##
</span><span class="inferred0"><a name="line451"></a> 451     # :singleton-method:
</span><span class="inferred1"><a name="line452"></a> 452     # Accessor for the prefix type that will be prepended to every primary key column name. The options are :table_name and
</span><span class="inferred0"><a name="line453"></a> 453     # :table_name_with_underscore. If the first is specified, the Product class will look for &quot;productid&quot; instead of &quot;id&quot; as
</span><span class="inferred1"><a name="line454"></a> 454     # the primary column. If the latter is specified, the Product class will look for &quot;product_id&quot; instead of &quot;id&quot;. Remember
</span><span class="inferred0"><a name="line455"></a> 455     # that this is a global setting for all Active Records.
</span><span class="marked1"><a name="line456"></a> 456     cattr_accessor :primary_key_prefix_type, :instance_writer =&gt; false
</span><span class="marked0"><a name="line457"></a> 457     @@primary_key_prefix_type = nil
</span><span class="inferred1"><a name="line458"></a> 458 
</span><span class="inferred0"><a name="line459"></a> 459     ##
</span><span class="inferred1"><a name="line460"></a> 460     # :singleton-method:
</span><span class="inferred0"><a name="line461"></a> 461     # Accessor for the name of the prefix string to prepend to every table name. So if set to &quot;basecamp_&quot;, all
</span><span class="inferred1"><a name="line462"></a> 462     # table names will be named like &quot;basecamp_projects&quot;, &quot;basecamp_people&quot;, etc. This is a convenient way of creating a namespace
</span><span class="inferred0"><a name="line463"></a> 463     # for tables in a shared database. By default, the prefix is the empty string.
</span><span class="marked1"><a name="line464"></a> 464     cattr_accessor :table_name_prefix, :instance_writer =&gt; false
</span><span class="marked0"><a name="line465"></a> 465     @@table_name_prefix = &quot;&quot;
</span><span class="inferred1"><a name="line466"></a> 466 
</span><span class="inferred0"><a name="line467"></a> 467     ##
</span><span class="inferred1"><a name="line468"></a> 468     # :singleton-method:
</span><span class="inferred0"><a name="line469"></a> 469     # Works like +table_name_prefix+, but appends instead of prepends (set to &quot;_basecamp&quot; gives &quot;projects_basecamp&quot;,
</span><span class="inferred1"><a name="line470"></a> 470     # &quot;people_basecamp&quot;). By default, the suffix is the empty string.
</span><span class="marked0"><a name="line471"></a> 471     cattr_accessor :table_name_suffix, :instance_writer =&gt; false
</span><span class="marked1"><a name="line472"></a> 472     @@table_name_suffix = &quot;&quot;
</span><span class="inferred0"><a name="line473"></a> 473 
</span><span class="inferred1"><a name="line474"></a> 474     ##
</span><span class="inferred0"><a name="line475"></a> 475     # :singleton-method:
</span><span class="inferred1"><a name="line476"></a> 476     # Indicates whether table names should be the pluralized versions of the corresponding class names.
</span><span class="inferred0"><a name="line477"></a> 477     # If true, the default table name for a Product class will be +products+. If false, it would just be +product+.
</span><span class="inferred1"><a name="line478"></a> 478     # See table_name for the full rules on table/class naming. This is true, by default.
</span><span class="marked0"><a name="line479"></a> 479     cattr_accessor :pluralize_table_names, :instance_writer =&gt; false
</span><span class="marked1"><a name="line480"></a> 480     @@pluralize_table_names = true
</span><span class="inferred0"><a name="line481"></a> 481 
</span><span class="inferred1"><a name="line482"></a> 482     ##
</span><span class="inferred0"><a name="line483"></a> 483     # :singleton-method:
</span><span class="inferred1"><a name="line484"></a> 484     # Determines whether to use ANSI codes to colorize the logging statements committed by the connection adapter. These colors
</span><span class="inferred0"><a name="line485"></a> 485     # make it much easier to overview things during debugging (when used through a reader like +tail+ and on a black background), but
</span><span class="inferred1"><a name="line486"></a> 486     # may complicate matters if you use software like syslog. This is true, by default.
</span><span class="marked0"><a name="line487"></a> 487     cattr_accessor :colorize_logging, :instance_writer =&gt; false
</span><span class="marked1"><a name="line488"></a> 488     @@colorize_logging = true
</span><span class="inferred0"><a name="line489"></a> 489 
</span><span class="inferred1"><a name="line490"></a> 490     ##
</span><span class="inferred0"><a name="line491"></a> 491     # :singleton-method:
</span><span class="inferred1"><a name="line492"></a> 492     # Determines whether to use Time.local (using :local) or Time.utc (using :utc) when pulling dates and times from the database.
</span><span class="inferred0"><a name="line493"></a> 493     # This is set to :local by default.
</span><span class="marked1"><a name="line494"></a> 494     cattr_accessor :default_timezone, :instance_writer =&gt; false
</span><span class="marked0"><a name="line495"></a> 495     @@default_timezone = :local
</span><span class="inferred1"><a name="line496"></a> 496 
</span><span class="inferred0"><a name="line497"></a> 497     ##
</span><span class="inferred1"><a name="line498"></a> 498     # :singleton-method:
</span><span class="inferred0"><a name="line499"></a> 499     # Specifies the format to use when dumping the database schema with Rails'
</span><span class="inferred1"><a name="line500"></a> 500     # Rakefile.  If :sql, the schema is dumped as (potentially database-
</span><span class="inferred0"><a name="line501"></a> 501     # specific) SQL statements.  If :ruby, the schema is dumped as an
</span><span class="inferred1"><a name="line502"></a> 502     # ActiveRecord::Schema file which can be loaded into any database that
</span><span class="inferred0"><a name="line503"></a> 503     # supports migrations.  Use :ruby if you want to have different database
</span><span class="inferred1"><a name="line504"></a> 504     # adapters for, e.g., your development and test environments.
</span><span class="marked0"><a name="line505"></a> 505     cattr_accessor :schema_format , :instance_writer =&gt; false
</span><span class="marked1"><a name="line506"></a> 506     @@schema_format = :ruby
</span><span class="inferred0"><a name="line507"></a> 507 
</span><span class="inferred1"><a name="line508"></a> 508     ##
</span><span class="inferred0"><a name="line509"></a> 509     # :singleton-method:
</span><span class="inferred1"><a name="line510"></a> 510     # Specify whether or not to use timestamps for migration numbers
</span><span class="marked0"><a name="line511"></a> 511     cattr_accessor :timestamped_migrations , :instance_writer =&gt; false
</span><span class="marked1"><a name="line512"></a> 512     @@timestamped_migrations = true
</span><span class="inferred0"><a name="line513"></a> 513 
</span><span class="inferred1"><a name="line514"></a> 514     # Determine whether to store the full constant name including namespace when using STI
</span><span class="marked0"><a name="line515"></a> 515     superclass_delegating_accessor :store_full_sti_class
</span><span class="marked1"><a name="line516"></a> 516     self.store_full_sti_class = false
</span><span class="inferred0"><a name="line517"></a> 517 
</span><span class="inferred1"><a name="line518"></a> 518     # Stores the default scope for the class
</span><span class="marked0"><a name="line519"></a> 519     class_inheritable_accessor :default_scoping, :instance_writer =&gt; false
</span><span class="marked1"><a name="line520"></a> 520     self.default_scoping = []
</span><span class="inferred0"><a name="line521"></a> 521 
</span><span class="marked1"><a name="line522"></a> 522     class &lt;&lt; self # Class methods
</span><span class="inferred0"><a name="line523"></a> 523       # Find operates with four different retrieval approaches:
</span><span class="inferred1"><a name="line524"></a> 524       #
</span><span class="inferred0"><a name="line525"></a> 525       # * Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
</span><span class="inferred1"><a name="line526"></a> 526       #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.
</span><span class="inferred0"><a name="line527"></a> 527       # * Find first - This will return the first record matched by the options used. These options can either be specific
</span><span class="inferred1"><a name="line528"></a> 528       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred0"><a name="line529"></a> 529       #   &lt;tt&gt;Model.find(:first, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.first(*args)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line530"></a> 530       # * Find last - This will return the last record matched by the options used. These options can either be specific
</span><span class="inferred0"><a name="line531"></a> 531       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred1"><a name="line532"></a> 532       #   &lt;tt&gt;Model.find(:last, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.last(*args)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line533"></a> 533       # * Find all - This will return all the records matched by the options used.
</span><span class="inferred1"><a name="line534"></a> 534       #   If no records are found, an empty array is returned. Use
</span><span class="inferred0"><a name="line535"></a> 535       #   &lt;tt&gt;Model.find(:all, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.all(*args)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line536"></a> 536       #
</span><span class="inferred0"><a name="line537"></a> 537       # All approaches accept an options hash as their last parameter.
</span><span class="inferred1"><a name="line538"></a> 538       #
</span><span class="inferred0"><a name="line539"></a> 539       # ==== Parameters
</span><span class="inferred1"><a name="line540"></a> 540       #
</span><span class="inferred0"><a name="line541"></a> 541       # * &lt;tt&gt;:conditions&lt;/tt&gt; - An SQL fragment like &quot;administrator = 1&quot;, &lt;tt&gt;[ &quot;user_name = ?&quot;, username ]&lt;/tt&gt;, or &lt;tt&gt;[&quot;user_name = :user_name&quot;, { :user_name =&gt; user_name }]&lt;/tt&gt;. See conditions in the intro.
</span><span class="inferred1"><a name="line542"></a> 542       # * &lt;tt&gt;:order&lt;/tt&gt; - An SQL fragment like &quot;created_at DESC, name&quot;.
</span><span class="inferred0"><a name="line543"></a> 543       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred1"><a name="line544"></a> 544       # * &lt;tt&gt;:having&lt;/tt&gt; - Combined with +:group+ this can be used to filter the records that a &lt;tt&gt;GROUP BY&lt;/tt&gt; returns. Uses the &lt;tt&gt;HAVING&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line545"></a> 545       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred1"><a name="line546"></a> 546       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip rows 0 through 4.
</span><span class="inferred0"><a name="line547"></a> 547       # * &lt;tt&gt;:joins&lt;/tt&gt; - Either an SQL fragment for additional joins like &quot;LEFT JOIN comments ON comments.post_id = id&quot; (rarely needed),
</span><span class="inferred1"><a name="line548"></a> 548       #   named associations in the same form used for the &lt;tt&gt;:include&lt;/tt&gt; option, which will perform an &lt;tt&gt;INNER JOIN&lt;/tt&gt; on the associated table(s),
</span><span class="inferred0"><a name="line549"></a> 549       #   or an array containing a mixture of both strings and named associations.
</span><span class="inferred1"><a name="line550"></a> 550       #   If the value is a string, then the records will be returned read-only since they will have attributes that do not correspond to the table's columns.
</span><span class="inferred0"><a name="line551"></a> 551       #   Pass &lt;tt&gt;:readonly =&gt; false&lt;/tt&gt; to override.
</span><span class="inferred1"><a name="line552"></a> 552       # * &lt;tt&gt;:include&lt;/tt&gt; - Names associations that should be loaded alongside. The symbols named refer
</span><span class="inferred0"><a name="line553"></a> 553       #   to already defined associations. See eager loading under Associations.
</span><span class="inferred1"><a name="line554"></a> 554       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &quot;*&quot; as in &quot;SELECT * FROM&quot;, but can be changed if you, for example, want to do a join but not
</span><span class="inferred0"><a name="line555"></a> 555       #   include the joined columns. Takes a string with the SELECT SQL fragment (e.g. &quot;id, name&quot;).
</span><span class="inferred1"><a name="line556"></a> 556       # * &lt;tt&gt;:from&lt;/tt&gt; - By default, this is the table name of the class, but can be changed to an alternate table name (or even the name
</span><span class="inferred0"><a name="line557"></a> 557       #   of a database view).
</span><span class="inferred1"><a name="line558"></a> 558       # * &lt;tt&gt;:readonly&lt;/tt&gt; - Mark the returned records read-only so they cannot be saved or updated.
</span><span class="inferred0"><a name="line559"></a> 559       # * &lt;tt&gt;:lock&lt;/tt&gt; - An SQL fragment like &quot;FOR UPDATE&quot; or &quot;LOCK IN SHARE MODE&quot;.
</span><span class="inferred1"><a name="line560"></a> 560       #   &lt;tt&gt;:lock =&gt; true&lt;/tt&gt; gives connection's default exclusive lock, usually &quot;FOR UPDATE&quot;.
</span><span class="inferred0"><a name="line561"></a> 561       #
</span><span class="inferred1"><a name="line562"></a> 562       # ==== Examples
</span><span class="inferred0"><a name="line563"></a> 563       #
</span><span class="inferred1"><a name="line564"></a> 564       #   # find by id
</span><span class="inferred0"><a name="line565"></a> 565       #   Person.find(1)       # returns the object for ID = 1
</span><span class="inferred1"><a name="line566"></a> 566       #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
</span><span class="inferred0"><a name="line567"></a> 567       #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
</span><span class="inferred1"><a name="line568"></a> 568       #   Person.find([1])     # returns an array for the object with ID = 1
</span><span class="inferred0"><a name="line569"></a> 569       #   Person.find(1, :conditions =&gt; &quot;administrator = 1&quot;, :order =&gt; &quot;created_on DESC&quot;)
</span><span class="inferred1"><a name="line570"></a> 570       #
</span><span class="inferred0"><a name="line571"></a> 571       # Note that returned records may not be in the same order as the ids you
</span><span class="inferred1"><a name="line572"></a> 572       # provide since database rows are unordered. Give an explicit &lt;tt&gt;:order&lt;/tt&gt;
</span><span class="inferred0"><a name="line573"></a> 573       # to ensure the results are sorted.
</span><span class="inferred1"><a name="line574"></a> 574       #
</span><span class="inferred0"><a name="line575"></a> 575       # ==== Examples
</span><span class="inferred1"><a name="line576"></a> 576       #
</span><span class="inferred0"><a name="line577"></a> 577       #   # find first
</span><span class="inferred1"><a name="line578"></a> 578       #   Person.find(:first) # returns the first object fetched by SELECT * FROM people
</span><span class="inferred0"><a name="line579"></a> 579       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred1"><a name="line580"></a> 580       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = :u&quot;, { :u =&gt; user_name }])
</span><span class="inferred0"><a name="line581"></a> 581       #   Person.find(:first, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred1"><a name="line582"></a> 582       #
</span><span class="inferred0"><a name="line583"></a> 583       #   # find last
</span><span class="inferred1"><a name="line584"></a> 584       #   Person.find(:last) # returns the last object fetched by SELECT * FROM people
</span><span class="inferred0"><a name="line585"></a> 585       #   Person.find(:last, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred1"><a name="line586"></a> 586       #   Person.find(:last, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred0"><a name="line587"></a> 587       #
</span><span class="inferred1"><a name="line588"></a> 588       #   # find all
</span><span class="inferred0"><a name="line589"></a> 589       #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people
</span><span class="inferred1"><a name="line590"></a> 590       #   Person.find(:all, :conditions =&gt; [ &quot;category IN (?)&quot;, categories], :limit =&gt; 50)
</span><span class="inferred0"><a name="line591"></a> 591       #   Person.find(:all, :conditions =&gt; { :friends =&gt; [&quot;Bob&quot;, &quot;Steve&quot;, &quot;Fred&quot;] }
</span><span class="inferred1"><a name="line592"></a> 592       #   Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
</span><span class="inferred0"><a name="line593"></a> 593       #   Person.find(:all, :include =&gt; [ :account, :friends ])
</span><span class="inferred1"><a name="line594"></a> 594       #   Person.find(:all, :group =&gt; &quot;category&quot;)
</span><span class="inferred0"><a name="line595"></a> 595       #
</span><span class="inferred1"><a name="line596"></a> 596       # Example for find with a lock: Imagine two concurrent transactions:
</span><span class="inferred0"><a name="line597"></a> 597       # each will read &lt;tt&gt;person.visits == 2&lt;/tt&gt;, add 1 to it, and save, resulting
</span><span class="inferred1"><a name="line598"></a> 598       # in two saves of &lt;tt&gt;person.visits = 3&lt;/tt&gt;.  By locking the row, the second
</span><span class="inferred0"><a name="line599"></a> 599       # transaction has to wait until the first is finished; we get the
</span><span class="inferred1"><a name="line600"></a> 600       # expected &lt;tt&gt;person.visits == 4&lt;/tt&gt;.
</span><span class="inferred0"><a name="line601"></a> 601       #
</span><span class="inferred1"><a name="line602"></a> 602       #   Person.transaction do
</span><span class="inferred0"><a name="line603"></a> 603       #     person = Person.find(1, :lock =&gt; true)
</span><span class="inferred1"><a name="line604"></a> 604       #     person.visits += 1
</span><span class="inferred0"><a name="line605"></a> 605       #     person.save!
</span><span class="inferred1"><a name="line606"></a> 606       #   end
</span><span class="marked0"><a name="line607"></a> 607       def find(*args)
</span><span class="uncovered1"><a name="line608"></a> 608         options = args.extract_options!
</span><span class="uncovered0"><a name="line609"></a> 609         validate_find_options(options)
</span><span class="uncovered1"><a name="line610"></a> 610         set_readonly_option!(options)
</span><span class="uncovered0"><a name="line611"></a> 611 
</span><span class="uncovered1"><a name="line612"></a> 612         case args.first
</span><span class="uncovered0"><a name="line613"></a> 613           when :first then find_initial(options)
</span><span class="uncovered1"><a name="line614"></a> 614           when :last  then find_last(options)
</span><span class="uncovered0"><a name="line615"></a> 615           when :all   then find_every(options)
</span><span class="uncovered1"><a name="line616"></a> 616           else             find_from_ids(args, options)
</span><span class="uncovered0"><a name="line617"></a> 617         end
</span><span class="uncovered1"><a name="line618"></a> 618       end
</span><span class="inferred0"><a name="line619"></a> 619 
</span><span class="inferred1"><a name="line620"></a> 620       # A convenience wrapper for &lt;tt&gt;find(:first, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred0"><a name="line621"></a> 621       # same arguments to this method as you can to &lt;tt&gt;find(:first)&lt;/tt&gt;.
</span><span class="marked1"><a name="line622"></a> 622       def first(*args)
</span><span class="uncovered0"><a name="line623"></a> 623         find(:first, *args)
</span><span class="uncovered1"><a name="line624"></a> 624       end
</span><span class="inferred0"><a name="line625"></a> 625 
</span><span class="inferred1"><a name="line626"></a> 626       # A convenience wrapper for &lt;tt&gt;find(:last, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred0"><a name="line627"></a> 627       # same arguments to this method as you can to &lt;tt&gt;find(:last)&lt;/tt&gt;.
</span><span class="marked1"><a name="line628"></a> 628       def last(*args)
</span><span class="uncovered0"><a name="line629"></a> 629         find(:last, *args)
</span><span class="uncovered1"><a name="line630"></a> 630       end
</span><span class="inferred0"><a name="line631"></a> 631 
</span><span class="inferred1"><a name="line632"></a> 632       # This is an alias for find(:all).  You can pass in all the same arguments to this method as you can
</span><span class="inferred0"><a name="line633"></a> 633       # to find(:all)
</span><span class="marked1"><a name="line634"></a> 634       def all(*args)
</span><span class="uncovered0"><a name="line635"></a> 635         find(:all, *args)
</span><span class="uncovered1"><a name="line636"></a> 636       end
</span><span class="inferred0"><a name="line637"></a> 637 
</span><span class="inferred1"><a name="line638"></a> 638       # Executes a custom SQL query against your database and returns all the results.  The results will
</span><span class="inferred0"><a name="line639"></a> 639       # be returned as an array with columns requested encapsulated as attributes of the model you call
</span><span class="inferred1"><a name="line640"></a> 640       # this method from.  If you call &lt;tt&gt;Product.find_by_sql&lt;/tt&gt; then the results will be returned in
</span><span class="inferred0"><a name="line641"></a> 641       # a Product object with the attributes you specified in the SQL query.
</span><span class="inferred1"><a name="line642"></a> 642       #
</span><span class="inferred0"><a name="line643"></a> 643       # If you call a complicated SQL query which spans multiple tables the columns specified by the
</span><span class="inferred1"><a name="line644"></a> 644       # SELECT will be attributes of the model, whether or not they are columns of the corresponding
</span><span class="inferred0"><a name="line645"></a> 645       # table.
</span><span class="inferred1"><a name="line646"></a> 646       #
</span><span class="inferred0"><a name="line647"></a> 647       # The +sql+ parameter is a full SQL query as a string.  It will be called as is, there will be
</span><span class="inferred1"><a name="line648"></a> 648       # no database agnostic conversions performed.  This should be a last resort because using, for example,
</span><span class="inferred0"><a name="line649"></a> 649       # MySQL specific terms will lock you to using that particular database engine or require you to
</span><span class="inferred1"><a name="line650"></a> 650       # change your call if you switch engines.
</span><span class="inferred0"><a name="line651"></a> 651       #
</span><span class="inferred1"><a name="line652"></a> 652       # ==== Examples
</span><span class="inferred0"><a name="line653"></a> 653       #   # A simple SQL query spanning multiple tables
</span><span class="inferred1"><a name="line654"></a> 654       #   Post.find_by_sql &quot;SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id&quot;
</span><span class="inferred0"><a name="line655"></a> 655       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;title&quot;=&gt;&quot;Ruby Meetup&quot;, &quot;first_name&quot;=&gt;&quot;Quentin&quot;}&gt;, ...]
</span><span class="inferred1"><a name="line656"></a> 656       #
</span><span class="inferred0"><a name="line657"></a> 657       #   # You can use the same string replacement techniques as you can with ActiveRecord#find
</span><span class="inferred1"><a name="line658"></a> 658       #   Post.find_by_sql [&quot;SELECT title FROM posts WHERE author = ? AND created &gt; ?&quot;, author_id, start_date]
</span><span class="inferred0"><a name="line659"></a> 659       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;first_name&quot;=&gt;&quot;The Cheap Man Buys Twice&quot;}&gt;, ...]
</span><span class="marked1"><a name="line660"></a> 660       def find_by_sql(sql)
</span><span class="uncovered0"><a name="line661"></a> 661         connection.select_all(sanitize_sql(sql), &quot;#{name} Load&quot;).collect! { |record| instantiate(record) }
</span><span class="uncovered1"><a name="line662"></a> 662       end
</span><span class="inferred0"><a name="line663"></a> 663 
</span><span class="inferred1"><a name="line664"></a> 664 
</span><span class="inferred0"><a name="line665"></a> 665       # Returns true if a record exists in the table that matches the +id+ or
</span><span class="inferred1"><a name="line666"></a> 666       # conditions given, or false otherwise. The argument can take four forms:
</span><span class="inferred0"><a name="line667"></a> 667       #
</span><span class="inferred1"><a name="line668"></a> 668       # * Integer - Finds the record with this primary key.
</span><span class="inferred0"><a name="line669"></a> 669       # * String - Finds the record with a primary key corresponding to this
</span><span class="inferred1"><a name="line670"></a> 670       #   string (such as &lt;tt&gt;'5'&lt;/tt&gt;).
</span><span class="inferred0"><a name="line671"></a> 671       # * Array - Finds the record that matches these +find+-style conditions
</span><span class="inferred1"><a name="line672"></a> 672       #   (such as &lt;tt&gt;['color = ?', 'red']&lt;/tt&gt;).
</span><span class="inferred0"><a name="line673"></a> 673       # * Hash - Finds the record that matches these +find+-style conditions
</span><span class="inferred1"><a name="line674"></a> 674       #   (such as &lt;tt&gt;{:color =&gt; 'red'}&lt;/tt&gt;).
</span><span class="inferred0"><a name="line675"></a> 675       #
</span><span class="inferred1"><a name="line676"></a> 676       # For more information about specifying conditions as a Hash or Array,
</span><span class="inferred0"><a name="line677"></a> 677       # see the Conditions section in the introduction to ActiveRecord::Base.
</span><span class="inferred1"><a name="line678"></a> 678       #
</span><span class="inferred0"><a name="line679"></a> 679       # Note: You can't pass in a condition as a string (like &lt;tt&gt;name =
</span><span class="inferred1"><a name="line680"></a> 680       # 'Jamie'&lt;/tt&gt;), since it would be sanitized and then queried against
</span><span class="inferred0"><a name="line681"></a> 681       # the primary key column, like &lt;tt&gt;id = 'name = \'Jamie\''&lt;/tt&gt;.
</span><span class="inferred1"><a name="line682"></a> 682       #
</span><span class="inferred0"><a name="line683"></a> 683       # ==== Examples
</span><span class="inferred1"><a name="line684"></a> 684       #   Person.exists?(5)
</span><span class="inferred0"><a name="line685"></a> 685       #   Person.exists?('5')
</span><span class="inferred1"><a name="line686"></a> 686       #   Person.exists?(:name =&gt; &quot;David&quot;)
</span><span class="inferred0"><a name="line687"></a> 687       #   Person.exists?(['name LIKE ?', &quot;%#{query}%&quot;])
</span><span class="marked1"><a name="line688"></a> 688       def exists?(id_or_conditions)
</span><span class="uncovered0"><a name="line689"></a> 689         connection.select_all(
</span><span class="uncovered1"><a name="line690"></a> 690           construct_finder_sql(
</span><span class="uncovered0"><a name="line691"></a> 691             :select     =&gt; &quot;#{quoted_table_name}.#{primary_key}&quot;,
</span><span class="uncovered1"><a name="line692"></a> 692             :conditions =&gt; expand_id_conditions(id_or_conditions),
</span><span class="uncovered0"><a name="line693"></a> 693             :limit      =&gt; 1
</span><span class="uncovered1"><a name="line694"></a> 694           ),
</span><span class="uncovered0"><a name="line695"></a> 695           &quot;#{name} Exists&quot;
</span><span class="uncovered1"><a name="line696"></a> 696         ).size &gt; 0
</span><span class="uncovered0"><a name="line697"></a> 697       end
</span><span class="inferred1"><a name="line698"></a> 698 
</span><span class="inferred0"><a name="line699"></a> 699       # Creates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred1"><a name="line700"></a> 700       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred0"><a name="line701"></a> 701       #
</span><span class="inferred1"><a name="line702"></a> 702       # The +attributes+ parameter can be either be a Hash or an Array of Hashes.  These Hashes describe the
</span><span class="inferred0"><a name="line703"></a> 703       # attributes on the objects that are to be created.
</span><span class="inferred1"><a name="line704"></a> 704       #
</span><span class="inferred0"><a name="line705"></a> 705       # ==== Examples
</span><span class="inferred1"><a name="line706"></a> 706       #   # Create a single new object
</span><span class="inferred0"><a name="line707"></a> 707       #   User.create(:first_name =&gt; 'Jamie')
</span><span class="inferred1"><a name="line708"></a> 708       #
</span><span class="inferred0"><a name="line709"></a> 709       #   # Create an Array of new objects
</span><span class="inferred1"><a name="line710"></a> 710       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
</span><span class="inferred0"><a name="line711"></a> 711       #
</span><span class="inferred1"><a name="line712"></a> 712       #   # Create a single object and pass it into a block to set other attributes.
</span><span class="inferred0"><a name="line713"></a> 713       #   User.create(:first_name =&gt; 'Jamie') do |u|
</span><span class="inferred1"><a name="line714"></a> 714       #     u.is_admin = false
</span><span class="inferred0"><a name="line715"></a> 715       #   end
</span><span class="inferred1"><a name="line716"></a> 716       #
</span><span class="inferred0"><a name="line717"></a> 717       #   # Creating an Array of new objects using a block, where the block is executed for each object:
</span><span class="inferred1"><a name="line718"></a> 718       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
</span><span class="inferred0"><a name="line719"></a> 719       #     u.is_admin = false
</span><span class="inferred1"><a name="line720"></a> 720       #   end
</span><span class="marked0"><a name="line721"></a> 721       def create(attributes = nil, &amp;block)
</span><span class="uncovered1"><a name="line722"></a> 722         if attributes.is_a?(Array)
</span><span class="uncovered0"><a name="line723"></a> 723           attributes.collect { |attr| create(attr, &amp;block) }
</span><span class="uncovered1"><a name="line724"></a> 724         else
</span><span class="uncovered0"><a name="line725"></a> 725           object = new(attributes)
</span><span class="uncovered1"><a name="line726"></a> 726           yield(object) if block_given?
</span><span class="uncovered0"><a name="line727"></a> 727           object.save
</span><span class="uncovered1"><a name="line728"></a> 728           object
</span><span class="uncovered0"><a name="line729"></a> 729         end
</span><span class="uncovered1"><a name="line730"></a> 730       end
</span><span class="inferred0"><a name="line731"></a> 731 
</span><span class="inferred1"><a name="line732"></a> 732       # Updates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred0"><a name="line733"></a> 733       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred1"><a name="line734"></a> 734       #
</span><span class="inferred0"><a name="line735"></a> 735       # ==== Parameters
</span><span class="inferred1"><a name="line736"></a> 736       #
</span><span class="inferred0"><a name="line737"></a> 737       # * +id+ - This should be the id or an array of ids to be updated.
</span><span class="inferred1"><a name="line738"></a> 738       # * +attributes+ - This should be a Hash of attributes to be set on the object, or an array of Hashes.
</span><span class="inferred0"><a name="line739"></a> 739       #
</span><span class="inferred1"><a name="line740"></a> 740       # ==== Examples
</span><span class="inferred0"><a name="line741"></a> 741       #
</span><span class="inferred1"><a name="line742"></a> 742       #   # Updating one record:
</span><span class="inferred0"><a name="line743"></a> 743       #   Person.update(15, { :user_name =&gt; 'Samuel', :group =&gt; 'expert' })
</span><span class="inferred1"><a name="line744"></a> 744       #
</span><span class="inferred0"><a name="line745"></a> 745       #   # Updating multiple records:
</span><span class="inferred1"><a name="line746"></a> 746       #   people = { 1 =&gt; { &quot;first_name&quot; =&gt; &quot;David&quot; }, 2 =&gt; { &quot;first_name&quot; =&gt; &quot;Jeremy&quot; } }
</span><span class="inferred0"><a name="line747"></a> 747       #   Person.update(people.keys, people.values)
</span><span class="marked1"><a name="line748"></a> 748       def update(id, attributes)
</span><span class="uncovered0"><a name="line749"></a> 749         if id.is_a?(Array)
</span><span class="uncovered1"><a name="line750"></a> 750           idx = -1
</span><span class="uncovered0"><a name="line751"></a> 751           id.collect { |one_id| idx += 1; update(one_id, attributes[idx]) }
</span><span class="uncovered1"><a name="line752"></a> 752         else
</span><span class="uncovered0"><a name="line753"></a> 753           object = find(id)
</span><span class="uncovered1"><a name="line754"></a> 754           object.update_attributes(attributes)
</span><span class="uncovered0"><a name="line755"></a> 755           object
</span><span class="uncovered1"><a name="line756"></a> 756         end
</span><span class="uncovered0"><a name="line757"></a> 757       end
</span><span class="inferred1"><a name="line758"></a> 758 
</span><span class="inferred0"><a name="line759"></a> 759       # Deletes the row with a primary key matching the +id+ argument, using a
</span><span class="inferred1"><a name="line760"></a> 760       # SQL +DELETE+ statement, and returns the number of rows deleted. Active
</span><span class="inferred0"><a name="line761"></a> 761       # Record objects are not instantiated, so the object's callbacks are not
</span><span class="inferred1"><a name="line762"></a> 762       # executed, including any &lt;tt&gt;:dependent&lt;/tt&gt; association options or
</span><span class="inferred0"><a name="line763"></a> 763       # Observer methods.
</span><span class="inferred1"><a name="line764"></a> 764       #
</span><span class="inferred0"><a name="line765"></a> 765       # You can delete multiple rows at once by passing an Array of &lt;tt&gt;id&lt;/tt&gt;s.
</span><span class="inferred1"><a name="line766"></a> 766       #
</span><span class="inferred0"><a name="line767"></a> 767       # Note: Although it is often much faster than the alternative,
</span><span class="inferred1"><a name="line768"></a> 768       # &lt;tt&gt;#destroy&lt;/tt&gt;, skipping callbacks might bypass business logic in
</span><span class="inferred0"><a name="line769"></a> 769       # your application that ensures referential integrity or performs other
</span><span class="inferred1"><a name="line770"></a> 770       # essential jobs.
</span><span class="inferred0"><a name="line771"></a> 771       #
</span><span class="inferred1"><a name="line772"></a> 772       # ==== Examples
</span><span class="inferred0"><a name="line773"></a> 773       #
</span><span class="inferred1"><a name="line774"></a> 774       #   # Delete a single row
</span><span class="inferred0"><a name="line775"></a> 775       #   Todo.delete(1)
</span><span class="inferred1"><a name="line776"></a> 776       #
</span><span class="inferred0"><a name="line777"></a> 777       #   # Delete multiple rows
</span><span class="inferred1"><a name="line778"></a> 778       #   Todo.delete([2,3,4])
</span><span class="marked0"><a name="line779"></a> 779       def delete(id)
</span><span class="uncovered1"><a name="line780"></a> 780         delete_all([ &quot;#{connection.quote_column_name(primary_key)} IN (?)&quot;, id ])
</span><span class="uncovered0"><a name="line781"></a> 781       end
</span><span class="inferred1"><a name="line782"></a> 782 
</span><span class="inferred0"><a name="line783"></a> 783       # Destroy an object (or multiple objects) that has the given id, the object is instantiated first,
</span><span class="inferred1"><a name="line784"></a> 784       # therefore all callbacks and filters are fired off before the object is deleted.  This method is
</span><span class="inferred0"><a name="line785"></a> 785       # less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.
</span><span class="inferred1"><a name="line786"></a> 786       #
</span><span class="inferred0"><a name="line787"></a> 787       # This essentially finds the object (or multiple objects) with the given id, creates a new object
</span><span class="inferred1"><a name="line788"></a> 788       # from the attributes, and then calls destroy on it.
</span><span class="inferred0"><a name="line789"></a> 789       #
</span><span class="inferred1"><a name="line790"></a> 790       # ==== Parameters
</span><span class="inferred0"><a name="line791"></a> 791       #
</span><span class="inferred1"><a name="line792"></a> 792       # * +id+ - Can be either an Integer or an Array of Integers.
</span><span class="inferred0"><a name="line793"></a> 793       #
</span><span class="inferred1"><a name="line794"></a> 794       # ==== Examples
</span><span class="inferred0"><a name="line795"></a> 795       #
</span><span class="inferred1"><a name="line796"></a> 796       #   # Destroy a single object
</span><span class="inferred0"><a name="line797"></a> 797       #   Todo.destroy(1)
</span><span class="inferred1"><a name="line798"></a> 798       #
</span><span class="inferred0"><a name="line799"></a> 799       #   # Destroy multiple objects
</span><span class="inferred1"><a name="line800"></a> 800       #   todos = [1,2,3]
</span><span class="inferred0"><a name="line801"></a> 801       #   Todo.destroy(todos)
</span><span class="marked1"><a name="line802"></a> 802       def destroy(id)
</span><span class="uncovered0"><a name="line803"></a> 803         if id.is_a?(Array)
</span><span class="uncovered1"><a name="line804"></a> 804           id.map { |one_id| destroy(one_id) }
</span><span class="uncovered0"><a name="line805"></a> 805         else
</span><span class="uncovered1"><a name="line806"></a> 806           find(id).destroy
</span><span class="uncovered0"><a name="line807"></a> 807         end
</span><span class="uncovered1"><a name="line808"></a> 808       end
</span><span class="inferred0"><a name="line809"></a> 809 
</span><span class="inferred1"><a name="line810"></a> 810       # Updates all records with details given if they match a set of conditions supplied, limits and order can
</span><span class="inferred0"><a name="line811"></a> 811       # also be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the
</span><span class="inferred1"><a name="line812"></a> 812       # database. It does not instantiate the involved models and it does not trigger Active Record callbacks.
</span><span class="inferred0"><a name="line813"></a> 813       #
</span><span class="inferred1"><a name="line814"></a> 814       # ==== Parameters
</span><span class="inferred0"><a name="line815"></a> 815       #
</span><span class="inferred1"><a name="line816"></a> 816       # * +updates+ - A string of column and value pairs that will be set on any records that match conditions. This creates the SET clause of the generated SQL.
</span><span class="inferred0"><a name="line817"></a> 817       # * +conditions+ - An SQL fragment like &quot;administrator = 1&quot; or [ &quot;user_name = ?&quot;, username ]. See conditions in the intro for more info.
</span><span class="inferred1"><a name="line818"></a> 818       # * +options+ - Additional options are &lt;tt&gt;:limit&lt;/tt&gt; and &lt;tt&gt;:order&lt;/tt&gt;, see the examples for usage.
</span><span class="inferred0"><a name="line819"></a> 819       #
</span><span class="inferred1"><a name="line820"></a> 820       # ==== Examples
</span><span class="inferred0"><a name="line821"></a> 821       #
</span><span class="inferred1"><a name="line822"></a> 822       #   # Update all billing objects with the 3 different attributes given
</span><span class="inferred0"><a name="line823"></a> 823       #   Billing.update_all( &quot;category = 'authorized', approved = 1, author = 'David'&quot; )
</span><span class="inferred1"><a name="line824"></a> 824       #
</span><span class="inferred0"><a name="line825"></a> 825       #   # Update records that match our conditions
</span><span class="inferred1"><a name="line826"></a> 826       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot; )
</span><span class="inferred0"><a name="line827"></a> 827       #
</span><span class="inferred1"><a name="line828"></a> 828       #   # Update records that match our conditions but limit it to 5 ordered by date
</span><span class="inferred0"><a name="line829"></a> 829       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot;,
</span><span class="inferred1"><a name="line830"></a> 830       #                         :order =&gt; 'created_at', :limit =&gt; 5 )
</span><span class="marked0"><a name="line831"></a> 831       def update_all(updates, conditions = nil, options = {})
</span><span class="uncovered1"><a name="line832"></a> 832         sql  = &quot;UPDATE #{quoted_table_name} SET #{sanitize_sql_for_assignment(updates)} &quot;
</span><span class="uncovered0"><a name="line833"></a> 833 
</span><span class="uncovered1"><a name="line834"></a> 834         scope = scope(:find)
</span><span class="uncovered0"><a name="line835"></a> 835 
</span><span class="uncovered1"><a name="line836"></a> 836         select_sql = &quot;&quot;
</span><span class="uncovered0"><a name="line837"></a> 837         add_conditions!(select_sql, conditions, scope)
</span><span class="uncovered1"><a name="line838"></a> 838 
</span><span class="uncovered0"><a name="line839"></a> 839         if options.has_key?(:limit) || (scope &amp;&amp; scope[:limit])
</span><span class="uncovered1"><a name="line840"></a> 840           # Only take order from scope if limit is also provided by scope, this
</span><span class="uncovered0"><a name="line841"></a> 841           # is useful for updating a has_many association with a limit.
</span><span class="uncovered1"><a name="line842"></a> 842           add_order!(select_sql, options[:order], scope)
</span><span class="uncovered0"><a name="line843"></a> 843 
</span><span class="uncovered1"><a name="line844"></a> 844           add_limit!(select_sql, options, scope)
</span><span class="uncovered0"><a name="line845"></a> 845           sql.concat(connection.limited_update_conditions(select_sql, quoted_table_name, connection.quote_column_name(primary_key)))
</span><span class="uncovered1"><a name="line846"></a> 846         else
</span><span class="uncovered0"><a name="line847"></a> 847           add_order!(select_sql, options[:order], nil)
</span><span class="uncovered1"><a name="line848"></a> 848           sql.concat(select_sql)
</span><span class="uncovered0"><a name="line849"></a> 849         end
</span><span class="uncovered1"><a name="line850"></a> 850 
</span><span class="uncovered0"><a name="line851"></a> 851         connection.update(sql, &quot;#{name} Update&quot;)
</span><span class="uncovered1"><a name="line852"></a> 852       end
</span><span class="inferred0"><a name="line853"></a> 853 
</span><span class="inferred1"><a name="line854"></a> 854       # Destroys the records matching +conditions+ by instantiating each
</span><span class="inferred0"><a name="line855"></a> 855       # record and calling its +destroy+ method. Each object's callbacks are
</span><span class="inferred1"><a name="line856"></a> 856       # executed (including &lt;tt&gt;:dependent&lt;/tt&gt; association options and
</span><span class="inferred0"><a name="line857"></a> 857       # +before_destroy+/+after_destroy+ Observer methods). Returns the
</span><span class="inferred1"><a name="line858"></a> 858       # collection of objects that were destroyed; each will be frozen, to
</span><span class="inferred0"><a name="line859"></a> 859       # reflect that no changes should be made (since they can't be
</span><span class="inferred1"><a name="line860"></a> 860       # persisted).
</span><span class="inferred0"><a name="line861"></a> 861       #
</span><span class="inferred1"><a name="line862"></a> 862       # Note: Instantiation, callback execution, and deletion of each
</span><span class="inferred0"><a name="line863"></a> 863       # record can be time consuming when you're removing many records at
</span><span class="inferred1"><a name="line864"></a> 864       # once. It generates at least one SQL +DELETE+ query per record (or
</span><span class="inferred0"><a name="line865"></a> 865       # possibly more, to enforce your callbacks). If you want to delete many
</span><span class="inferred1"><a name="line866"></a> 866       # rows quickly, without concern for their associations or callbacks, use
</span><span class="inferred0"><a name="line867"></a> 867       # +delete_all+ instead.
</span><span class="inferred1"><a name="line868"></a> 868       #
</span><span class="inferred0"><a name="line869"></a> 869       # ==== Parameters
</span><span class="inferred1"><a name="line870"></a> 870       #
</span><span class="inferred0"><a name="line871"></a> 871       # * +conditions+ - A string, array, or hash that specifies which records
</span><span class="inferred1"><a name="line872"></a> 872       #   to destroy. If omitted, all records are destroyed. See the
</span><span class="inferred0"><a name="line873"></a> 873       #   Conditions section in the introduction to ActiveRecord::Base for
</span><span class="inferred1"><a name="line874"></a> 874       #   more information.
</span><span class="inferred0"><a name="line875"></a> 875       #
</span><span class="inferred1"><a name="line876"></a> 876       # ==== Examples
</span><span class="inferred0"><a name="line877"></a> 877       #
</span><span class="inferred1"><a name="line878"></a> 878       #   Person.destroy_all(&quot;last_login &lt; '2004-04-04'&quot;)
</span><span class="inferred0"><a name="line879"></a> 879       #   Person.destroy_all(:status =&gt; &quot;inactive&quot;)
</span><span class="marked1"><a name="line880"></a> 880       def destroy_all(conditions = nil)
</span><span class="uncovered0"><a name="line881"></a> 881         find(:all, :conditions =&gt; conditions).each { |object| object.destroy }
</span><span class="uncovered1"><a name="line882"></a> 882       end
</span><span class="inferred0"><a name="line883"></a> 883 
</span><span class="inferred1"><a name="line884"></a> 884       # Deletes the records matching +conditions+ without instantiating the records first, and hence not
</span><span class="inferred0"><a name="line885"></a> 885       # calling the +destroy+ method nor invoking callbacks. This is a single SQL DELETE statement that
</span><span class="inferred1"><a name="line886"></a> 886       # goes straight to the database, much more efficient than +destroy_all+. Be careful with relations
</span><span class="inferred0"><a name="line887"></a> 887       # though, in particular &lt;tt&gt;:dependent&lt;/tt&gt; rules defined on associations are not honored.
</span><span class="inferred1"><a name="line888"></a> 888       #
</span><span class="inferred0"><a name="line889"></a> 889       # ==== Parameters
</span><span class="inferred1"><a name="line890"></a> 890       #
</span><span class="inferred0"><a name="line891"></a> 891       # * +conditions+ - Conditions are specified the same way as with +find+ method.
</span><span class="inferred1"><a name="line892"></a> 892       #
</span><span class="inferred0"><a name="line893"></a> 893       # ==== Example
</span><span class="inferred1"><a name="line894"></a> 894       #
</span><span class="inferred0"><a name="line895"></a> 895       #   Post.delete_all(&quot;person_id = 5 AND (category = 'Something' OR category = 'Else')&quot;)
</span><span class="inferred1"><a name="line896"></a> 896       #   Post.delete_all([&quot;person_id = ? AND (category = ? OR category = ?)&quot;, 5, 'Something', 'Else'])
</span><span class="inferred0"><a name="line897"></a> 897       #
</span><span class="inferred1"><a name="line898"></a> 898       # Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent
</span><span class="inferred0"><a name="line899"></a> 899       # associations or call your &lt;tt&gt;before_*&lt;/tt&gt; or +after_destroy+ callbacks, use the +destroy_all+ method instead.
</span><span class="marked1"><a name="line900"></a> 900       def delete_all(conditions = nil)
</span><span class="uncovered0"><a name="line901"></a> 901         sql = &quot;DELETE FROM #{quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line902"></a> 902         add_conditions!(sql, conditions, scope(:find))
</span><span class="uncovered0"><a name="line903"></a> 903         connection.delete(sql, &quot;#{name} Delete all&quot;)
</span><span class="uncovered1"><a name="line904"></a> 904       end
</span><span class="inferred0"><a name="line905"></a> 905 
</span><span class="inferred1"><a name="line906"></a> 906       # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
</span><span class="inferred0"><a name="line907"></a> 907       # The use of this method should be restricted to complicated SQL queries that can't be executed
</span><span class="inferred1"><a name="line908"></a> 908       # using the ActiveRecord::Calculations class methods.  Look into those before using this.
</span><span class="inferred0"><a name="line909"></a> 909       #
</span><span class="inferred1"><a name="line910"></a> 910       # ==== Parameters
</span><span class="inferred0"><a name="line911"></a> 911       #
</span><span class="inferred1"><a name="line912"></a> 912       # * +sql+ - An SQL statement which should return a count query from the database, see the example below.
</span><span class="inferred0"><a name="line913"></a> 913       #
</span><span class="inferred1"><a name="line914"></a> 914       # ==== Examples
</span><span class="inferred0"><a name="line915"></a> 915       #
</span><span class="inferred1"><a name="line916"></a> 916       #   Product.count_by_sql &quot;SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id&quot;
</span><span class="marked0"><a name="line917"></a> 917       def count_by_sql(sql)
</span><span class="uncovered1"><a name="line918"></a> 918         sql = sanitize_conditions(sql)
</span><span class="uncovered0"><a name="line919"></a> 919         connection.select_value(sql, &quot;#{name} Count&quot;).to_i
</span><span class="uncovered1"><a name="line920"></a> 920       end
</span><span class="inferred0"><a name="line921"></a> 921 
</span><span class="inferred1"><a name="line922"></a> 922       # A generic &quot;counter updater&quot; implementation, intended primarily to be
</span><span class="inferred0"><a name="line923"></a> 923       # used by increment_counter and decrement_counter, but which may also
</span><span class="inferred1"><a name="line924"></a> 924       # be useful on its own. It simply does a direct SQL update for the record
</span><span class="inferred0"><a name="line925"></a> 925       # with the given ID, altering the given hash of counters by the amount
</span><span class="inferred1"><a name="line926"></a> 926       # given by the corresponding value:
</span><span class="inferred0"><a name="line927"></a> 927       #
</span><span class="inferred1"><a name="line928"></a> 928       # ==== Parameters
</span><span class="inferred0"><a name="line929"></a> 929       #
</span><span class="inferred1"><a name="line930"></a> 930       # * +id+ - The id of the object you wish to update a counter on or an Array of ids.
</span><span class="inferred0"><a name="line931"></a> 931       # * +counters+ - An Array of Hashes containing the names of the fields
</span><span class="inferred1"><a name="line932"></a> 932       #   to update as keys and the amount to update the field by as values.
</span><span class="inferred0"><a name="line933"></a> 933       #
</span><span class="inferred1"><a name="line934"></a> 934       # ==== Examples
</span><span class="inferred0"><a name="line935"></a> 935       #
</span><span class="inferred1"><a name="line936"></a> 936       #   # For the Post with id of 5, decrement the comment_count by 1, and
</span><span class="inferred0"><a name="line937"></a> 937       #   # increment the action_count by 1
</span><span class="inferred1"><a name="line938"></a> 938       #   Post.update_counters 5, :comment_count =&gt; -1, :action_count =&gt; 1
</span><span class="inferred0"><a name="line939"></a> 939       #   # Executes the following SQL:
</span><span class="inferred1"><a name="line940"></a> 940       #   # UPDATE posts
</span><span class="inferred0"><a name="line941"></a> 941       #   #    SET comment_count = comment_count - 1,
</span><span class="inferred1"><a name="line942"></a> 942       #   #        action_count = action_count + 1
</span><span class="inferred0"><a name="line943"></a> 943       #   #  WHERE id = 5
</span><span class="inferred1"><a name="line944"></a> 944       #
</span><span class="inferred0"><a name="line945"></a> 945       #   # For the Posts with id of 10 and 15, increment the comment_count by 1
</span><span class="inferred1"><a name="line946"></a> 946       #   Post.update_counters [10, 15], :comment_count =&gt; 1
</span><span class="inferred0"><a name="line947"></a> 947       #   # Executes the following SQL:
</span><span class="inferred1"><a name="line948"></a> 948       #   # UPDATE posts
</span><span class="inferred0"><a name="line949"></a> 949       #   #    SET comment_count = comment_count + 1,
</span><span class="inferred1"><a name="line950"></a> 950       #   #  WHERE id IN (10, 15)
</span><span class="marked0"><a name="line951"></a> 951       def update_counters(id, counters)
</span><span class="uncovered1"><a name="line952"></a> 952         updates = counters.inject([]) { |list, (counter_name, increment)|
</span><span class="uncovered0"><a name="line953"></a> 953           sign = increment &lt; 0 ? &quot;-&quot; : &quot;+&quot;
</span><span class="uncovered1"><a name="line954"></a> 954           list &lt;&lt; &quot;#{connection.quote_column_name(counter_name)} = COALESCE(#{connection.quote_column_name(counter_name)}, 0) #{sign} #{increment.abs}&quot;
</span><span class="uncovered0"><a name="line955"></a> 955         }.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line956"></a> 956 
</span><span class="uncovered0"><a name="line957"></a> 957         if id.is_a?(Array)
</span><span class="uncovered1"><a name="line958"></a> 958           ids_list = id.map {|i| quote_value(i)}.join(', ')
</span><span class="uncovered0"><a name="line959"></a> 959           condition = &quot;IN  (#{ids_list})&quot;
</span><span class="uncovered1"><a name="line960"></a> 960         else
</span><span class="uncovered0"><a name="line961"></a> 961           condition = &quot;= #{quote_value(id)}&quot;
</span><span class="uncovered1"><a name="line962"></a> 962         end
</span><span class="uncovered0"><a name="line963"></a> 963 
</span><span class="uncovered1"><a name="line964"></a> 964         update_all(updates, &quot;#{connection.quote_column_name(primary_key)} #{condition}&quot;)
</span><span class="uncovered0"><a name="line965"></a> 965       end
</span><span class="inferred1"><a name="line966"></a> 966 
</span><span class="inferred0"><a name="line967"></a> 967       # Increment a number field by one, usually representing a count.
</span><span class="inferred1"><a name="line968"></a> 968       #
</span><span class="inferred0"><a name="line969"></a> 969       # This is used for caching aggregate values, so that they don't need to be computed every time.
</span><span class="inferred1"><a name="line970"></a> 970       # For example, a DiscussionBoard may cache post_count and comment_count otherwise every time the board is
</span><span class="inferred0"><a name="line971"></a> 971       # shown it would have to run an SQL query to find how many posts and comments there are.
</span><span class="inferred1"><a name="line972"></a> 972       #
</span><span class="inferred0"><a name="line973"></a> 973       # ==== Parameters
</span><span class="inferred1"><a name="line974"></a> 974       #
</span><span class="inferred0"><a name="line975"></a> 975       # * +counter_name+ - The name of the field that should be incremented.
</span><span class="inferred1"><a name="line976"></a> 976       # * +id+ - The id of the object that should be incremented.
</span><span class="inferred0"><a name="line977"></a> 977       #
</span><span class="inferred1"><a name="line978"></a> 978       # ==== Examples
</span><span class="inferred0"><a name="line979"></a> 979       #
</span><span class="inferred1"><a name="line980"></a> 980       #   # Increment the post_count column for the record with an id of 5
</span><span class="inferred0"><a name="line981"></a> 981       #   DiscussionBoard.increment_counter(:post_count, 5)
</span><span class="marked1"><a name="line982"></a> 982       def increment_counter(counter_name, id)
</span><span class="uncovered0"><a name="line983"></a> 983         update_counters(id, counter_name =&gt; 1)
</span><span class="uncovered1"><a name="line984"></a> 984       end
</span><span class="inferred0"><a name="line985"></a> 985 
</span><span class="inferred1"><a name="line986"></a> 986       # Decrement a number field by one, usually representing a count.
</span><span class="inferred0"><a name="line987"></a> 987       #
</span><span class="inferred1"><a name="line988"></a> 988       # This works the same as increment_counter but reduces the column value by 1 instead of increasing it.
</span><span class="inferred0"><a name="line989"></a> 989       #
</span><span class="inferred1"><a name="line990"></a> 990       # ==== Parameters
</span><span class="inferred0"><a name="line991"></a> 991       #
</span><span class="inferred1"><a name="line992"></a> 992       # * +counter_name+ - The name of the field that should be decremented.
</span><span class="inferred0"><a name="line993"></a> 993       # * +id+ - The id of the object that should be decremented.
</span><span class="inferred1"><a name="line994"></a> 994       #
</span><span class="inferred0"><a name="line995"></a> 995       # ==== Examples
</span><span class="inferred1"><a name="line996"></a> 996       #
</span><span class="inferred0"><a name="line997"></a> 997       #   # Decrement the post_count column for the record with an id of 5
</span><span class="inferred1"><a name="line998"></a> 998       #   DiscussionBoard.decrement_counter(:post_count, 5)
</span><span class="marked0"><a name="line999"></a> 999       def decrement_counter(counter_name, id)
</span><span class="uncovered1"><a name="line1000"></a>1000         update_counters(id, counter_name =&gt; -1)
</span><span class="uncovered0"><a name="line1001"></a>1001       end
</span><span class="inferred1"><a name="line1002"></a>1002 
</span><span class="inferred0"><a name="line1003"></a>1003 
</span><span class="inferred1"><a name="line1004"></a>1004       # Attributes named in this macro are protected from mass-assignment,
</span><span class="inferred0"><a name="line1005"></a>1005       # such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred1"><a name="line1006"></a>1006       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred0"><a name="line1007"></a>1007       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1008"></a>1008       #
</span><span class="inferred0"><a name="line1009"></a>1009       # Mass-assignment to these attributes will simply be ignored, to assign
</span><span class="inferred1"><a name="line1010"></a>1010       # to them you can use direct writer methods. This is meant to protect
</span><span class="inferred0"><a name="line1011"></a>1011       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred1"><a name="line1012"></a>1012       # tampering with URLs or forms.
</span><span class="inferred0"><a name="line1013"></a>1013       #
</span><span class="inferred1"><a name="line1014"></a>1014       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1015"></a>1015       #     attr_protected :credit_rating
</span><span class="inferred1"><a name="line1016"></a>1016       #   end
</span><span class="inferred0"><a name="line1017"></a>1017       #
</span><span class="inferred1"><a name="line1018"></a>1018       #   customer = Customer.new(&quot;name&quot; =&gt; David, &quot;credit_rating&quot; =&gt; &quot;Excellent&quot;)
</span><span class="inferred0"><a name="line1019"></a>1019       #   customer.credit_rating # =&gt; nil
</span><span class="inferred1"><a name="line1020"></a>1020       #   customer.attributes = { &quot;description&quot; =&gt; &quot;Jolly fellow&quot;, &quot;credit_rating&quot; =&gt; &quot;Superb&quot; }
</span><span class="inferred0"><a name="line1021"></a>1021       #   customer.credit_rating # =&gt; nil
</span><span class="inferred1"><a name="line1022"></a>1022       #
</span><span class="inferred0"><a name="line1023"></a>1023       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred1"><a name="line1024"></a>1024       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="inferred0"><a name="line1025"></a>1025       #
</span><span class="inferred1"><a name="line1026"></a>1026       # To start from an all-closed default and enable attributes as needed,
</span><span class="inferred0"><a name="line1027"></a>1027       # have a look at +attr_accessible+.
</span><span class="marked1"><a name="line1028"></a>1028       def attr_protected(*attributes)
</span><span class="uncovered0"><a name="line1029"></a>1029         write_inheritable_attribute(:attr_protected, Set.new(attributes.map(&amp;:to_s)) + (protected_attributes || []))
</span><span class="uncovered1"><a name="line1030"></a>1030       end
</span><span class="inferred0"><a name="line1031"></a>1031 
</span><span class="inferred1"><a name="line1032"></a>1032       # Returns an array of all the attributes that have been protected from mass-assignment.
</span><span class="marked0"><a name="line1033"></a>1033       def protected_attributes # :nodoc:
</span><span class="uncovered1"><a name="line1034"></a>1034         read_inheritable_attribute(:attr_protected)
</span><span class="uncovered0"><a name="line1035"></a>1035       end
</span><span class="inferred1"><a name="line1036"></a>1036 
</span><span class="inferred0"><a name="line1037"></a>1037       # Specifies a white list of model attributes that can be set via
</span><span class="inferred1"><a name="line1038"></a>1038       # mass-assignment, such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred0"><a name="line1039"></a>1039       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred1"><a name="line1040"></a>1040       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;
</span><span class="inferred0"><a name="line1041"></a>1041       #
</span><span class="inferred1"><a name="line1042"></a>1042       # This is the opposite of the +attr_protected+ macro: Mass-assignment
</span><span class="inferred0"><a name="line1043"></a>1043       # will only set attributes in this list, to assign to the rest of
</span><span class="inferred1"><a name="line1044"></a>1044       # attributes you can use direct writer methods. This is meant to protect
</span><span class="inferred0"><a name="line1045"></a>1045       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred1"><a name="line1046"></a>1046       # tampering with URLs or forms. If you'd rather start from an all-open
</span><span class="inferred0"><a name="line1047"></a>1047       # default and restrict attributes as needed, have a look at
</span><span class="inferred1"><a name="line1048"></a>1048       # +attr_protected+.
</span><span class="inferred0"><a name="line1049"></a>1049       #
</span><span class="inferred1"><a name="line1050"></a>1050       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1051"></a>1051       #     attr_accessible :name, :nickname
</span><span class="inferred1"><a name="line1052"></a>1052       #   end
</span><span class="inferred0"><a name="line1053"></a>1053       #
</span><span class="inferred1"><a name="line1054"></a>1054       #   customer = Customer.new(:name =&gt; &quot;David&quot;, :nickname =&gt; &quot;Dave&quot;, :credit_rating =&gt; &quot;Excellent&quot;)
</span><span class="inferred0"><a name="line1055"></a>1055       #   customer.credit_rating # =&gt; nil
</span><span class="inferred1"><a name="line1056"></a>1056       #   customer.attributes = { :name =&gt; &quot;Jolly fellow&quot;, :credit_rating =&gt; &quot;Superb&quot; }
</span><span class="inferred0"><a name="line1057"></a>1057       #   customer.credit_rating # =&gt; nil
</span><span class="inferred1"><a name="line1058"></a>1058       #
</span><span class="inferred0"><a name="line1059"></a>1059       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred1"><a name="line1060"></a>1060       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="marked0"><a name="line1061"></a>1061       def attr_accessible(*attributes)
</span><span class="uncovered1"><a name="line1062"></a>1062         write_inheritable_attribute(:attr_accessible, Set.new(attributes.map(&amp;:to_s)) + (accessible_attributes || []))
</span><span class="uncovered0"><a name="line1063"></a>1063       end
</span><span class="inferred1"><a name="line1064"></a>1064 
</span><span class="inferred0"><a name="line1065"></a>1065       # Returns an array of all the attributes that have been made accessible to mass-assignment.
</span><span class="marked1"><a name="line1066"></a>1066       def accessible_attributes # :nodoc:
</span><span class="uncovered0"><a name="line1067"></a>1067         read_inheritable_attribute(:attr_accessible)
</span><span class="uncovered1"><a name="line1068"></a>1068       end
</span><span class="inferred0"><a name="line1069"></a>1069 
</span><span class="inferred1"><a name="line1070"></a>1070        # Attributes listed as readonly can be set for a new record, but will be ignored in database updates afterwards.
</span><span class="marked0"><a name="line1071"></a>1071        def attr_readonly(*attributes)
</span><span class="uncovered1"><a name="line1072"></a>1072          write_inheritable_attribute(:attr_readonly, Set.new(attributes.map(&amp;:to_s)) + (readonly_attributes || []))
</span><span class="uncovered0"><a name="line1073"></a>1073        end
</span><span class="inferred1"><a name="line1074"></a>1074 
</span><span class="inferred0"><a name="line1075"></a>1075        # Returns an array of all the attributes that have been specified as readonly.
</span><span class="marked1"><a name="line1076"></a>1076        def readonly_attributes
</span><span class="uncovered0"><a name="line1077"></a>1077          read_inheritable_attribute(:attr_readonly)
</span><span class="uncovered1"><a name="line1078"></a>1078        end
</span><span class="inferred0"><a name="line1079"></a>1079 
</span><span class="inferred1"><a name="line1080"></a>1080       # If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object,
</span><span class="inferred0"><a name="line1081"></a>1081       # then specify the name of that attribute using this method and it will be handled automatically.
</span><span class="inferred1"><a name="line1082"></a>1082       # The serialization is done through YAML. If +class_name+ is specified, the serialized object must be of that
</span><span class="inferred0"><a name="line1083"></a>1083       # class on retrieval or SerializationTypeMismatch will be raised.
</span><span class="inferred1"><a name="line1084"></a>1084       #
</span><span class="inferred0"><a name="line1085"></a>1085       # ==== Parameters
</span><span class="inferred1"><a name="line1086"></a>1086       #
</span><span class="inferred0"><a name="line1087"></a>1087       # * +attr_name+ - The field name that should be serialized.
</span><span class="inferred1"><a name="line1088"></a>1088       # * +class_name+ - Optional, class name that the object type should be equal to.
</span><span class="inferred0"><a name="line1089"></a>1089       #
</span><span class="inferred1"><a name="line1090"></a>1090       # ==== Example
</span><span class="inferred0"><a name="line1091"></a>1091       #   # Serialize a preferences attribute
</span><span class="inferred1"><a name="line1092"></a>1092       #   class User
</span><span class="inferred0"><a name="line1093"></a>1093       #     serialize :preferences
</span><span class="inferred1"><a name="line1094"></a>1094       #   end
</span><span class="marked0"><a name="line1095"></a>1095       def serialize(attr_name, class_name = Object)
</span><span class="uncovered1"><a name="line1096"></a>1096         serialized_attributes[attr_name.to_s] = class_name
</span><span class="uncovered0"><a name="line1097"></a>1097       end
</span><span class="inferred1"><a name="line1098"></a>1098 
</span><span class="inferred0"><a name="line1099"></a>1099       # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.
</span><span class="marked1"><a name="line1100"></a>1100       def serialized_attributes
</span><span class="uncovered0"><a name="line1101"></a>1101         read_inheritable_attribute(:attr_serialized) or write_inheritable_attribute(:attr_serialized, {})
</span><span class="uncovered1"><a name="line1102"></a>1102       end
</span><span class="inferred0"><a name="line1103"></a>1103 
</span><span class="inferred1"><a name="line1104"></a>1104 
</span><span class="inferred0"><a name="line1105"></a>1105       # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending
</span><span class="inferred1"><a name="line1106"></a>1106       # directly from ActiveRecord::Base. So if the hierarchy looks like: Reply &lt; Message &lt; ActiveRecord::Base, then Message is used
</span><span class="inferred0"><a name="line1107"></a>1107       # to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class
</span><span class="inferred1"><a name="line1108"></a>1108       # in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.
</span><span class="inferred0"><a name="line1109"></a>1109       #
</span><span class="inferred1"><a name="line1110"></a>1110       # Nested classes are given table names prefixed by the singular form of
</span><span class="inferred0"><a name="line1111"></a>1111       # the parent's table name. Enclosing modules are not considered.
</span><span class="inferred1"><a name="line1112"></a>1112       #
</span><span class="inferred0"><a name="line1113"></a>1113       # ==== Examples
</span><span class="inferred1"><a name="line1114"></a>1114       #
</span><span class="inferred0"><a name="line1115"></a>1115       #   class Invoice &lt; ActiveRecord::Base; end;
</span><span class="inferred1"><a name="line1116"></a>1116       #   file                  class               table_name
</span><span class="inferred0"><a name="line1117"></a>1117       #   invoice.rb            Invoice             invoices
</span><span class="inferred1"><a name="line1118"></a>1118       #
</span><span class="inferred0"><a name="line1119"></a>1119       #   class Invoice &lt; ActiveRecord::Base; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred1"><a name="line1120"></a>1120       #   file                  class               table_name
</span><span class="inferred0"><a name="line1121"></a>1121       #   invoice.rb            Invoice::Lineitem   invoice_lineitems
</span><span class="inferred1"><a name="line1122"></a>1122       #
</span><span class="inferred0"><a name="line1123"></a>1123       #   module Invoice; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred1"><a name="line1124"></a>1124       #   file                  class               table_name
</span><span class="inferred0"><a name="line1125"></a>1125       #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
</span><span class="inferred1"><a name="line1126"></a>1126       #
</span><span class="inferred0"><a name="line1127"></a>1127       # Additionally, the class-level +table_name_prefix+ is prepended and the
</span><span class="inferred1"><a name="line1128"></a>1128       # +table_name_suffix+ is appended.  So if you have &quot;myapp_&quot; as a prefix,
</span><span class="inferred0"><a name="line1129"></a>1129       # the table name guess for an Invoice class becomes &quot;myapp_invoices&quot;.
</span><span class="inferred1"><a name="line1130"></a>1130       # Invoice::Lineitem becomes &quot;myapp_invoice_lineitems&quot;.
</span><span class="inferred0"><a name="line1131"></a>1131       #
</span><span class="inferred1"><a name="line1132"></a>1132       # You can also overwrite this class method to allow for unguessable
</span><span class="inferred0"><a name="line1133"></a>1133       # links, such as a Mouse class with a link to a &quot;mice&quot; table. Example:
</span><span class="inferred1"><a name="line1134"></a>1134       #
</span><span class="inferred0"><a name="line1135"></a>1135       #   class Mouse &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1136"></a>1136       #     set_table_name &quot;mice&quot;
</span><span class="inferred0"><a name="line1137"></a>1137       #   end
</span><span class="marked1"><a name="line1138"></a>1138       def table_name
</span><span class="uncovered0"><a name="line1139"></a>1139         reset_table_name
</span><span class="uncovered1"><a name="line1140"></a>1140       end
</span><span class="inferred0"><a name="line1141"></a>1141 
</span><span class="marked1"><a name="line1142"></a>1142       def reset_table_name #:nodoc:
</span><span class="uncovered0"><a name="line1143"></a>1143         base = base_class
</span><span class="uncovered1"><a name="line1144"></a>1144 
</span><span class="uncovered0"><a name="line1145"></a>1145         name =
</span><span class="uncovered1"><a name="line1146"></a>1146           # STI subclasses always use their superclass' table.
</span><span class="uncovered0"><a name="line1147"></a>1147           unless self == base
</span><span class="uncovered1"><a name="line1148"></a>1148             base.table_name
</span><span class="uncovered0"><a name="line1149"></a>1149           else
</span><span class="uncovered1"><a name="line1150"></a>1150             # Nested classes are prefixed with singular parent table name.
</span><span class="uncovered0"><a name="line1151"></a>1151             if parent &lt; ActiveRecord::Base &amp;&amp; !parent.abstract_class?
</span><span class="uncovered1"><a name="line1152"></a>1152               contained = parent.table_name
</span><span class="uncovered0"><a name="line1153"></a>1153               contained = contained.singularize if parent.pluralize_table_names
</span><span class="uncovered1"><a name="line1154"></a>1154               contained &lt;&lt; '_'
</span><span class="uncovered0"><a name="line1155"></a>1155             end
</span><span class="uncovered1"><a name="line1156"></a>1156             name = &quot;#{table_name_prefix}#{contained}#{undecorated_table_name(base.name)}#{table_name_suffix}&quot;
</span><span class="uncovered0"><a name="line1157"></a>1157           end
</span><span class="uncovered1"><a name="line1158"></a>1158 
</span><span class="uncovered0"><a name="line1159"></a>1159         set_table_name(name)
</span><span class="uncovered1"><a name="line1160"></a>1160         name
</span><span class="uncovered0"><a name="line1161"></a>1161       end
</span><span class="inferred1"><a name="line1162"></a>1162 
</span><span class="inferred0"><a name="line1163"></a>1163       # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the
</span><span class="inferred1"><a name="line1164"></a>1164       # primary_key_prefix_type setting, though.
</span><span class="marked0"><a name="line1165"></a>1165       def primary_key
</span><span class="uncovered1"><a name="line1166"></a>1166         reset_primary_key
</span><span class="uncovered0"><a name="line1167"></a>1167       end
</span><span class="inferred1"><a name="line1168"></a>1168 
</span><span class="marked0"><a name="line1169"></a>1169       def reset_primary_key #:nodoc:
</span><span class="uncovered1"><a name="line1170"></a>1170         key = get_primary_key(base_class.name)
</span><span class="uncovered0"><a name="line1171"></a>1171         set_primary_key(key)
</span><span class="uncovered1"><a name="line1172"></a>1172         key
</span><span class="uncovered0"><a name="line1173"></a>1173       end
</span><span class="inferred1"><a name="line1174"></a>1174 
</span><span class="marked0"><a name="line1175"></a>1175       def get_primary_key(base_name) #:nodoc:
</span><span class="uncovered1"><a name="line1176"></a>1176         key = 'id'
</span><span class="uncovered0"><a name="line1177"></a>1177         case primary_key_prefix_type
</span><span class="uncovered1"><a name="line1178"></a>1178           when :table_name
</span><span class="uncovered0"><a name="line1179"></a>1179             key = base_name.to_s.foreign_key(false)
</span><span class="uncovered1"><a name="line1180"></a>1180           when :table_name_with_underscore
</span><span class="uncovered0"><a name="line1181"></a>1181             key = base_name.to_s.foreign_key
</span><span class="uncovered1"><a name="line1182"></a>1182         end
</span><span class="uncovered0"><a name="line1183"></a>1183         key
</span><span class="uncovered1"><a name="line1184"></a>1184       end
</span><span class="inferred0"><a name="line1185"></a>1185 
</span><span class="inferred1"><a name="line1186"></a>1186       # Defines the column name for use with single table inheritance
</span><span class="inferred0"><a name="line1187"></a>1187       # -- can be set in subclasses like so: self.inheritance_column = &quot;type_id&quot;
</span><span class="marked1"><a name="line1188"></a>1188       def inheritance_column
</span><span class="uncovered0"><a name="line1189"></a>1189         @inheritance_column ||= &quot;type&quot;.freeze
</span><span class="uncovered1"><a name="line1190"></a>1190       end
</span><span class="inferred0"><a name="line1191"></a>1191 
</span><span class="inferred1"><a name="line1192"></a>1192       # Lazy-set the sequence name to the connection's default.  This method
</span><span class="inferred0"><a name="line1193"></a>1193       # is only ever called once since set_sequence_name overrides it.
</span><span class="marked1"><a name="line1194"></a>1194       def sequence_name #:nodoc:
</span><span class="uncovered0"><a name="line1195"></a>1195         reset_sequence_name
</span><span class="uncovered1"><a name="line1196"></a>1196       end
</span><span class="inferred0"><a name="line1197"></a>1197 
</span><span class="marked1"><a name="line1198"></a>1198       def reset_sequence_name #:nodoc:
</span><span class="uncovered0"><a name="line1199"></a>1199         default = connection.default_sequence_name(table_name, primary_key)
</span><span class="uncovered1"><a name="line1200"></a>1200         set_sequence_name(default)
</span><span class="uncovered0"><a name="line1201"></a>1201         default
</span><span class="uncovered1"><a name="line1202"></a>1202       end
</span><span class="inferred0"><a name="line1203"></a>1203 
</span><span class="inferred1"><a name="line1204"></a>1204       # Sets the table name to use to the given value, or (if the value
</span><span class="inferred0"><a name="line1205"></a>1205       # is nil or false) to the value returned by the given block.
</span><span class="inferred1"><a name="line1206"></a>1206       #
</span><span class="inferred0"><a name="line1207"></a>1207       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1208"></a>1208       #     set_table_name &quot;project&quot;
</span><span class="inferred0"><a name="line1209"></a>1209       #   end
</span><span class="marked1"><a name="line1210"></a>1210       def set_table_name(value = nil, &amp;block)
</span><span class="uncovered0"><a name="line1211"></a>1211         define_attr_method :table_name, value, &amp;block
</span><span class="uncovered1"><a name="line1212"></a>1212       end
</span><span class="marked0"><a name="line1213"></a>1213       alias :table_name= :set_table_name
</span><span class="inferred1"><a name="line1214"></a>1214 
</span><span class="inferred0"><a name="line1215"></a>1215       # Sets the name of the primary key column to use to the given value,
</span><span class="inferred1"><a name="line1216"></a>1216       # or (if the value is nil or false) to the value returned by the given
</span><span class="inferred0"><a name="line1217"></a>1217       # block.
</span><span class="inferred1"><a name="line1218"></a>1218       #
</span><span class="inferred0"><a name="line1219"></a>1219       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1220"></a>1220       #     set_primary_key &quot;sysid&quot;
</span><span class="inferred0"><a name="line1221"></a>1221       #   end
</span><span class="marked1"><a name="line1222"></a>1222       def set_primary_key(value = nil, &amp;block)
</span><span class="uncovered0"><a name="line1223"></a>1223         define_attr_method :primary_key, value, &amp;block
</span><span class="uncovered1"><a name="line1224"></a>1224       end
</span><span class="marked0"><a name="line1225"></a>1225       alias :primary_key= :set_primary_key
</span><span class="inferred1"><a name="line1226"></a>1226 
</span><span class="inferred0"><a name="line1227"></a>1227       # Sets the name of the inheritance column to use to the given value,
</span><span class="inferred1"><a name="line1228"></a>1228       # or (if the value # is nil or false) to the value returned by the
</span><span class="inferred0"><a name="line1229"></a>1229       # given block.
</span><span class="inferred1"><a name="line1230"></a>1230       #
</span><span class="inferred0"><a name="line1231"></a>1231       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1232"></a>1232       #     set_inheritance_column do
</span><span class="inferred0"><a name="line1233"></a>1233       #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred1"><a name="line1234"></a>1234       #     end
</span><span class="inferred0"><a name="line1235"></a>1235       #   end
</span><span class="marked1"><a name="line1236"></a>1236       def set_inheritance_column(value = nil, &amp;block)
</span><span class="uncovered0"><a name="line1237"></a>1237         define_attr_method :inheritance_column, value, &amp;block
</span><span class="uncovered1"><a name="line1238"></a>1238       end
</span><span class="marked0"><a name="line1239"></a>1239       alias :inheritance_column= :set_inheritance_column
</span><span class="inferred1"><a name="line1240"></a>1240 
</span><span class="inferred0"><a name="line1241"></a>1241       # Sets the name of the sequence to use when generating ids to the given
</span><span class="inferred1"><a name="line1242"></a>1242       # value, or (if the value is nil or false) to the value returned by the
</span><span class="inferred0"><a name="line1243"></a>1243       # given block. This is required for Oracle and is useful for any
</span><span class="inferred1"><a name="line1244"></a>1244       # database which relies on sequences for primary key generation.
</span><span class="inferred0"><a name="line1245"></a>1245       #
</span><span class="inferred1"><a name="line1246"></a>1246       # If a sequence name is not explicitly set when using Oracle or Firebird,
</span><span class="inferred0"><a name="line1247"></a>1247       # it will default to the commonly used pattern of: #{table_name}_seq
</span><span class="inferred1"><a name="line1248"></a>1248       #
</span><span class="inferred0"><a name="line1249"></a>1249       # If a sequence name is not explicitly set when using PostgreSQL, it
</span><span class="inferred1"><a name="line1250"></a>1250       # will discover the sequence corresponding to your primary key for you.
</span><span class="inferred0"><a name="line1251"></a>1251       #
</span><span class="inferred1"><a name="line1252"></a>1252       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1253"></a>1253       #     set_sequence_name &quot;projectseq&quot;   # default would have been &quot;project_seq&quot;
</span><span class="inferred1"><a name="line1254"></a>1254       #   end
</span><span class="marked0"><a name="line1255"></a>1255       def set_sequence_name(value = nil, &amp;block)
</span><span class="uncovered1"><a name="line1256"></a>1256         define_attr_method :sequence_name, value, &amp;block
</span><span class="uncovered0"><a name="line1257"></a>1257       end
</span><span class="marked1"><a name="line1258"></a>1258       alias :sequence_name= :set_sequence_name
</span><span class="inferred0"><a name="line1259"></a>1259 
</span><span class="inferred1"><a name="line1260"></a>1260       # Turns the +table_name+ back into a class name following the reverse rules of +table_name+.
</span><span class="marked0"><a name="line1261"></a>1261       def class_name(table_name = table_name) # :nodoc:
</span><span class="uncovered1"><a name="line1262"></a>1262         # remove any prefix and/or suffix from the table name
</span><span class="uncovered0"><a name="line1263"></a>1263         class_name = table_name[table_name_prefix.length..-(table_name_suffix.length + 1)].camelize
</span><span class="uncovered1"><a name="line1264"></a>1264         class_name = class_name.singularize if pluralize_table_names
</span><span class="uncovered0"><a name="line1265"></a>1265         class_name
</span><span class="uncovered1"><a name="line1266"></a>1266       end
</span><span class="inferred0"><a name="line1267"></a>1267 
</span><span class="inferred1"><a name="line1268"></a>1268       # Indicates whether the table associated with this class exists
</span><span class="marked0"><a name="line1269"></a>1269       def table_exists?
</span><span class="uncovered1"><a name="line1270"></a>1270         connection.table_exists?(table_name)
</span><span class="uncovered0"><a name="line1271"></a>1271       end
</span><span class="inferred1"><a name="line1272"></a>1272 
</span><span class="inferred0"><a name="line1273"></a>1273       # Returns an array of column objects for the table associated with this class.
</span><span class="marked1"><a name="line1274"></a>1274       def columns
</span><span class="uncovered0"><a name="line1275"></a>1275         unless defined?(@columns) &amp;&amp; @columns
</span><span class="uncovered1"><a name="line1276"></a>1276           @columns = connection.columns(table_name, &quot;#{name} Columns&quot;)
</span><span class="uncovered0"><a name="line1277"></a>1277           @columns.each { |column| column.primary = column.name == primary_key }
</span><span class="uncovered1"><a name="line1278"></a>1278         end
</span><span class="uncovered0"><a name="line1279"></a>1279         @columns
</span><span class="uncovered1"><a name="line1280"></a>1280       end
</span><span class="inferred0"><a name="line1281"></a>1281 
</span><span class="inferred1"><a name="line1282"></a>1282       # Returns a hash of column objects for the table associated with this class.
</span><span class="marked0"><a name="line1283"></a>1283       def columns_hash
</span><span class="uncovered1"><a name="line1284"></a>1284         @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }
</span><span class="uncovered0"><a name="line1285"></a>1285       end
</span><span class="inferred1"><a name="line1286"></a>1286 
</span><span class="inferred0"><a name="line1287"></a>1287       # Returns an array of column names as strings.
</span><span class="marked1"><a name="line1288"></a>1288       def column_names
</span><span class="uncovered0"><a name="line1289"></a>1289         @column_names ||= columns.map { |column| column.name }
</span><span class="uncovered1"><a name="line1290"></a>1290       end
</span><span class="inferred0"><a name="line1291"></a>1291 
</span><span class="inferred1"><a name="line1292"></a>1292       # Returns an array of column objects where the primary id, all columns ending in &quot;_id&quot; or &quot;_count&quot;,
</span><span class="inferred0"><a name="line1293"></a>1293       # and columns used for single table inheritance have been removed.
</span><span class="marked1"><a name="line1294"></a>1294       def content_columns
</span><span class="uncovered0"><a name="line1295"></a>1295         @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }
</span><span class="uncovered1"><a name="line1296"></a>1296       end
</span><span class="inferred0"><a name="line1297"></a>1297 
</span><span class="inferred1"><a name="line1298"></a>1298       # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key
</span><span class="inferred0"><a name="line1299"></a>1299       # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
</span><span class="inferred1"><a name="line1300"></a>1300       # is available.
</span><span class="marked0"><a name="line1301"></a>1301       def column_methods_hash #:nodoc:
</span><span class="uncovered1"><a name="line1302"></a>1302         @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
</span><span class="uncovered0"><a name="line1303"></a>1303           attr_name = attr.to_s
</span><span class="uncovered1"><a name="line1304"></a>1304           methods[attr.to_sym]       = attr_name
</span><span class="uncovered0"><a name="line1305"></a>1305           methods[&quot;#{attr}=&quot;.to_sym] = attr_name
</span><span class="uncovered1"><a name="line1306"></a>1306           methods[&quot;#{attr}?&quot;.to_sym] = attr_name
</span><span class="uncovered0"><a name="line1307"></a>1307           methods[&quot;#{attr}_before_type_cast&quot;.to_sym] = attr_name
</span><span class="uncovered1"><a name="line1308"></a>1308           methods
</span><span class="uncovered0"><a name="line1309"></a>1309         end
</span><span class="uncovered1"><a name="line1310"></a>1310       end
</span><span class="inferred0"><a name="line1311"></a>1311 
</span><span class="inferred1"><a name="line1312"></a>1312       # Resets all the cached information about columns, which will cause them
</span><span class="inferred0"><a name="line1313"></a>1313       # to be reloaded on the next request.
</span><span class="inferred1"><a name="line1314"></a>1314       #
</span><span class="inferred0"><a name="line1315"></a>1315       # The most common usage pattern for this method is probably in a migration,
</span><span class="inferred1"><a name="line1316"></a>1316       # when just after creating a table you want to populate it with some default
</span><span class="inferred0"><a name="line1317"></a>1317       # values, eg:
</span><span class="inferred1"><a name="line1318"></a>1318       #
</span><span class="inferred0"><a name="line1319"></a>1319       #  class CreateJobLevels &lt; ActiveRecord::Migration
</span><span class="inferred1"><a name="line1320"></a>1320       #    def self.up
</span><span class="inferred0"><a name="line1321"></a>1321       #      create_table :job_levels do |t|
</span><span class="inferred1"><a name="line1322"></a>1322       #        t.integer :id
</span><span class="inferred0"><a name="line1323"></a>1323       #        t.string :name
</span><span class="inferred1"><a name="line1324"></a>1324       #
</span><span class="inferred0"><a name="line1325"></a>1325       #        t.timestamps
</span><span class="inferred1"><a name="line1326"></a>1326       #      end
</span><span class="inferred0"><a name="line1327"></a>1327       #
</span><span class="inferred1"><a name="line1328"></a>1328       #      JobLevel.reset_column_information
</span><span class="inferred0"><a name="line1329"></a>1329       #      %w{assistant executive manager director}.each do |type|
</span><span class="inferred1"><a name="line1330"></a>1330       #        JobLevel.create(:name =&gt; type)
</span><span class="inferred0"><a name="line1331"></a>1331       #      end
</span><span class="inferred1"><a name="line1332"></a>1332       #    end
</span><span class="inferred0"><a name="line1333"></a>1333       #
</span><span class="inferred1"><a name="line1334"></a>1334       #    def self.down
</span><span class="inferred0"><a name="line1335"></a>1335       #      drop_table :job_levels
</span><span class="inferred1"><a name="line1336"></a>1336       #    end
</span><span class="inferred0"><a name="line1337"></a>1337       #  end
</span><span class="marked1"><a name="line1338"></a>1338       def reset_column_information
</span><span class="uncovered0"><a name="line1339"></a>1339         generated_methods.each { |name| undef_method(name) }
</span><span class="uncovered1"><a name="line1340"></a>1340         @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @generated_methods = @inheritance_column = nil
</span><span class="uncovered0"><a name="line1341"></a>1341       end
</span><span class="inferred1"><a name="line1342"></a>1342 
</span><span class="marked0"><a name="line1343"></a>1343       def reset_column_information_and_inheritable_attributes_for_all_subclasses#:nodoc:
</span><span class="uncovered1"><a name="line1344"></a>1344         subclasses.each { |klass| klass.reset_inheritable_attributes; klass.reset_column_information }
</span><span class="uncovered0"><a name="line1345"></a>1345       end
</span><span class="inferred1"><a name="line1346"></a>1346 
</span><span class="marked0"><a name="line1347"></a>1347       def self_and_descendents_from_active_record#nodoc:
</span><span class="uncovered1"><a name="line1348"></a>1348         klass = self
</span><span class="uncovered0"><a name="line1349"></a>1349         classes = [klass]
</span><span class="uncovered1"><a name="line1350"></a>1350         while klass != klass.base_class  
</span><span class="uncovered0"><a name="line1351"></a>1351           classes &lt;&lt; klass = klass.superclass
</span><span class="uncovered1"><a name="line1352"></a>1352         end
</span><span class="uncovered0"><a name="line1353"></a>1353         classes
</span><span class="uncovered1"><a name="line1354"></a>1354       rescue
</span><span class="uncovered0"><a name="line1355"></a>1355         # OPTIMIZE this rescue is to fix this test: ./test/cases/reflection_test.rb:56:in `test_human_name_for_column'
</span><span class="uncovered1"><a name="line1356"></a>1356         # Appearantly the method base_class causes some trouble.
</span><span class="uncovered0"><a name="line1357"></a>1357         # It now works for sure.
</span><span class="uncovered1"><a name="line1358"></a>1358         [self]
</span><span class="uncovered0"><a name="line1359"></a>1359       end
</span><span class="inferred1"><a name="line1360"></a>1360 
</span><span class="inferred0"><a name="line1361"></a>1361       # Transforms attribute key names into a more humane format, such as &quot;First name&quot; instead of &quot;first_name&quot;. Example:
</span><span class="inferred1"><a name="line1362"></a>1362       #   Person.human_attribute_name(&quot;first_name&quot;) # =&gt; &quot;First name&quot;
</span><span class="inferred0"><a name="line1363"></a>1363       # This used to be depricated in favor of humanize, but is now preferred, because it automatically uses the I18n
</span><span class="inferred1"><a name="line1364"></a>1364       # module now.
</span><span class="inferred0"><a name="line1365"></a>1365       # Specify +options+ with additional translating options.
</span><span class="marked1"><a name="line1366"></a>1366       def human_attribute_name(attribute_key_name, options = {})
</span><span class="uncovered0"><a name="line1367"></a>1367         defaults = self_and_descendents_from_active_record.map do |klass|
</span><span class="uncovered1"><a name="line1368"></a>1368           :&quot;#{klass.name.underscore}.#{attribute_key_name}&quot;
</span><span class="uncovered0"><a name="line1369"></a>1369         end
</span><span class="uncovered1"><a name="line1370"></a>1370         defaults &lt;&lt; options[:default] if options[:default]
</span><span class="uncovered0"><a name="line1371"></a>1371         defaults.flatten!
</span><span class="uncovered1"><a name="line1372"></a>1372         defaults &lt;&lt; attribute_key_name.humanize
</span><span class="uncovered0"><a name="line1373"></a>1373         options[:count] ||= 1
</span><span class="uncovered1"><a name="line1374"></a>1374         I18n.translate(defaults.shift, options.merge(:default =&gt; defaults, :scope =&gt; [:activerecord, :attributes]))
</span><span class="uncovered0"><a name="line1375"></a>1375       end
</span><span class="inferred1"><a name="line1376"></a>1376 
</span><span class="inferred0"><a name="line1377"></a>1377       # Transform the modelname into a more humane format, using I18n.
</span><span class="inferred1"><a name="line1378"></a>1378       # Defaults to the basic humanize method.
</span><span class="inferred0"><a name="line1379"></a>1379       # Default scope of the translation is activerecord.models
</span><span class="inferred1"><a name="line1380"></a>1380       # Specify +options+ with additional translating options.
</span><span class="marked0"><a name="line1381"></a>1381       def human_name(options = {})
</span><span class="uncovered1"><a name="line1382"></a>1382         defaults = self_and_descendents_from_active_record.map do |klass|
</span><span class="uncovered0"><a name="line1383"></a>1383           :&quot;#{klass.name.underscore}&quot;
</span><span class="uncovered1"><a name="line1384"></a>1384         end 
</span><span class="uncovered0"><a name="line1385"></a>1385         defaults &lt;&lt; self.name.humanize
</span><span class="uncovered1"><a name="line1386"></a>1386         I18n.translate(defaults.shift, {:scope =&gt; [:activerecord, :models], :count =&gt; 1, :default =&gt; defaults}.merge(options))
</span><span class="uncovered0"><a name="line1387"></a>1387       end
</span><span class="inferred1"><a name="line1388"></a>1388 
</span><span class="inferred0"><a name="line1389"></a>1389       # True if this isn't a concrete subclass needing a STI type condition.
</span><span class="marked1"><a name="line1390"></a>1390       def descends_from_active_record?
</span><span class="uncovered0"><a name="line1391"></a>1391         if superclass.abstract_class?
</span><span class="uncovered1"><a name="line1392"></a>1392           superclass.descends_from_active_record?
</span><span class="uncovered0"><a name="line1393"></a>1393         else
</span><span class="uncovered1"><a name="line1394"></a>1394           superclass == Base || !columns_hash.include?(inheritance_column)
</span><span class="uncovered0"><a name="line1395"></a>1395         end
</span><span class="uncovered1"><a name="line1396"></a>1396       end
</span><span class="inferred0"><a name="line1397"></a>1397 
</span><span class="marked1"><a name="line1398"></a>1398       def finder_needs_type_condition? #:nodoc:
</span><span class="uncovered0"><a name="line1399"></a>1399         # This is like this because benchmarking justifies the strange :false stuff
</span><span class="uncovered1"><a name="line1400"></a>1400         :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
</span><span class="uncovered0"><a name="line1401"></a>1401       end
</span><span class="inferred1"><a name="line1402"></a>1402 
</span><span class="inferred0"><a name="line1403"></a>1403       # Returns a string like 'Post id:integer, title:string, body:text'
</span><span class="marked1"><a name="line1404"></a>1404       def inspect
</span><span class="uncovered0"><a name="line1405"></a>1405         if self == Base
</span><span class="uncovered1"><a name="line1406"></a>1406           super
</span><span class="uncovered0"><a name="line1407"></a>1407         elsif abstract_class?
</span><span class="uncovered1"><a name="line1408"></a>1408           &quot;#{super}(abstract)&quot;
</span><span class="uncovered0"><a name="line1409"></a>1409         elsif table_exists?
</span><span class="uncovered1"><a name="line1410"></a>1410           attr_list = columns.map { |c| &quot;#{c.name}: #{c.type}&quot; } * ', '
</span><span class="uncovered0"><a name="line1411"></a>1411           &quot;#{super}(#{attr_list})&quot;
</span><span class="uncovered1"><a name="line1412"></a>1412         else
</span><span class="uncovered0"><a name="line1413"></a>1413           &quot;#{super}(Table doesn't exist)&quot;
</span><span class="uncovered1"><a name="line1414"></a>1414         end
</span><span class="uncovered0"><a name="line1415"></a>1415       end
</span><span class="inferred1"><a name="line1416"></a>1416 
</span><span class="inferred0"><a name="line1417"></a>1417 
</span><span class="marked1"><a name="line1418"></a>1418       def quote_value(value, column = nil) #:nodoc:
</span><span class="uncovered0"><a name="line1419"></a>1419         connection.quote(value,column)
</span><span class="uncovered1"><a name="line1420"></a>1420       end
</span><span class="inferred0"><a name="line1421"></a>1421 
</span><span class="inferred1"><a name="line1422"></a>1422       # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to &lt;tt&gt;connection.quote&lt;/tt&gt;.
</span><span class="marked0"><a name="line1423"></a>1423       def sanitize(object) #:nodoc:
</span><span class="uncovered1"><a name="line1424"></a>1424         connection.quote(object)
</span><span class="uncovered0"><a name="line1425"></a>1425       end
</span><span class="inferred1"><a name="line1426"></a>1426 
</span><span class="inferred0"><a name="line1427"></a>1427       # Log and benchmark multiple statements in a single block. Example:
</span><span class="inferred1"><a name="line1428"></a>1428       #
</span><span class="inferred0"><a name="line1429"></a>1429       #   Project.benchmark(&quot;Creating project&quot;) do
</span><span class="inferred1"><a name="line1430"></a>1430       #     project = Project.create(&quot;name&quot; =&gt; &quot;stuff&quot;)
</span><span class="inferred0"><a name="line1431"></a>1431       #     project.create_manager(&quot;name&quot; =&gt; &quot;David&quot;)
</span><span class="inferred1"><a name="line1432"></a>1432       #     project.milestones &lt;&lt; Milestone.find(:all)
</span><span class="inferred0"><a name="line1433"></a>1433       #   end
</span><span class="inferred1"><a name="line1434"></a>1434       #
</span><span class="inferred0"><a name="line1435"></a>1435       # The benchmark is only recorded if the current level of the logger is less than or equal to the &lt;tt&gt;log_level&lt;/tt&gt;,
</span><span class="inferred1"><a name="line1436"></a>1436       # which makes it easy to include benchmarking statements in production software that will remain inexpensive because
</span><span class="inferred0"><a name="line1437"></a>1437       # the benchmark will only be conducted if the log level is low enough.
</span><span class="inferred1"><a name="line1438"></a>1438       #
</span><span class="inferred0"><a name="line1439"></a>1439       # The logging of the multiple statements is turned off unless &lt;tt&gt;use_silence&lt;/tt&gt; is set to false.
</span><span class="marked1"><a name="line1440"></a>1440       def benchmark(title, log_level = Logger::DEBUG, use_silence = true)
</span><span class="uncovered0"><a name="line1441"></a>1441         if logger &amp;&amp; logger.level &lt;= log_level
</span><span class="uncovered1"><a name="line1442"></a>1442           result = nil
</span><span class="uncovered0"><a name="line1443"></a>1443           ms = Benchmark.ms { result = use_silence ? silence { yield } : yield }
</span><span class="uncovered1"><a name="line1444"></a>1444           logger.add(log_level, '%s (%.1fms)' % [title, ms])
</span><span class="uncovered0"><a name="line1445"></a>1445           result
</span><span class="uncovered1"><a name="line1446"></a>1446         else
</span><span class="uncovered0"><a name="line1447"></a>1447           yield
</span><span class="uncovered1"><a name="line1448"></a>1448         end
</span><span class="uncovered0"><a name="line1449"></a>1449       end
</span><span class="inferred1"><a name="line1450"></a>1450 
</span><span class="inferred0"><a name="line1451"></a>1451       # Silences the logger for the duration of the block.
</span><span class="marked1"><a name="line1452"></a>1452       def silence
</span><span class="uncovered0"><a name="line1453"></a>1453         old_logger_level, logger.level = logger.level, Logger::ERROR if logger
</span><span class="uncovered1"><a name="line1454"></a>1454         yield
</span><span class="uncovered0"><a name="line1455"></a>1455       ensure
</span><span class="uncovered1"><a name="line1456"></a>1456         logger.level = old_logger_level if logger
</span><span class="uncovered0"><a name="line1457"></a>1457       end
</span><span class="inferred1"><a name="line1458"></a>1458 
</span><span class="inferred0"><a name="line1459"></a>1459       # Overwrite the default class equality method to provide support for association proxies.
</span><span class="marked1"><a name="line1460"></a>1460       def ===(object)
</span><span class="uncovered0"><a name="line1461"></a>1461         object.is_a?(self)
</span><span class="uncovered1"><a name="line1462"></a>1462       end
</span><span class="inferred0"><a name="line1463"></a>1463 
</span><span class="inferred1"><a name="line1464"></a>1464       # Returns the base AR subclass that this class descends from. If A
</span><span class="inferred0"><a name="line1465"></a>1465       # extends AR::Base, A.base_class will return A. If B descends from A
</span><span class="inferred1"><a name="line1466"></a>1466       # through some arbitrarily deep hierarchy, B.base_class will return A.
</span><span class="marked0"><a name="line1467"></a>1467       def base_class
</span><span class="uncovered1"><a name="line1468"></a>1468         class_of_active_record_descendant(self)
</span><span class="uncovered0"><a name="line1469"></a>1469       end
</span><span class="inferred1"><a name="line1470"></a>1470 
</span><span class="inferred0"><a name="line1471"></a>1471       # Set this to true if this is an abstract class (see &lt;tt&gt;abstract_class?&lt;/tt&gt;).
</span><span class="marked1"><a name="line1472"></a>1472       attr_accessor :abstract_class
</span><span class="inferred0"><a name="line1473"></a>1473 
</span><span class="inferred1"><a name="line1474"></a>1474       # Returns whether this class is a base AR class.  If A is a base class and
</span><span class="inferred0"><a name="line1475"></a>1475       # B descends from A, then B.base_class will return B.
</span><span class="marked1"><a name="line1476"></a>1476       def abstract_class?
</span><span class="uncovered0"><a name="line1477"></a>1477         defined?(@abstract_class) &amp;&amp; @abstract_class == true
</span><span class="uncovered1"><a name="line1478"></a>1478       end
</span><span class="inferred0"><a name="line1479"></a>1479 
</span><span class="marked1"><a name="line1480"></a>1480       def respond_to?(method_id, include_private = false)
</span><span class="marked0"><a name="line1481"></a>1481         if match = DynamicFinderMatch.match(method_id)
</span><span class="uncovered1"><a name="line1482"></a>1482           return true if all_attributes_exists?(match.attribute_names)
</span><span class="marked0"><a name="line1483"></a>1483         elsif match = DynamicScopeMatch.match(method_id)
</span><span class="uncovered1"><a name="line1484"></a>1484           return true if all_attributes_exists?(match.attribute_names)
</span><span class="uncovered0"><a name="line1485"></a>1485         end
</span><span class="inferred1"><a name="line1486"></a>1486         
</span><span class="marked0"><a name="line1487"></a>1487         super
</span><span class="inferred1"><a name="line1488"></a>1488       end
</span><span class="inferred0"><a name="line1489"></a>1489 
</span><span class="marked1"><a name="line1490"></a>1490       def sti_name
</span><span class="uncovered0"><a name="line1491"></a>1491         store_full_sti_class ? name : name.demodulize
</span><span class="uncovered1"><a name="line1492"></a>1492       end
</span><span class="inferred0"><a name="line1493"></a>1493 
</span><span class="inferred1"><a name="line1494"></a>1494       # Merges conditions so that the result is a valid +condition+
</span><span class="marked0"><a name="line1495"></a>1495       def merge_conditions(*conditions)
</span><span class="uncovered1"><a name="line1496"></a>1496         segments = []
</span><span class="uncovered0"><a name="line1497"></a>1497 
</span><span class="uncovered1"><a name="line1498"></a>1498         conditions.each do |condition|
</span><span class="uncovered0"><a name="line1499"></a>1499           unless condition.blank?
</span><span class="uncovered1"><a name="line1500"></a>1500             sql = sanitize_sql(condition)
</span><span class="uncovered0"><a name="line1501"></a>1501             segments &lt;&lt; sql unless sql.blank?
</span><span class="uncovered1"><a name="line1502"></a>1502           end
</span><span class="uncovered0"><a name="line1503"></a>1503         end
</span><span class="uncovered1"><a name="line1504"></a>1504 
</span><span class="uncovered0"><a name="line1505"></a>1505         &quot;(#{segments.join(') AND (')})&quot; unless segments.empty?
</span><span class="uncovered1"><a name="line1506"></a>1506       end
</span><span class="inferred0"><a name="line1507"></a>1507 
</span><span class="marked1"><a name="line1508"></a>1508       private
</span><span class="marked0"><a name="line1509"></a>1509         def find_initial(options)
</span><span class="uncovered1"><a name="line1510"></a>1510           options.update(:limit =&gt; 1)
</span><span class="uncovered0"><a name="line1511"></a>1511           find_every(options).first
</span><span class="uncovered1"><a name="line1512"></a>1512         end
</span><span class="inferred0"><a name="line1513"></a>1513 
</span><span class="marked1"><a name="line1514"></a>1514         def find_last(options)
</span><span class="uncovered0"><a name="line1515"></a>1515           order = options[:order]
</span><span class="uncovered1"><a name="line1516"></a>1516 
</span><span class="uncovered0"><a name="line1517"></a>1517           if order
</span><span class="uncovered1"><a name="line1518"></a>1518             order = reverse_sql_order(order)
</span><span class="uncovered0"><a name="line1519"></a>1519           elsif !scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1520"></a>1520             order = &quot;#{table_name}.#{primary_key} DESC&quot;
</span><span class="uncovered0"><a name="line1521"></a>1521           end
</span><span class="uncovered1"><a name="line1522"></a>1522 
</span><span class="uncovered0"><a name="line1523"></a>1523           if scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1524"></a>1524             scope = scope(:find)
</span><span class="uncovered0"><a name="line1525"></a>1525             original_scoped_order = scope[:order]
</span><span class="uncovered1"><a name="line1526"></a>1526             scope[:order] = reverse_sql_order(original_scoped_order)
</span><span class="uncovered0"><a name="line1527"></a>1527           end
</span><span class="uncovered1"><a name="line1528"></a>1528 
</span><span class="uncovered0"><a name="line1529"></a>1529           begin
</span><span class="uncovered1"><a name="line1530"></a>1530             find_initial(options.merge({ :order =&gt; order }))
</span><span class="uncovered0"><a name="line1531"></a>1531           ensure
</span><span class="uncovered1"><a name="line1532"></a>1532             scope[:order] = original_scoped_order if original_scoped_order
</span><span class="uncovered0"><a name="line1533"></a>1533           end
</span><span class="uncovered1"><a name="line1534"></a>1534         end
</span><span class="inferred0"><a name="line1535"></a>1535 
</span><span class="marked1"><a name="line1536"></a>1536         def reverse_sql_order(order_query)
</span><span class="uncovered0"><a name="line1537"></a>1537           reversed_query = order_query.split(/,/).each { |s|
</span><span class="uncovered1"><a name="line1538"></a>1538             if s.match(/\s(asc|ASC)$/)
</span><span class="uncovered0"><a name="line1539"></a>1539               s.gsub!(/\s(asc|ASC)$/, ' DESC')
</span><span class="uncovered1"><a name="line1540"></a>1540             elsif s.match(/\s(desc|DESC)$/)
</span><span class="uncovered0"><a name="line1541"></a>1541               s.gsub!(/\s(desc|DESC)$/, ' ASC')
</span><span class="uncovered1"><a name="line1542"></a>1542             elsif !s.match(/\s(asc|ASC|desc|DESC)$/)
</span><span class="uncovered0"><a name="line1543"></a>1543               s.concat(' DESC')
</span><span class="uncovered1"><a name="line1544"></a>1544             end
</span><span class="uncovered0"><a name="line1545"></a>1545           }.join(',')
</span><span class="uncovered1"><a name="line1546"></a>1546         end
</span><span class="inferred0"><a name="line1547"></a>1547 
</span><span class="marked1"><a name="line1548"></a>1548         def find_every(options)
</span><span class="uncovered0"><a name="line1549"></a>1549           include_associations = merge_includes(scope(:find, :include), options[:include])
</span><span class="uncovered1"><a name="line1550"></a>1550 
</span><span class="uncovered0"><a name="line1551"></a>1551           if include_associations.any? &amp;&amp; references_eager_loaded_tables?(options)
</span><span class="uncovered1"><a name="line1552"></a>1552             records = find_with_associations(options)
</span><span class="uncovered0"><a name="line1553"></a>1553           else
</span><span class="uncovered1"><a name="line1554"></a>1554             records = find_by_sql(construct_finder_sql(options))
</span><span class="uncovered0"><a name="line1555"></a>1555             if include_associations.any?
</span><span class="uncovered1"><a name="line1556"></a>1556               preload_associations(records, include_associations)
</span><span class="uncovered0"><a name="line1557"></a>1557             end
</span><span class="uncovered1"><a name="line1558"></a>1558           end
</span><span class="uncovered0"><a name="line1559"></a>1559 
</span><span class="uncovered1"><a name="line1560"></a>1560           records.each { |record| record.readonly! } if options[:readonly]
</span><span class="uncovered0"><a name="line1561"></a>1561 
</span><span class="uncovered1"><a name="line1562"></a>1562           records
</span><span class="uncovered0"><a name="line1563"></a>1563         end
</span><span class="inferred1"><a name="line1564"></a>1564 
</span><span class="marked0"><a name="line1565"></a>1565         def find_from_ids(ids, options)
</span><span class="uncovered1"><a name="line1566"></a>1566           expects_array = ids.first.kind_of?(Array)
</span><span class="uncovered0"><a name="line1567"></a>1567           return ids.first if expects_array &amp;&amp; ids.first.empty?
</span><span class="uncovered1"><a name="line1568"></a>1568 
</span><span class="uncovered0"><a name="line1569"></a>1569           ids = ids.flatten.compact.uniq
</span><span class="uncovered1"><a name="line1570"></a>1570 
</span><span class="uncovered0"><a name="line1571"></a>1571           case ids.size
</span><span class="uncovered1"><a name="line1572"></a>1572             when 0
</span><span class="uncovered0"><a name="line1573"></a>1573               raise RecordNotFound, &quot;Couldn't find #{name} without an ID&quot;
</span><span class="uncovered1"><a name="line1574"></a>1574             when 1
</span><span class="uncovered0"><a name="line1575"></a>1575               result = find_one(ids.first, options)
</span><span class="uncovered1"><a name="line1576"></a>1576               expects_array ? [ result ] : result
</span><span class="uncovered0"><a name="line1577"></a>1577             else
</span><span class="uncovered1"><a name="line1578"></a>1578               find_some(ids, options)
</span><span class="uncovered0"><a name="line1579"></a>1579           end
</span><span class="uncovered1"><a name="line1580"></a>1580         end
</span><span class="inferred0"><a name="line1581"></a>1581 
</span><span class="marked1"><a name="line1582"></a>1582         def find_one(id, options)
</span><span class="uncovered0"><a name="line1583"></a>1583           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="uncovered1"><a name="line1584"></a>1584           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} = #{quote_value(id,columns_hash[primary_key])}#{conditions}&quot;
</span><span class="uncovered0"><a name="line1585"></a>1585 
</span><span class="uncovered1"><a name="line1586"></a>1586           # Use find_every(options).first since the primary key condition
</span><span class="uncovered0"><a name="line1587"></a>1587           # already ensures we have a single record. Using find_initial adds
</span><span class="uncovered1"><a name="line1588"></a>1588           # a superfluous :limit =&gt; 1.
</span><span class="uncovered0"><a name="line1589"></a>1589           if result = find_every(options).first
</span><span class="uncovered1"><a name="line1590"></a>1590             result
</span><span class="uncovered0"><a name="line1591"></a>1591           else
</span><span class="uncovered1"><a name="line1592"></a>1592             raise RecordNotFound, &quot;Couldn't find #{name} with ID=#{id}#{conditions}&quot;
</span><span class="uncovered0"><a name="line1593"></a>1593           end
</span><span class="uncovered1"><a name="line1594"></a>1594         end
</span><span class="inferred0"><a name="line1595"></a>1595 
</span><span class="marked1"><a name="line1596"></a>1596         def find_some(ids, options)
</span><span class="uncovered0"><a name="line1597"></a>1597           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="uncovered1"><a name="line1598"></a>1598           ids_list   = ids.map { |id| quote_value(id,columns_hash[primary_key]) }.join(',')
</span><span class="uncovered0"><a name="line1599"></a>1599           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} IN (#{ids_list})#{conditions}&quot;
</span><span class="uncovered1"><a name="line1600"></a>1600 
</span><span class="uncovered0"><a name="line1601"></a>1601           result = find_every(options)
</span><span class="uncovered1"><a name="line1602"></a>1602 
</span><span class="uncovered0"><a name="line1603"></a>1603           # Determine expected size from limit and offset, not just ids.size.
</span><span class="uncovered1"><a name="line1604"></a>1604           expected_size =
</span><span class="uncovered0"><a name="line1605"></a>1605             if options[:limit] &amp;&amp; ids.size &gt; options[:limit]
</span><span class="uncovered1"><a name="line1606"></a>1606               options[:limit]
</span><span class="uncovered0"><a name="line1607"></a>1607             else
</span><span class="uncovered1"><a name="line1608"></a>1608               ids.size
</span><span class="uncovered0"><a name="line1609"></a>1609             end
</span><span class="uncovered1"><a name="line1610"></a>1610 
</span><span class="uncovered0"><a name="line1611"></a>1611           # 11 ids with limit 3, offset 9 should give 2 results.
</span><span class="uncovered1"><a name="line1612"></a>1612           if options[:offset] &amp;&amp; (ids.size - options[:offset] &lt; expected_size)
</span><span class="uncovered0"><a name="line1613"></a>1613             expected_size = ids.size - options[:offset]
</span><span class="uncovered1"><a name="line1614"></a>1614           end
</span><span class="uncovered0"><a name="line1615"></a>1615 
</span><span class="uncovered1"><a name="line1616"></a>1616           if result.size == expected_size
</span><span class="uncovered0"><a name="line1617"></a>1617             result
</span><span class="uncovered1"><a name="line1618"></a>1618           else
</span><span class="uncovered0"><a name="line1619"></a>1619             raise RecordNotFound, &quot;Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions} (found #{result.size} results, but was looking for #{expected_size})&quot;
</span><span class="uncovered1"><a name="line1620"></a>1620           end
</span><span class="uncovered0"><a name="line1621"></a>1621         end
</span><span class="inferred1"><a name="line1622"></a>1622 
</span><span class="inferred0"><a name="line1623"></a>1623         # Finder methods must instantiate through this method to work with the
</span><span class="inferred1"><a name="line1624"></a>1624         # single-table inheritance model that makes it possible to create
</span><span class="inferred0"><a name="line1625"></a>1625         # objects of different types from the same table.
</span><span class="marked1"><a name="line1626"></a>1626         def instantiate(record)
</span><span class="uncovered0"><a name="line1627"></a>1627           object =
</span><span class="uncovered1"><a name="line1628"></a>1628             if subclass_name = record[inheritance_column]
</span><span class="uncovered0"><a name="line1629"></a>1629               # No type given.
</span><span class="uncovered1"><a name="line1630"></a>1630               if subclass_name.empty?
</span><span class="uncovered0"><a name="line1631"></a>1631                 allocate
</span><span class="uncovered1"><a name="line1632"></a>1632 
</span><span class="uncovered0"><a name="line1633"></a>1633               else
</span><span class="uncovered1"><a name="line1634"></a>1634                 # Ignore type if no column is present since it was probably
</span><span class="uncovered0"><a name="line1635"></a>1635                 # pulled in from a sloppy join.
</span><span class="uncovered1"><a name="line1636"></a>1636                 unless columns_hash.include?(inheritance_column)
</span><span class="uncovered0"><a name="line1637"></a>1637                   allocate
</span><span class="uncovered1"><a name="line1638"></a>1638 
</span><span class="uncovered0"><a name="line1639"></a>1639                 else
</span><span class="uncovered1"><a name="line1640"></a>1640                   begin
</span><span class="uncovered0"><a name="line1641"></a>1641                     compute_type(subclass_name).allocate
</span><span class="uncovered1"><a name="line1642"></a>1642                   rescue NameError
</span><span class="uncovered0"><a name="line1643"></a>1643                     raise SubclassNotFound,
</span><span class="uncovered1"><a name="line1644"></a>1644                       &quot;The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. &quot; +
</span><span class="uncovered0"><a name="line1645"></a>1645                       &quot;This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. &quot; +
</span><span class="uncovered1"><a name="line1646"></a>1646                       &quot;Please rename this column if you didn't intend it to be used for storing the inheritance class &quot; +
</span><span class="uncovered0"><a name="line1647"></a>1647                       &quot;or overwrite #{self.to_s}.inheritance_column to use another column for that information.&quot;
</span><span class="uncovered1"><a name="line1648"></a>1648                   end
</span><span class="uncovered0"><a name="line1649"></a>1649                 end
</span><span class="uncovered1"><a name="line1650"></a>1650               end
</span><span class="uncovered0"><a name="line1651"></a>1651             else
</span><span class="uncovered1"><a name="line1652"></a>1652               allocate
</span><span class="uncovered0"><a name="line1653"></a>1653             end
</span><span class="uncovered1"><a name="line1654"></a>1654 
</span><span class="uncovered0"><a name="line1655"></a>1655           object.instance_variable_set(&quot;@attributes&quot;, record)
</span><span class="uncovered1"><a name="line1656"></a>1656           object.instance_variable_set(&quot;@attributes_cache&quot;, Hash.new)
</span><span class="uncovered0"><a name="line1657"></a>1657 
</span><span class="uncovered1"><a name="line1658"></a>1658           if object.respond_to_without_attributes?(:after_find)
</span><span class="uncovered0"><a name="line1659"></a>1659             object.send(:callback, :after_find)
</span><span class="uncovered1"><a name="line1660"></a>1660           end
</span><span class="uncovered0"><a name="line1661"></a>1661 
</span><span class="uncovered1"><a name="line1662"></a>1662           if object.respond_to_without_attributes?(:after_initialize)
</span><span class="uncovered0"><a name="line1663"></a>1663             object.send(:callback, :after_initialize)
</span><span class="uncovered1"><a name="line1664"></a>1664           end
</span><span class="uncovered0"><a name="line1665"></a>1665 
</span><span class="uncovered1"><a name="line1666"></a>1666           object
</span><span class="uncovered0"><a name="line1667"></a>1667         end
</span><span class="inferred1"><a name="line1668"></a>1668 
</span><span class="inferred0"><a name="line1669"></a>1669         # Nest the type name in the same module as this class.
</span><span class="inferred1"><a name="line1670"></a>1670         # Bar is &quot;MyApp::Business::Bar&quot; relative to MyApp::Business::Foo
</span><span class="marked0"><a name="line1671"></a>1671         def type_name_with_module(type_name)
</span><span class="uncovered1"><a name="line1672"></a>1672           if store_full_sti_class
</span><span class="uncovered0"><a name="line1673"></a>1673             type_name
</span><span class="uncovered1"><a name="line1674"></a>1674           else
</span><span class="uncovered0"><a name="line1675"></a>1675             (/^::/ =~ type_name) ? type_name : &quot;#{parent.name}::#{type_name}&quot;
</span><span class="uncovered1"><a name="line1676"></a>1676           end
</span><span class="uncovered0"><a name="line1677"></a>1677         end
</span><span class="inferred1"><a name="line1678"></a>1678 
</span><span class="marked0"><a name="line1679"></a>1679         def default_select(qualified)
</span><span class="uncovered1"><a name="line1680"></a>1680           if qualified
</span><span class="uncovered0"><a name="line1681"></a>1681             quoted_table_name + '.*'
</span><span class="uncovered1"><a name="line1682"></a>1682           else
</span><span class="uncovered0"><a name="line1683"></a>1683             '*'
</span><span class="uncovered1"><a name="line1684"></a>1684           end
</span><span class="uncovered0"><a name="line1685"></a>1685         end
</span><span class="inferred1"><a name="line1686"></a>1686 
</span><span class="marked0"><a name="line1687"></a>1687         def construct_finder_sql(options)
</span><span class="uncovered1"><a name="line1688"></a>1688           scope = scope(:find)
</span><span class="uncovered0"><a name="line1689"></a>1689           sql  = &quot;SELECT #{options[:select] || (scope &amp;&amp; scope[:select]) || default_select(options[:joins] || (scope &amp;&amp; scope[:joins]))} &quot;
</span><span class="uncovered1"><a name="line1690"></a>1690           sql &lt;&lt; &quot;FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="uncovered0"><a name="line1691"></a>1691 
</span><span class="uncovered1"><a name="line1692"></a>1692           add_joins!(sql, options[:joins], scope)
</span><span class="uncovered0"><a name="line1693"></a>1693           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered1"><a name="line1694"></a>1694 
</span><span class="uncovered0"><a name="line1695"></a>1695           add_group!(sql, options[:group], options[:having], scope)
</span><span class="uncovered1"><a name="line1696"></a>1696           add_order!(sql, options[:order], scope)
</span><span class="uncovered0"><a name="line1697"></a>1697           add_limit!(sql, options, scope)
</span><span class="uncovered1"><a name="line1698"></a>1698           add_lock!(sql, options, scope)
</span><span class="uncovered0"><a name="line1699"></a>1699 
</span><span class="uncovered1"><a name="line1700"></a>1700           sql
</span><span class="uncovered0"><a name="line1701"></a>1701         end
</span><span class="inferred1"><a name="line1702"></a>1702 
</span><span class="inferred0"><a name="line1703"></a>1703         # Merges includes so that the result is a valid +include+
</span><span class="marked1"><a name="line1704"></a>1704         def merge_includes(first, second)
</span><span class="uncovered0"><a name="line1705"></a>1705          (safe_to_array(first) + safe_to_array(second)).uniq
</span><span class="uncovered1"><a name="line1706"></a>1706         end
</span><span class="inferred0"><a name="line1707"></a>1707 
</span><span class="marked1"><a name="line1708"></a>1708         def merge_joins(*joins)
</span><span class="uncovered0"><a name="line1709"></a>1709           if joins.any?{|j| j.is_a?(String) || array_of_strings?(j) }
</span><span class="uncovered1"><a name="line1710"></a>1710             joins = joins.collect do |join|
</span><span class="uncovered0"><a name="line1711"></a>1711               join = [join] if join.is_a?(String)
</span><span class="uncovered1"><a name="line1712"></a>1712               unless array_of_strings?(join)
</span><span class="uncovered0"><a name="line1713"></a>1713                 join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, join, nil)
</span><span class="uncovered1"><a name="line1714"></a>1714                 join = join_dependency.join_associations.collect { |assoc| assoc.association_join }
</span><span class="uncovered0"><a name="line1715"></a>1715               end
</span><span class="uncovered1"><a name="line1716"></a>1716               join
</span><span class="uncovered0"><a name="line1717"></a>1717             end
</span><span class="uncovered1"><a name="line1718"></a>1718             joins.flatten.map{|j| j.strip}.uniq
</span><span class="uncovered0"><a name="line1719"></a>1719           else
</span><span class="uncovered1"><a name="line1720"></a>1720             joins.collect{|j| safe_to_array(j)}.flatten.uniq
</span><span class="uncovered0"><a name="line1721"></a>1721           end
</span><span class="uncovered1"><a name="line1722"></a>1722         end
</span><span class="inferred0"><a name="line1723"></a>1723 
</span><span class="inferred1"><a name="line1724"></a>1724         # Object#to_a is deprecated, though it does have the desired behavior
</span><span class="marked0"><a name="line1725"></a>1725         def safe_to_array(o)
</span><span class="uncovered1"><a name="line1726"></a>1726           case o
</span><span class="uncovered0"><a name="line1727"></a>1727           when NilClass
</span><span class="uncovered1"><a name="line1728"></a>1728             []
</span><span class="uncovered0"><a name="line1729"></a>1729           when Array
</span><span class="uncovered1"><a name="line1730"></a>1730             o
</span><span class="uncovered0"><a name="line1731"></a>1731           else
</span><span class="uncovered1"><a name="line1732"></a>1732             [o]
</span><span class="uncovered0"><a name="line1733"></a>1733           end
</span><span class="uncovered1"><a name="line1734"></a>1734         end
</span><span class="inferred0"><a name="line1735"></a>1735 
</span><span class="marked1"><a name="line1736"></a>1736         def array_of_strings?(o)
</span><span class="uncovered0"><a name="line1737"></a>1737           o.is_a?(Array) &amp;&amp; o.all?{|obj| obj.is_a?(String)}
</span><span class="uncovered1"><a name="line1738"></a>1738         end
</span><span class="inferred0"><a name="line1739"></a>1739 
</span><span class="marked1"><a name="line1740"></a>1740         def add_order!(sql, order, scope = :auto)
</span><span class="uncovered0"><a name="line1741"></a>1741           scope = scope(:find) if :auto == scope
</span><span class="uncovered1"><a name="line1742"></a>1742           scoped_order = scope[:order] if scope
</span><span class="uncovered0"><a name="line1743"></a>1743           if order
</span><span class="uncovered1"><a name="line1744"></a>1744             sql &lt;&lt; &quot; ORDER BY #{order}&quot;
</span><span class="uncovered0"><a name="line1745"></a>1745             sql &lt;&lt; &quot;, #{scoped_order}&quot; if scoped_order
</span><span class="uncovered1"><a name="line1746"></a>1746           else
</span><span class="uncovered0"><a name="line1747"></a>1747             sql &lt;&lt; &quot; ORDER BY #{scoped_order}&quot; if scoped_order
</span><span class="uncovered1"><a name="line1748"></a>1748           end
</span><span class="uncovered0"><a name="line1749"></a>1749         end
</span><span class="inferred1"><a name="line1750"></a>1750 
</span><span class="marked0"><a name="line1751"></a>1751         def add_group!(sql, group, having, scope = :auto)
</span><span class="uncovered1"><a name="line1752"></a>1752           if group
</span><span class="uncovered0"><a name="line1753"></a>1753             sql &lt;&lt; &quot; GROUP BY #{group}&quot;
</span><span class="uncovered1"><a name="line1754"></a>1754             sql &lt;&lt; &quot; HAVING #{having}&quot; if having
</span><span class="uncovered0"><a name="line1755"></a>1755           else
</span><span class="uncovered1"><a name="line1756"></a>1756             scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1757"></a>1757             if scope &amp;&amp; (scoped_group = scope[:group])
</span><span class="uncovered1"><a name="line1758"></a>1758               sql &lt;&lt; &quot; GROUP BY #{scoped_group}&quot;
</span><span class="uncovered0"><a name="line1759"></a>1759               sql &lt;&lt; &quot; HAVING #{scoped_having}&quot; if (scoped_having = scope[:having])
</span><span class="uncovered1"><a name="line1760"></a>1760             end
</span><span class="uncovered0"><a name="line1761"></a>1761           end
</span><span class="uncovered1"><a name="line1762"></a>1762         end
</span><span class="inferred0"><a name="line1763"></a>1763 
</span><span class="inferred1"><a name="line1764"></a>1764         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked0"><a name="line1765"></a>1765         def add_limit!(sql, options, scope = :auto)
</span><span class="uncovered1"><a name="line1766"></a>1766           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1767"></a>1767 
</span><span class="uncovered1"><a name="line1768"></a>1768           if scope
</span><span class="uncovered0"><a name="line1769"></a>1769             options[:limit] ||= scope[:limit]
</span><span class="uncovered1"><a name="line1770"></a>1770             options[:offset] ||= scope[:offset]
</span><span class="uncovered0"><a name="line1771"></a>1771           end
</span><span class="uncovered1"><a name="line1772"></a>1772 
</span><span class="uncovered0"><a name="line1773"></a>1773           connection.add_limit_offset!(sql, options)
</span><span class="uncovered1"><a name="line1774"></a>1774         end
</span><span class="inferred0"><a name="line1775"></a>1775 
</span><span class="inferred1"><a name="line1776"></a>1776         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="inferred0"><a name="line1777"></a>1777         # The &lt;tt&gt;:lock&lt;/tt&gt; option has precedence over a scoped &lt;tt&gt;:lock&lt;/tt&gt;.
</span><span class="marked1"><a name="line1778"></a>1778         def add_lock!(sql, options, scope = :auto)
</span><span class="uncovered0"><a name="line1779"></a>1779           scope = scope(:find) if :auto == scope
</span><span class="uncovered1"><a name="line1780"></a>1780           options = options.reverse_merge(:lock =&gt; scope[:lock]) if scope
</span><span class="uncovered0"><a name="line1781"></a>1781           connection.add_lock!(sql, options)
</span><span class="uncovered1"><a name="line1782"></a>1782         end
</span><span class="inferred0"><a name="line1783"></a>1783 
</span><span class="inferred1"><a name="line1784"></a>1784         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked0"><a name="line1785"></a>1785         def add_joins!(sql, joins, scope = :auto)
</span><span class="uncovered1"><a name="line1786"></a>1786           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1787"></a>1787           merged_joins = scope &amp;&amp; scope[:joins] &amp;&amp; joins ? merge_joins(scope[:joins], joins) : (joins || scope &amp;&amp; scope[:joins])
</span><span class="uncovered1"><a name="line1788"></a>1788           case merged_joins
</span><span class="uncovered0"><a name="line1789"></a>1789           when Symbol, Hash, Array
</span><span class="uncovered1"><a name="line1790"></a>1790             if array_of_strings?(merged_joins)
</span><span class="uncovered0"><a name="line1791"></a>1791               sql &lt;&lt; merged_joins.join(' ') + &quot; &quot;
</span><span class="uncovered1"><a name="line1792"></a>1792             else
</span><span class="uncovered0"><a name="line1793"></a>1793               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, merged_joins, nil)
</span><span class="uncovered1"><a name="line1794"></a>1794               sql &lt;&lt; &quot; #{join_dependency.join_associations.collect { |assoc| assoc.association_join }.join} &quot;
</span><span class="uncovered0"><a name="line1795"></a>1795             end
</span><span class="uncovered1"><a name="line1796"></a>1796           when String
</span><span class="uncovered0"><a name="line1797"></a>1797             sql &lt;&lt; &quot; #{merged_joins} &quot;
</span><span class="uncovered1"><a name="line1798"></a>1798           end
</span><span class="uncovered0"><a name="line1799"></a>1799         end
</span><span class="inferred1"><a name="line1800"></a>1800 
</span><span class="inferred0"><a name="line1801"></a>1801         # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.
</span><span class="inferred1"><a name="line1802"></a>1802         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked0"><a name="line1803"></a>1803         def add_conditions!(sql, conditions, scope = :auto)
</span><span class="uncovered1"><a name="line1804"></a>1804           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1805"></a>1805           conditions = [conditions]
</span><span class="uncovered1"><a name="line1806"></a>1806           conditions &lt;&lt; scope[:conditions] if scope
</span><span class="uncovered0"><a name="line1807"></a>1807           conditions &lt;&lt; type_condition if finder_needs_type_condition?
</span><span class="uncovered1"><a name="line1808"></a>1808           merged_conditions = merge_conditions(*conditions)
</span><span class="uncovered0"><a name="line1809"></a>1809           sql &lt;&lt; &quot;WHERE #{merged_conditions} &quot; unless merged_conditions.blank?
</span><span class="uncovered1"><a name="line1810"></a>1810         end
</span><span class="inferred0"><a name="line1811"></a>1811 
</span><span class="marked1"><a name="line1812"></a>1812         def type_condition(table_alias=nil)
</span><span class="uncovered0"><a name="line1813"></a>1813           quoted_table_alias = self.connection.quote_table_name(table_alias || table_name)
</span><span class="uncovered1"><a name="line1814"></a>1814           quoted_inheritance_column = connection.quote_column_name(inheritance_column)
</span><span class="uncovered0"><a name="line1815"></a>1815           type_condition = subclasses.inject(&quot;#{quoted_table_alias}.#{quoted_inheritance_column} = '#{sti_name}' &quot;) do |condition, subclass|
</span><span class="uncovered1"><a name="line1816"></a>1816             condition &lt;&lt; &quot;OR #{quoted_table_alias}.#{quoted_inheritance_column} = '#{subclass.sti_name}' &quot;
</span><span class="uncovered0"><a name="line1817"></a>1817           end
</span><span class="uncovered1"><a name="line1818"></a>1818 
</span><span class="uncovered0"><a name="line1819"></a>1819           &quot; (#{type_condition}) &quot;
</span><span class="uncovered1"><a name="line1820"></a>1820         end
</span><span class="inferred0"><a name="line1821"></a>1821 
</span><span class="inferred1"><a name="line1822"></a>1822         # Guesses the table name, but does not decorate it with prefix and suffix information.
</span><span class="marked0"><a name="line1823"></a>1823         def undecorated_table_name(class_name = base_class.name)
</span><span class="uncovered1"><a name="line1824"></a>1824           table_name = class_name.to_s.demodulize.underscore
</span><span class="uncovered0"><a name="line1825"></a>1825           table_name = table_name.pluralize if pluralize_table_names
</span><span class="uncovered1"><a name="line1826"></a>1826           table_name
</span><span class="uncovered0"><a name="line1827"></a>1827         end
</span><span class="inferred1"><a name="line1828"></a>1828 
</span><span class="inferred0"><a name="line1829"></a>1829         # Enables dynamic finders like &lt;tt&gt;find_by_user_name(user_name)&lt;/tt&gt; and &lt;tt&gt;find_by_user_name_and_password(user_name, password)&lt;/tt&gt;
</span><span class="inferred1"><a name="line1830"></a>1830         # that are turned into &lt;tt&gt;find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt; and
</span><span class="inferred0"><a name="line1831"></a>1831         # &lt;tt&gt;find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt; respectively. Also works for
</span><span class="inferred1"><a name="line1832"></a>1832         # &lt;tt&gt;find(:all)&lt;/tt&gt; by using &lt;tt&gt;find_all_by_amount(50)&lt;/tt&gt; that is turned into &lt;tt&gt;find(:all, :conditions =&gt; [&quot;amount = ?&quot;, 50])&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1833"></a>1833         #
</span><span class="inferred1"><a name="line1834"></a>1834         # It's even possible to use all the additional parameters to +find+. For example, the full interface for +find_all_by_amount+
</span><span class="inferred0"><a name="line1835"></a>1835         # is actually &lt;tt&gt;find_all_by_amount(amount, options)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1836"></a>1836         #
</span><span class="inferred0"><a name="line1837"></a>1837         # Also enables dynamic scopes like scoped_by_user_name(user_name) and scoped_by_user_name_and_password(user_name, password) that
</span><span class="inferred1"><a name="line1838"></a>1838         # are turned into scoped(:conditions =&gt; [&quot;user_name = ?&quot;, user_name]) and scoped(:conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])
</span><span class="inferred0"><a name="line1839"></a>1839         # respectively.
</span><span class="inferred1"><a name="line1840"></a>1840         #
</span><span class="inferred0"><a name="line1841"></a>1841         # Each dynamic finder, scope or initializer/creator is also defined in the class after it is first invoked, so that future
</span><span class="inferred1"><a name="line1842"></a>1842         # attempts to use it do not run through method_missing.
</span><span class="marked0"><a name="line1843"></a>1843         def method_missing(method_id, *arguments, &amp;block)
</span><span class="uncovered1"><a name="line1844"></a>1844           if match = DynamicFinderMatch.match(method_id)
</span><span class="uncovered0"><a name="line1845"></a>1845             attribute_names = match.attribute_names
</span><span class="uncovered1"><a name="line1846"></a>1846             super unless all_attributes_exists?(attribute_names)
</span><span class="uncovered0"><a name="line1847"></a>1847             if match.finder?
</span><span class="uncovered1"><a name="line1848"></a>1848               finder = match.finder
</span><span class="uncovered0"><a name="line1849"></a>1849               bang = match.bang?
</span><span class="uncovered1"><a name="line1850"></a>1850               # def self.find_by_login_and_activated(*args)
</span><span class="uncovered0"><a name="line1851"></a>1851               #   options = args.extract_options!
</span><span class="uncovered1"><a name="line1852"></a>1852               #   attributes = construct_attributes_from_arguments(
</span><span class="uncovered0"><a name="line1853"></a>1853               #     [:login,:activated],
</span><span class="uncovered1"><a name="line1854"></a>1854               #     args
</span><span class="uncovered0"><a name="line1855"></a>1855               #   )
</span><span class="uncovered1"><a name="line1856"></a>1856               #   finder_options = { :conditions =&gt; attributes }
</span><span class="uncovered0"><a name="line1857"></a>1857               #   validate_find_options(options)
</span><span class="uncovered1"><a name="line1858"></a>1858               #   set_readonly_option!(options)
</span><span class="uncovered0"><a name="line1859"></a>1859               #
</span><span class="uncovered1"><a name="line1860"></a>1860               #   if options[:conditions]
</span><span class="uncovered0"><a name="line1861"></a>1861               #     with_scope(:find =&gt; finder_options) do
</span><span class="uncovered1"><a name="line1862"></a>1862               #       find(:first, options)
</span><span class="uncovered0"><a name="line1863"></a>1863               #     end
</span><span class="uncovered1"><a name="line1864"></a>1864               #   else
</span><span class="uncovered0"><a name="line1865"></a>1865               #     find(:first, options.merge(finder_options))
</span><span class="uncovered1"><a name="line1866"></a>1866               #   end
</span><span class="uncovered0"><a name="line1867"></a>1867               # end
</span><span class="uncovered1"><a name="line1868"></a>1868               self.class_eval %{
</span><span class="uncovered0"><a name="line1869"></a>1869                 def self.#{method_id}(*args)
</span><span class="uncovered1"><a name="line1870"></a>1870                   options = args.extract_options!
</span><span class="uncovered0"><a name="line1871"></a>1871                   attributes = construct_attributes_from_arguments(
</span><span class="uncovered1"><a name="line1872"></a>1872                     [:#{attribute_names.join(',:')}],
</span><span class="uncovered0"><a name="line1873"></a>1873                     args
</span><span class="uncovered1"><a name="line1874"></a>1874                   )
</span><span class="uncovered0"><a name="line1875"></a>1875                   finder_options = { :conditions =&gt; attributes }
</span><span class="uncovered1"><a name="line1876"></a>1876                   validate_find_options(options)
</span><span class="uncovered0"><a name="line1877"></a>1877                   set_readonly_option!(options)
</span><span class="uncovered1"><a name="line1878"></a>1878 
</span><span class="uncovered0"><a name="line1879"></a>1879                   #{'result = ' if bang}if options[:conditions]
</span><span class="uncovered1"><a name="line1880"></a>1880                     with_scope(:find =&gt; finder_options) do
</span><span class="uncovered0"><a name="line1881"></a>1881                       find(:#{finder}, options)
</span><span class="uncovered1"><a name="line1882"></a>1882                     end
</span><span class="uncovered0"><a name="line1883"></a>1883                   else
</span><span class="uncovered1"><a name="line1884"></a>1884                     find(:#{finder}, options.merge(finder_options))
</span><span class="uncovered0"><a name="line1885"></a>1885                   end
</span><span class="uncovered1"><a name="line1886"></a>1886                   #{'result || raise(RecordNotFound, &quot;Couldn\'t find #{name} with #{attributes.to_a.collect {|pair| &quot;#{pair.first} = #{pair.second}&quot;}.join(\', \')}&quot;)' if bang}
</span><span class="uncovered0"><a name="line1887"></a>1887                 end
</span><span class="uncovered1"><a name="line1888"></a>1888               }, __FILE__, __LINE__
</span><span class="uncovered0"><a name="line1889"></a>1889               send(method_id, *arguments)
</span><span class="uncovered1"><a name="line1890"></a>1890             elsif match.instantiator?
</span><span class="uncovered0"><a name="line1891"></a>1891               instantiator = match.instantiator
</span><span class="uncovered1"><a name="line1892"></a>1892               # def self.find_or_create_by_user_id(*args)
</span><span class="uncovered0"><a name="line1893"></a>1893               #   guard_protected_attributes = false
</span><span class="uncovered1"><a name="line1894"></a>1894               #
</span><span class="uncovered0"><a name="line1895"></a>1895               #   if args[0].is_a?(Hash)
</span><span class="uncovered1"><a name="line1896"></a>1896               #     guard_protected_attributes = true
</span><span class="uncovered0"><a name="line1897"></a>1897               #     attributes = args[0].with_indifferent_access
</span><span class="uncovered1"><a name="line1898"></a>1898               #     find_attributes = attributes.slice(*[:user_id])
</span><span class="uncovered0"><a name="line1899"></a>1899               #   else
</span><span class="uncovered1"><a name="line1900"></a>1900               #     find_attributes = attributes = construct_attributes_from_arguments([:user_id], args)
</span><span class="uncovered0"><a name="line1901"></a>1901               #   end
</span><span class="uncovered1"><a name="line1902"></a>1902               #
</span><span class="uncovered0"><a name="line1903"></a>1903               #   options = { :conditions =&gt; find_attributes }
</span><span class="uncovered1"><a name="line1904"></a>1904               #   set_readonly_option!(options)
</span><span class="uncovered0"><a name="line1905"></a>1905               #
</span><span class="uncovered1"><a name="line1906"></a>1906               #   record = find(:first, options)
</span><span class="uncovered0"><a name="line1907"></a>1907               #
</span><span class="uncovered1"><a name="line1908"></a>1908               #   if record.nil?
</span><span class="uncovered0"><a name="line1909"></a>1909               #     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }
</span><span class="uncovered1"><a name="line1910"></a>1910               #     yield(record) if block_given?
</span><span class="uncovered0"><a name="line1911"></a>1911               #     record.save
</span><span class="uncovered1"><a name="line1912"></a>1912               #     record
</span><span class="uncovered0"><a name="line1913"></a>1913               #   else
</span><span class="uncovered1"><a name="line1914"></a>1914               #     record
</span><span class="uncovered0"><a name="line1915"></a>1915               #   end
</span><span class="uncovered1"><a name="line1916"></a>1916               # end
</span><span class="uncovered0"><a name="line1917"></a>1917               self.class_eval %{
</span><span class="uncovered1"><a name="line1918"></a>1918                 def self.#{method_id}(*args)
</span><span class="uncovered0"><a name="line1919"></a>1919                   guard_protected_attributes = false
</span><span class="uncovered1"><a name="line1920"></a>1920 
</span><span class="uncovered0"><a name="line1921"></a>1921                   if args[0].is_a?(Hash)
</span><span class="uncovered1"><a name="line1922"></a>1922                     guard_protected_attributes = true
</span><span class="uncovered0"><a name="line1923"></a>1923                     attributes = args[0].with_indifferent_access
</span><span class="uncovered1"><a name="line1924"></a>1924                     find_attributes = attributes.slice(*[:#{attribute_names.join(',:')}])
</span><span class="uncovered0"><a name="line1925"></a>1925                   else
</span><span class="uncovered1"><a name="line1926"></a>1926                     find_attributes = attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)
</span><span class="uncovered0"><a name="line1927"></a>1927                   end
</span><span class="uncovered1"><a name="line1928"></a>1928 
</span><span class="uncovered0"><a name="line1929"></a>1929                   options = { :conditions =&gt; find_attributes }
</span><span class="uncovered1"><a name="line1930"></a>1930                   set_readonly_option!(options)
</span><span class="uncovered0"><a name="line1931"></a>1931 
</span><span class="uncovered1"><a name="line1932"></a>1932                   record = find(:first, options)
</span><span class="uncovered0"><a name="line1933"></a>1933 
</span><span class="uncovered1"><a name="line1934"></a>1934                   if record.nil?
</span><span class="uncovered0"><a name="line1935"></a>1935                     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }
</span><span class="uncovered1"><a name="line1936"></a>1936                     #{'yield(record) if block_given?'}
</span><span class="uncovered0"><a name="line1937"></a>1937                     #{'record.save' if instantiator == :create}
</span><span class="uncovered1"><a name="line1938"></a>1938                     record
</span><span class="uncovered0"><a name="line1939"></a>1939                   else
</span><span class="uncovered1"><a name="line1940"></a>1940                     record
</span><span class="uncovered0"><a name="line1941"></a>1941                   end
</span><span class="uncovered1"><a name="line1942"></a>1942                 end
</span><span class="uncovered0"><a name="line1943"></a>1943               }, __FILE__, __LINE__
</span><span class="uncovered1"><a name="line1944"></a>1944               send(method_id, *arguments, &amp;block)
</span><span class="uncovered0"><a name="line1945"></a>1945             end
</span><span class="uncovered1"><a name="line1946"></a>1946           elsif match = DynamicScopeMatch.match(method_id)
</span><span class="uncovered0"><a name="line1947"></a>1947             attribute_names = match.attribute_names
</span><span class="uncovered1"><a name="line1948"></a>1948             super unless all_attributes_exists?(attribute_names)
</span><span class="uncovered0"><a name="line1949"></a>1949             if match.scope?
</span><span class="uncovered1"><a name="line1950"></a>1950               self.class_eval %{
</span><span class="uncovered0"><a name="line1951"></a>1951                 def self.#{method_id}(*args)                        # def self.scoped_by_user_name_and_password(*args)
</span><span class="uncovered1"><a name="line1952"></a>1952                   options = args.extract_options!                   #   options = args.extract_options!
</span><span class="uncovered0"><a name="line1953"></a>1953                   attributes = construct_attributes_from_arguments( #   attributes = construct_attributes_from_arguments(
</span><span class="uncovered1"><a name="line1954"></a>1954                     [:#{attribute_names.join(',:')}], args          #     [:user_name, :password], args
</span><span class="uncovered0"><a name="line1955"></a>1955                   )                                                 #   )
</span><span class="uncovered1"><a name="line1956"></a>1956                                                                     # 
</span><span class="uncovered0"><a name="line1957"></a>1957                   scoped(:conditions =&gt; attributes)                 #   scoped(:conditions =&gt; attributes)
</span><span class="uncovered1"><a name="line1958"></a>1958                 end                                                 # end
</span><span class="uncovered0"><a name="line1959"></a>1959               }, __FILE__, __LINE__
</span><span class="uncovered1"><a name="line1960"></a>1960               send(method_id, *arguments)
</span><span class="uncovered0"><a name="line1961"></a>1961             end
</span><span class="uncovered1"><a name="line1962"></a>1962           else
</span><span class="uncovered0"><a name="line1963"></a>1963             super
</span><span class="uncovered1"><a name="line1964"></a>1964           end
</span><span class="uncovered0"><a name="line1965"></a>1965         end
</span><span class="inferred1"><a name="line1966"></a>1966 
</span><span class="marked0"><a name="line1967"></a>1967         def construct_attributes_from_arguments(attribute_names, arguments)
</span><span class="uncovered1"><a name="line1968"></a>1968           attributes = {}
</span><span class="uncovered0"><a name="line1969"></a>1969           attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }
</span><span class="uncovered1"><a name="line1970"></a>1970           attributes
</span><span class="uncovered0"><a name="line1971"></a>1971         end
</span><span class="inferred1"><a name="line1972"></a>1972 
</span><span class="inferred0"><a name="line1973"></a>1973         # Similar in purpose to +expand_hash_conditions_for_aggregates+.
</span><span class="marked1"><a name="line1974"></a>1974         def expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered0"><a name="line1975"></a>1975           expanded_attribute_names = []
</span><span class="uncovered1"><a name="line1976"></a>1976           attribute_names.each do |attribute_name|
</span><span class="uncovered0"><a name="line1977"></a>1977             unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?
</span><span class="uncovered1"><a name="line1978"></a>1978               aggregate_mapping(aggregation).each do |field_attr, aggregate_attr|
</span><span class="uncovered0"><a name="line1979"></a>1979                 expanded_attribute_names &lt;&lt; field_attr
</span><span class="uncovered1"><a name="line1980"></a>1980               end
</span><span class="uncovered0"><a name="line1981"></a>1981             else
</span><span class="uncovered1"><a name="line1982"></a>1982               expanded_attribute_names &lt;&lt; attribute_name
</span><span class="uncovered0"><a name="line1983"></a>1983             end
</span><span class="uncovered1"><a name="line1984"></a>1984           end
</span><span class="uncovered0"><a name="line1985"></a>1985           expanded_attribute_names
</span><span class="uncovered1"><a name="line1986"></a>1986         end
</span><span class="inferred0"><a name="line1987"></a>1987 
</span><span class="marked1"><a name="line1988"></a>1988         def all_attributes_exists?(attribute_names)
</span><span class="uncovered0"><a name="line1989"></a>1989           attribute_names = expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered1"><a name="line1990"></a>1990           attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }
</span><span class="uncovered0"><a name="line1991"></a>1991         end
</span><span class="inferred1"><a name="line1992"></a>1992 
</span><span class="marked0"><a name="line1993"></a>1993         def attribute_condition(argument)
</span><span class="uncovered1"><a name="line1994"></a>1994           case argument
</span><span class="uncovered0"><a name="line1995"></a>1995             when nil   then &quot;IS ?&quot;
</span><span class="uncovered1"><a name="line1996"></a>1996             when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then &quot;IN (?)&quot;
</span><span class="uncovered0"><a name="line1997"></a>1997             when Range then &quot;BETWEEN ? AND ?&quot;
</span><span class="uncovered1"><a name="line1998"></a>1998             else            &quot;= ?&quot;
</span><span class="uncovered0"><a name="line1999"></a>1999           end
</span><span class="uncovered1"><a name="line2000"></a>2000         end
</span><span class="inferred0"><a name="line2001"></a>2001 
</span><span class="inferred1"><a name="line2002"></a>2002         # Interpret Array and Hash as conditions and anything else as an id.
</span><span class="marked0"><a name="line2003"></a>2003         def expand_id_conditions(id_or_conditions)
</span><span class="uncovered1"><a name="line2004"></a>2004           case id_or_conditions
</span><span class="uncovered0"><a name="line2005"></a>2005             when Array, Hash then id_or_conditions
</span><span class="uncovered1"><a name="line2006"></a>2006             else sanitize_sql(primary_key =&gt; id_or_conditions)
</span><span class="uncovered0"><a name="line2007"></a>2007           end
</span><span class="uncovered1"><a name="line2008"></a>2008         end
</span><span class="inferred0"><a name="line2009"></a>2009 
</span><span class="inferred1"><a name="line2010"></a>2010 
</span><span class="inferred0"><a name="line2011"></a>2011         # Defines an &quot;attribute&quot; method (like +inheritance_column+ or
</span><span class="inferred1"><a name="line2012"></a>2012         # +table_name+). A new (class) method will be created with the
</span><span class="inferred0"><a name="line2013"></a>2013         # given name. If a value is specified, the new method will
</span><span class="inferred1"><a name="line2014"></a>2014         # return that value (as a string). Otherwise, the given block
</span><span class="inferred0"><a name="line2015"></a>2015         # will be used to compute the value of the method.
</span><span class="inferred1"><a name="line2016"></a>2016         #
</span><span class="inferred0"><a name="line2017"></a>2017         # The original method will be aliased, with the new name being
</span><span class="inferred1"><a name="line2018"></a>2018         # prefixed with &quot;original_&quot;. This allows the new method to
</span><span class="inferred0"><a name="line2019"></a>2019         # access the original value.
</span><span class="inferred1"><a name="line2020"></a>2020         #
</span><span class="inferred0"><a name="line2021"></a>2021         # Example:
</span><span class="inferred1"><a name="line2022"></a>2022         #
</span><span class="inferred0"><a name="line2023"></a>2023         #   class A &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2024"></a>2024         #     define_attr_method :primary_key, &quot;sysid&quot;
</span><span class="inferred0"><a name="line2025"></a>2025         #     define_attr_method( :inheritance_column ) do
</span><span class="inferred1"><a name="line2026"></a>2026         #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred0"><a name="line2027"></a>2027         #     end
</span><span class="inferred1"><a name="line2028"></a>2028         #   end
</span><span class="marked0"><a name="line2029"></a>2029         def define_attr_method(name, value=nil, &amp;block)
</span><span class="uncovered1"><a name="line2030"></a>2030           sing = class &lt;&lt; self; self; end
</span><span class="uncovered0"><a name="line2031"></a>2031           sing.send :alias_method, &quot;original_#{name}&quot;, name
</span><span class="uncovered1"><a name="line2032"></a>2032           if block_given?
</span><span class="uncovered0"><a name="line2033"></a>2033             sing.send :define_method, name, &amp;block
</span><span class="uncovered1"><a name="line2034"></a>2034           else
</span><span class="uncovered0"><a name="line2035"></a>2035             # use eval instead of a block to work around a memory leak in dev
</span><span class="uncovered1"><a name="line2036"></a>2036             # mode in fcgi
</span><span class="uncovered0"><a name="line2037"></a>2037             sing.class_eval &quot;def #{name}; #{value.to_s.inspect}; end&quot;
</span><span class="uncovered1"><a name="line2038"></a>2038           end
</span><span class="uncovered0"><a name="line2039"></a>2039         end
</span><span class="inferred1"><a name="line2040"></a>2040 
</span><span class="marked0"><a name="line2041"></a>2041       protected
</span><span class="inferred1"><a name="line2042"></a>2042         # Scope parameters to method calls within the block.  Takes a hash of method_name =&gt; parameters hash.
</span><span class="inferred0"><a name="line2043"></a>2043         # method_name may be &lt;tt&gt;:find&lt;/tt&gt; or &lt;tt&gt;:create&lt;/tt&gt;. &lt;tt&gt;:find&lt;/tt&gt; parameters may include the &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:joins&lt;/tt&gt;,
</span><span class="inferred1"><a name="line2044"></a>2044         # &lt;tt&gt;:include&lt;/tt&gt;, &lt;tt&gt;:offset&lt;/tt&gt;, &lt;tt&gt;:limit&lt;/tt&gt;, and &lt;tt&gt;:readonly&lt;/tt&gt; options. &lt;tt&gt;:create&lt;/tt&gt; parameters are an attributes hash.
</span><span class="inferred0"><a name="line2045"></a>2045         #
</span><span class="inferred1"><a name="line2046"></a>2046         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line2047"></a>2047         #     def self.create_with_scope
</span><span class="inferred1"><a name="line2048"></a>2048         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot; }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred0"><a name="line2049"></a>2049         #         find(1) # =&gt; SELECT * from articles WHERE blog_id = 1 AND id = 1
</span><span class="inferred1"><a name="line2050"></a>2050         #         a = create(1)
</span><span class="inferred0"><a name="line2051"></a>2051         #         a.blog_id # =&gt; 1
</span><span class="inferred1"><a name="line2052"></a>2052         #       end
</span><span class="inferred0"><a name="line2053"></a>2053         #     end
</span><span class="inferred1"><a name="line2054"></a>2054         #   end
</span><span class="inferred0"><a name="line2055"></a>2055         #
</span><span class="inferred1"><a name="line2056"></a>2056         # In nested scopings, all previous parameters are overwritten by the innermost rule, with the exception of
</span><span class="inferred0"><a name="line2057"></a>2057         # &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:include&lt;/tt&gt;, and &lt;tt&gt;:joins&lt;/tt&gt; options in &lt;tt&gt;:find&lt;/tt&gt;, which are merged.
</span><span class="inferred1"><a name="line2058"></a>2058         #
</span><span class="inferred0"><a name="line2059"></a>2059         # &lt;tt&gt;:joins&lt;/tt&gt; options are uniqued so multiple scopes can join in the same table without table aliasing
</span><span class="inferred1"><a name="line2060"></a>2060         # problems.  If you need to join multiple tables, but still want one of the tables to be uniqued, use the
</span><span class="inferred0"><a name="line2061"></a>2061         # array of strings format for your joins.
</span><span class="inferred1"><a name="line2062"></a>2062         #
</span><span class="inferred0"><a name="line2063"></a>2063         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2064"></a>2064         #     def self.find_with_scope
</span><span class="inferred0"><a name="line2065"></a>2065         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred1"><a name="line2066"></a>2066         #         with_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred0"><a name="line2067"></a>2067         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 LIMIT 10
</span><span class="inferred1"><a name="line2068"></a>2068         #         end
</span><span class="inferred0"><a name="line2069"></a>2069         #         with_scope(:find =&gt; { :conditions =&gt; &quot;author_id = 3&quot; })
</span><span class="inferred1"><a name="line2070"></a>2070         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 AND author_id = 3 LIMIT 1
</span><span class="inferred0"><a name="line2071"></a>2071         #         end
</span><span class="inferred1"><a name="line2072"></a>2072         #       end
</span><span class="inferred0"><a name="line2073"></a>2073         #     end
</span><span class="inferred1"><a name="line2074"></a>2074         #   end
</span><span class="inferred0"><a name="line2075"></a>2075         #
</span><span class="inferred1"><a name="line2076"></a>2076         # You can ignore any previous scopings by using the &lt;tt&gt;with_exclusive_scope&lt;/tt&gt; method.
</span><span class="inferred0"><a name="line2077"></a>2077         #
</span><span class="inferred1"><a name="line2078"></a>2078         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line2079"></a>2079         #     def self.find_with_exclusive_scope
</span><span class="inferred1"><a name="line2080"></a>2080         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }) do
</span><span class="inferred0"><a name="line2081"></a>2081         #         with_exclusive_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred1"><a name="line2082"></a>2082         #           find(:all) # =&gt; SELECT * from articles LIMIT 10
</span><span class="inferred0"><a name="line2083"></a>2083         #         end
</span><span class="inferred1"><a name="line2084"></a>2084         #       end
</span><span class="inferred0"><a name="line2085"></a>2085         #     end
</span><span class="inferred1"><a name="line2086"></a>2086         #   end
</span><span class="inferred0"><a name="line2087"></a>2087         #
</span><span class="inferred1"><a name="line2088"></a>2088         # *Note*: the +:find+ scope also has effect on update and deletion methods,
</span><span class="inferred0"><a name="line2089"></a>2089         # like +update_all+ and +delete_all+.
</span><span class="marked1"><a name="line2090"></a>2090         def with_scope(method_scoping = {}, action = :merge, &amp;block)
</span><span class="uncovered0"><a name="line2091"></a>2091           method_scoping = method_scoping.method_scoping if method_scoping.respond_to?(:method_scoping)
</span><span class="uncovered1"><a name="line2092"></a>2092 
</span><span class="uncovered0"><a name="line2093"></a>2093           # Dup first and second level of hash (method and params).
</span><span class="uncovered1"><a name="line2094"></a>2094           method_scoping = method_scoping.inject({}) do |hash, (method, params)|
</span><span class="uncovered0"><a name="line2095"></a>2095             hash[method] = (params == true) ? params : params.dup
</span><span class="uncovered1"><a name="line2096"></a>2096             hash
</span><span class="uncovered0"><a name="line2097"></a>2097           end
</span><span class="uncovered1"><a name="line2098"></a>2098 
</span><span class="uncovered0"><a name="line2099"></a>2099           method_scoping.assert_valid_keys([ :find, :create ])
</span><span class="uncovered1"><a name="line2100"></a>2100 
</span><span class="uncovered0"><a name="line2101"></a>2101           if f = method_scoping[:find]
</span><span class="uncovered1"><a name="line2102"></a>2102             f.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="uncovered0"><a name="line2103"></a>2103             set_readonly_option! f
</span><span class="uncovered1"><a name="line2104"></a>2104           end
</span><span class="uncovered0"><a name="line2105"></a>2105 
</span><span class="uncovered1"><a name="line2106"></a>2106           # Merge scopings
</span><span class="uncovered0"><a name="line2107"></a>2107           if action == :merge &amp;&amp; current_scoped_methods
</span><span class="uncovered1"><a name="line2108"></a>2108             method_scoping = current_scoped_methods.inject(method_scoping) do |hash, (method, params)|
</span><span class="uncovered0"><a name="line2109"></a>2109               case hash[method]
</span><span class="uncovered1"><a name="line2110"></a>2110                 when Hash
</span><span class="uncovered0"><a name="line2111"></a>2111                   if method == :find
</span><span class="uncovered1"><a name="line2112"></a>2112                     (hash[method].keys + params.keys).uniq.each do |key|
</span><span class="uncovered0"><a name="line2113"></a>2113                       merge = hash[method][key] &amp;&amp; params[key] # merge if both scopes have the same key
</span><span class="uncovered1"><a name="line2114"></a>2114                       if key == :conditions &amp;&amp; merge
</span><span class="uncovered0"><a name="line2115"></a>2115                         if params[key].is_a?(Hash) &amp;&amp; hash[method][key].is_a?(Hash)
</span><span class="uncovered1"><a name="line2116"></a>2116                           hash[method][key] = merge_conditions(hash[method][key].deep_merge(params[key]))
</span><span class="uncovered0"><a name="line2117"></a>2117                         else
</span><span class="uncovered1"><a name="line2118"></a>2118                           hash[method][key] = merge_conditions(params[key], hash[method][key])
</span><span class="uncovered0"><a name="line2119"></a>2119                         end
</span><span class="uncovered1"><a name="line2120"></a>2120                       elsif key == :include &amp;&amp; merge
</span><span class="uncovered0"><a name="line2121"></a>2121                         hash[method][key] = merge_includes(hash[method][key], params[key]).uniq
</span><span class="uncovered1"><a name="line2122"></a>2122                       elsif key == :joins &amp;&amp; merge
</span><span class="uncovered0"><a name="line2123"></a>2123                         hash[method][key] = merge_joins(params[key], hash[method][key])
</span><span class="uncovered1"><a name="line2124"></a>2124                       else
</span><span class="uncovered0"><a name="line2125"></a>2125                         hash[method][key] = hash[method][key] || params[key]
</span><span class="uncovered1"><a name="line2126"></a>2126                       end
</span><span class="uncovered0"><a name="line2127"></a>2127                     end
</span><span class="uncovered1"><a name="line2128"></a>2128                   else
</span><span class="uncovered0"><a name="line2129"></a>2129                     hash[method] = hash[method].merge(params)
</span><span class="uncovered1"><a name="line2130"></a>2130                   end
</span><span class="uncovered0"><a name="line2131"></a>2131                 else
</span><span class="uncovered1"><a name="line2132"></a>2132                   hash[method] = params
</span><span class="uncovered0"><a name="line2133"></a>2133               end
</span><span class="uncovered1"><a name="line2134"></a>2134               hash
</span><span class="uncovered0"><a name="line2135"></a>2135             end
</span><span class="uncovered1"><a name="line2136"></a>2136           end
</span><span class="uncovered0"><a name="line2137"></a>2137 
</span><span class="uncovered1"><a name="line2138"></a>2138           self.scoped_methods &lt;&lt; method_scoping
</span><span class="uncovered0"><a name="line2139"></a>2139 
</span><span class="uncovered1"><a name="line2140"></a>2140           begin
</span><span class="uncovered0"><a name="line2141"></a>2141             yield
</span><span class="uncovered1"><a name="line2142"></a>2142           ensure
</span><span class="uncovered0"><a name="line2143"></a>2143             self.scoped_methods.pop
</span><span class="uncovered1"><a name="line2144"></a>2144           end
</span><span class="uncovered0"><a name="line2145"></a>2145         end
</span><span class="inferred1"><a name="line2146"></a>2146 
</span><span class="inferred0"><a name="line2147"></a>2147         # Works like with_scope, but discards any nested properties.
</span><span class="marked1"><a name="line2148"></a>2148         def with_exclusive_scope(method_scoping = {}, &amp;block)
</span><span class="uncovered0"><a name="line2149"></a>2149           with_scope(method_scoping, :overwrite, &amp;block)
</span><span class="uncovered1"><a name="line2150"></a>2150         end
</span><span class="inferred0"><a name="line2151"></a>2151 
</span><span class="marked1"><a name="line2152"></a>2152         def subclasses #:nodoc:
</span><span class="uncovered0"><a name="line2153"></a>2153           @@subclasses[self] ||= []
</span><span class="uncovered1"><a name="line2154"></a>2154           @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }
</span><span class="uncovered0"><a name="line2155"></a>2155         end
</span><span class="inferred1"><a name="line2156"></a>2156 
</span><span class="inferred0"><a name="line2157"></a>2157         # Sets the default options for the model. The format of the
</span><span class="inferred1"><a name="line2158"></a>2158         # &lt;tt&gt;options&lt;/tt&gt; argument is the same as in find.
</span><span class="inferred0"><a name="line2159"></a>2159         #
</span><span class="inferred1"><a name="line2160"></a>2160         #   class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line2161"></a>2161         #     default_scope :order =&gt; 'last_name, first_name'
</span><span class="inferred1"><a name="line2162"></a>2162         #   end
</span><span class="marked0"><a name="line2163"></a>2163         def default_scope(options = {})
</span><span class="uncovered1"><a name="line2164"></a>2164           self.default_scoping &lt;&lt; { :find =&gt; options, :create =&gt; (options.is_a?(Hash) &amp;&amp; options.has_key?(:conditions)) ? options[:conditions] : {} }
</span><span class="uncovered0"><a name="line2165"></a>2165         end
</span><span class="inferred1"><a name="line2166"></a>2166 
</span><span class="inferred0"><a name="line2167"></a>2167         # Test whether the given method and optional key are scoped.
</span><span class="marked1"><a name="line2168"></a>2168         def scoped?(method, key = nil) #:nodoc:
</span><span class="uncovered0"><a name="line2169"></a>2169           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered1"><a name="line2170"></a>2170             !key || scope.has_key?(key)
</span><span class="uncovered0"><a name="line2171"></a>2171           end
</span><span class="uncovered1"><a name="line2172"></a>2172         end
</span><span class="inferred0"><a name="line2173"></a>2173 
</span><span class="inferred1"><a name="line2174"></a>2174         # Retrieve the scope for the given method and optional key.
</span><span class="marked0"><a name="line2175"></a>2175         def scope(method, key = nil) #:nodoc:
</span><span class="uncovered1"><a name="line2176"></a>2176           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered0"><a name="line2177"></a>2177             key ? scope[key] : scope
</span><span class="uncovered1"><a name="line2178"></a>2178           end
</span><span class="uncovered0"><a name="line2179"></a>2179         end
</span><span class="inferred1"><a name="line2180"></a>2180 
</span><span class="marked0"><a name="line2181"></a>2181         def scoped_methods #:nodoc:
</span><span class="uncovered1"><a name="line2182"></a>2182           Thread.current[:&quot;#{self}_scoped_methods&quot;] ||= self.default_scoping.dup
</span><span class="uncovered0"><a name="line2183"></a>2183         end
</span><span class="inferred1"><a name="line2184"></a>2184 
</span><span class="marked0"><a name="line2185"></a>2185         def current_scoped_methods #:nodoc:
</span><span class="uncovered1"><a name="line2186"></a>2186           scoped_methods.last
</span><span class="uncovered0"><a name="line2187"></a>2187         end
</span><span class="inferred1"><a name="line2188"></a>2188 
</span><span class="inferred0"><a name="line2189"></a>2189         # Returns the class type of the record using the current module as a prefix. So descendants of
</span><span class="inferred1"><a name="line2190"></a>2190         # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
</span><span class="marked0"><a name="line2191"></a>2191         def compute_type(type_name)
</span><span class="uncovered1"><a name="line2192"></a>2192           modularized_name = type_name_with_module(type_name)
</span><span class="uncovered0"><a name="line2193"></a>2193           silence_warnings do
</span><span class="uncovered1"><a name="line2194"></a>2194             begin
</span><span class="uncovered0"><a name="line2195"></a>2195               class_eval(modularized_name, __FILE__, __LINE__)
</span><span class="uncovered1"><a name="line2196"></a>2196             rescue NameError
</span><span class="uncovered0"><a name="line2197"></a>2197               class_eval(type_name, __FILE__, __LINE__)
</span><span class="uncovered1"><a name="line2198"></a>2198             end
</span><span class="uncovered0"><a name="line2199"></a>2199           end
</span><span class="uncovered1"><a name="line2200"></a>2200         end
</span><span class="inferred0"><a name="line2201"></a>2201 
</span><span class="inferred1"><a name="line2202"></a>2202         # Returns the class descending directly from ActiveRecord::Base or an
</span><span class="inferred0"><a name="line2203"></a>2203         # abstract class, if any, in the inheritance hierarchy.
</span><span class="marked1"><a name="line2204"></a>2204         def class_of_active_record_descendant(klass)
</span><span class="uncovered0"><a name="line2205"></a>2205           if klass.superclass == Base || klass.superclass.abstract_class?
</span><span class="uncovered1"><a name="line2206"></a>2206             klass
</span><span class="uncovered0"><a name="line2207"></a>2207           elsif klass.superclass.nil?
</span><span class="uncovered1"><a name="line2208"></a>2208             raise ActiveRecordError, &quot;#{name} doesn't belong in a hierarchy descending from ActiveRecord&quot;
</span><span class="uncovered0"><a name="line2209"></a>2209           else
</span><span class="uncovered1"><a name="line2210"></a>2210             class_of_active_record_descendant(klass.superclass)
</span><span class="uncovered0"><a name="line2211"></a>2211           end
</span><span class="uncovered1"><a name="line2212"></a>2212         end
</span><span class="inferred0"><a name="line2213"></a>2213 
</span><span class="inferred1"><a name="line2214"></a>2214         # Returns the name of the class descending directly from Active Record in the inheritance hierarchy.
</span><span class="marked0"><a name="line2215"></a>2215         def class_name_of_active_record_descendant(klass) #:nodoc:
</span><span class="uncovered1"><a name="line2216"></a>2216           klass.base_class.name
</span><span class="uncovered0"><a name="line2217"></a>2217         end
</span><span class="inferred1"><a name="line2218"></a>2218 
</span><span class="inferred0"><a name="line2219"></a>2219         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred1"><a name="line2220"></a>2220         # them into a valid SQL fragment for a WHERE clause.
</span><span class="inferred0"><a name="line2221"></a>2221         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred1"><a name="line2222"></a>2222         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }  returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred0"><a name="line2223"></a>2223         #   &quot;name='foo''bar' and group_id='4'&quot; returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked1"><a name="line2224"></a>2224         def sanitize_sql_for_conditions(condition)
</span><span class="uncovered0"><a name="line2225"></a>2225           return nil if condition.blank?
</span><span class="uncovered1"><a name="line2226"></a>2226 
</span><span class="uncovered0"><a name="line2227"></a>2227           case condition
</span><span class="uncovered1"><a name="line2228"></a>2228             when Array; sanitize_sql_array(condition)
</span><span class="uncovered0"><a name="line2229"></a>2229             when Hash;  sanitize_sql_hash_for_conditions(condition)
</span><span class="uncovered1"><a name="line2230"></a>2230             else        condition
</span><span class="uncovered0"><a name="line2231"></a>2231           end
</span><span class="uncovered1"><a name="line2232"></a>2232         end
</span><span class="marked0"><a name="line2233"></a>2233         alias_method :sanitize_sql, :sanitize_sql_for_conditions
</span><span class="inferred1"><a name="line2234"></a>2234 
</span><span class="inferred0"><a name="line2235"></a>2235         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred1"><a name="line2236"></a>2236         # them into a valid SQL fragment for a SET clause.
</span><span class="inferred0"><a name="line2237"></a>2237         #   { :name =&gt; nil, :group_id =&gt; 4 }  returns &quot;name = NULL , group_id='4'&quot;
</span><span class="marked1"><a name="line2238"></a>2238         def sanitize_sql_for_assignment(assignments)
</span><span class="uncovered0"><a name="line2239"></a>2239           case assignments
</span><span class="uncovered1"><a name="line2240"></a>2240             when Array; sanitize_sql_array(assignments)
</span><span class="uncovered0"><a name="line2241"></a>2241             when Hash;  sanitize_sql_hash_for_assignment(assignments)
</span><span class="uncovered1"><a name="line2242"></a>2242             else        assignments
</span><span class="uncovered0"><a name="line2243"></a>2243           end
</span><span class="uncovered1"><a name="line2244"></a>2244         end
</span><span class="inferred0"><a name="line2245"></a>2245 
</span><span class="marked1"><a name="line2246"></a>2246         def aggregate_mapping(reflection)
</span><span class="uncovered0"><a name="line2247"></a>2247           mapping = reflection.options[:mapping] || [reflection.name, reflection.name]
</span><span class="uncovered1"><a name="line2248"></a>2248           mapping.first.is_a?(Array) ? mapping : [mapping]
</span><span class="uncovered0"><a name="line2249"></a>2249         end
</span><span class="inferred1"><a name="line2250"></a>2250 
</span><span class="inferred0"><a name="line2251"></a>2251         # Accepts a hash of SQL conditions and replaces those attributes
</span><span class="inferred1"><a name="line2252"></a>2252         # that correspond to a +composed_of+ relationship with their expanded
</span><span class="inferred0"><a name="line2253"></a>2253         # aggregate attribute values.
</span><span class="inferred1"><a name="line2254"></a>2254         # Given:
</span><span class="inferred0"><a name="line2255"></a>2255         #     class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2256"></a>2256         #       composed_of :address, :class_name =&gt; &quot;Address&quot;,
</span><span class="inferred0"><a name="line2257"></a>2257         #         :mapping =&gt; [%w(address_street street), %w(address_city city)]
</span><span class="inferred1"><a name="line2258"></a>2258         #     end
</span><span class="inferred0"><a name="line2259"></a>2259         # Then:
</span><span class="inferred1"><a name="line2260"></a>2260         #     { :address =&gt; Address.new(&quot;813 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred0"><a name="line2261"></a>2261         #       # =&gt; { :address_street =&gt; &quot;813 abc st.&quot;, :address_city =&gt; &quot;chicago&quot; }
</span><span class="marked1"><a name="line2262"></a>2262         def expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered0"><a name="line2263"></a>2263           expanded_attrs = {}
</span><span class="uncovered1"><a name="line2264"></a>2264           attrs.each do |attr, value|
</span><span class="uncovered0"><a name="line2265"></a>2265             unless (aggregation = reflect_on_aggregation(attr.to_sym)).nil?
</span><span class="uncovered1"><a name="line2266"></a>2266               mapping = aggregate_mapping(aggregation)
</span><span class="uncovered0"><a name="line2267"></a>2267               mapping.each do |field_attr, aggregate_attr|
</span><span class="uncovered1"><a name="line2268"></a>2268                 if mapping.size == 1 &amp;&amp; !value.respond_to?(aggregate_attr)
</span><span class="uncovered0"><a name="line2269"></a>2269                   expanded_attrs[field_attr] = value
</span><span class="uncovered1"><a name="line2270"></a>2270                 else
</span><span class="uncovered0"><a name="line2271"></a>2271                   expanded_attrs[field_attr] = value.send(aggregate_attr)
</span><span class="uncovered1"><a name="line2272"></a>2272                 end
</span><span class="uncovered0"><a name="line2273"></a>2273               end
</span><span class="uncovered1"><a name="line2274"></a>2274             else
</span><span class="uncovered0"><a name="line2275"></a>2275               expanded_attrs[attr] = value
</span><span class="uncovered1"><a name="line2276"></a>2276             end
</span><span class="uncovered0"><a name="line2277"></a>2277           end
</span><span class="uncovered1"><a name="line2278"></a>2278           expanded_attrs
</span><span class="uncovered0"><a name="line2279"></a>2279         end
</span><span class="inferred1"><a name="line2280"></a>2280 
</span><span class="inferred0"><a name="line2281"></a>2281         # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
</span><span class="inferred1"><a name="line2282"></a>2282         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }
</span><span class="inferred0"><a name="line2283"></a>2283         #     # =&gt; &quot;name='foo''bar' and group_id= 4&quot;
</span><span class="inferred1"><a name="line2284"></a>2284         #   { :status =&gt; nil, :group_id =&gt; [1,2,3] }
</span><span class="inferred0"><a name="line2285"></a>2285         #     # =&gt; &quot;status IS NULL and group_id IN (1,2,3)&quot;
</span><span class="inferred1"><a name="line2286"></a>2286         #   { :age =&gt; 13..18 }
</span><span class="inferred0"><a name="line2287"></a>2287         #     # =&gt; &quot;age BETWEEN 13 AND 18&quot;
</span><span class="inferred1"><a name="line2288"></a>2288         #   { 'other_records.id' =&gt; 7 }
</span><span class="inferred0"><a name="line2289"></a>2289         #     # =&gt; &quot;`other_records`.`id` = 7&quot;
</span><span class="inferred1"><a name="line2290"></a>2290         #   { :other_records =&gt; { :id =&gt; 7 } }
</span><span class="inferred0"><a name="line2291"></a>2291         #     # =&gt; &quot;`other_records`.`id` = 7&quot;
</span><span class="inferred1"><a name="line2292"></a>2292         # And for value objects on a composed_of relationship:
</span><span class="inferred0"><a name="line2293"></a>2293         #   { :address =&gt; Address.new(&quot;123 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred1"><a name="line2294"></a>2294         #     # =&gt; &quot;address_street='123 abc st.' and address_city='chicago'&quot;
</span><span class="marked0"><a name="line2295"></a>2295         def sanitize_sql_hash_for_conditions(attrs, table_name = quoted_table_name)
</span><span class="uncovered1"><a name="line2296"></a>2296           attrs = expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered0"><a name="line2297"></a>2297 
</span><span class="uncovered1"><a name="line2298"></a>2298           conditions = attrs.map do |attr, value|
</span><span class="uncovered0"><a name="line2299"></a>2299             unless value.is_a?(Hash)
</span><span class="uncovered1"><a name="line2300"></a>2300               attr = attr.to_s
</span><span class="uncovered0"><a name="line2301"></a>2301 
</span><span class="uncovered1"><a name="line2302"></a>2302               # Extract table name from qualified attribute names.
</span><span class="uncovered0"><a name="line2303"></a>2303               if attr.include?('.')
</span><span class="uncovered1"><a name="line2304"></a>2304                 table_name, attr = attr.split('.', 2)
</span><span class="uncovered0"><a name="line2305"></a>2305                 table_name = connection.quote_table_name(table_name)
</span><span class="uncovered1"><a name="line2306"></a>2306               end
</span><span class="uncovered0"><a name="line2307"></a>2307 
</span><span class="uncovered1"><a name="line2308"></a>2308               &quot;#{table_name}.#{connection.quote_column_name(attr)} #{attribute_condition(value)}&quot;
</span><span class="uncovered0"><a name="line2309"></a>2309             else
</span><span class="uncovered1"><a name="line2310"></a>2310               sanitize_sql_hash_for_conditions(value, connection.quote_table_name(attr.to_s))
</span><span class="uncovered0"><a name="line2311"></a>2311             end
</span><span class="uncovered1"><a name="line2312"></a>2312           end.join(' AND ')
</span><span class="uncovered0"><a name="line2313"></a>2313 
</span><span class="uncovered1"><a name="line2314"></a>2314           replace_bind_variables(conditions, expand_range_bind_variables(attrs.values))
</span><span class="uncovered0"><a name="line2315"></a>2315         end
</span><span class="marked1"><a name="line2316"></a>2316         alias_method :sanitize_sql_hash, :sanitize_sql_hash_for_conditions
</span><span class="inferred0"><a name="line2317"></a>2317 
</span><span class="inferred1"><a name="line2318"></a>2318         # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
</span><span class="inferred0"><a name="line2319"></a>2319         #   { :status =&gt; nil, :group_id =&gt; 1 }
</span><span class="inferred1"><a name="line2320"></a>2320         #     # =&gt; &quot;status = NULL , group_id = 1&quot;
</span><span class="marked0"><a name="line2321"></a>2321         def sanitize_sql_hash_for_assignment(attrs)
</span><span class="uncovered1"><a name="line2322"></a>2322           attrs.map do |attr, value|
</span><span class="uncovered0"><a name="line2323"></a>2323             &quot;#{connection.quote_column_name(attr)} = #{quote_bound_value(value)}&quot;
</span><span class="uncovered1"><a name="line2324"></a>2324           end.join(', ')
</span><span class="uncovered0"><a name="line2325"></a>2325         end
</span><span class="inferred1"><a name="line2326"></a>2326 
</span><span class="inferred0"><a name="line2327"></a>2327         # Accepts an array of conditions.  The array has each value
</span><span class="inferred1"><a name="line2328"></a>2328         # sanitized and interpolated into the SQL statement.
</span><span class="inferred0"><a name="line2329"></a>2329         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked1"><a name="line2330"></a>2330         def sanitize_sql_array(ary)
</span><span class="uncovered0"><a name="line2331"></a>2331           statement, *values = ary
</span><span class="uncovered1"><a name="line2332"></a>2332           if values.first.is_a?(Hash) and statement =~ /:\w+/
</span><span class="uncovered0"><a name="line2333"></a>2333             replace_named_bind_variables(statement, values.first)
</span><span class="uncovered1"><a name="line2334"></a>2334           elsif statement.include?('?')
</span><span class="uncovered0"><a name="line2335"></a>2335             replace_bind_variables(statement, values)
</span><span class="uncovered1"><a name="line2336"></a>2336           else
</span><span class="uncovered0"><a name="line2337"></a>2337             statement % values.collect { |value| connection.quote_string(value.to_s) }
</span><span class="uncovered1"><a name="line2338"></a>2338           end
</span><span class="uncovered0"><a name="line2339"></a>2339         end
</span><span class="inferred1"><a name="line2340"></a>2340 
</span><span class="marked0"><a name="line2341"></a>2341         alias_method :sanitize_conditions, :sanitize_sql
</span><span class="inferred1"><a name="line2342"></a>2342 
</span><span class="marked0"><a name="line2343"></a>2343         def replace_bind_variables(statement, values) #:nodoc:
</span><span class="uncovered1"><a name="line2344"></a>2344           raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)
</span><span class="uncovered0"><a name="line2345"></a>2345           bound = values.dup
</span><span class="uncovered1"><a name="line2346"></a>2346           statement.gsub('?') { quote_bound_value(bound.shift) }
</span><span class="uncovered0"><a name="line2347"></a>2347         end
</span><span class="inferred1"><a name="line2348"></a>2348 
</span><span class="marked0"><a name="line2349"></a>2349         def replace_named_bind_variables(statement, bind_vars) #:nodoc:
</span><span class="uncovered1"><a name="line2350"></a>2350           statement.gsub(/(:?):([a-zA-Z]\w*)/) do
</span><span class="uncovered0"><a name="line2351"></a>2351             if $1 == ':' # skip postgresql casts
</span><span class="uncovered1"><a name="line2352"></a>2352               $&amp; # return the whole match
</span><span class="uncovered0"><a name="line2353"></a>2353             elsif bind_vars.include?(match = $2.to_sym)
</span><span class="uncovered1"><a name="line2354"></a>2354               quote_bound_value(bind_vars[match])
</span><span class="uncovered0"><a name="line2355"></a>2355             else
</span><span class="uncovered1"><a name="line2356"></a>2356               raise PreparedStatementInvalid, &quot;missing value for :#{match} in #{statement}&quot;
</span><span class="uncovered0"><a name="line2357"></a>2357             end
</span><span class="uncovered1"><a name="line2358"></a>2358           end
</span><span class="uncovered0"><a name="line2359"></a>2359         end
</span><span class="inferred1"><a name="line2360"></a>2360 
</span><span class="marked0"><a name="line2361"></a>2361         def expand_range_bind_variables(bind_vars) #:nodoc:
</span><span class="uncovered1"><a name="line2362"></a>2362           expanded = []
</span><span class="uncovered0"><a name="line2363"></a>2363 
</span><span class="uncovered1"><a name="line2364"></a>2364           bind_vars.each do |var|
</span><span class="uncovered0"><a name="line2365"></a>2365             next if var.is_a?(Hash)
</span><span class="uncovered1"><a name="line2366"></a>2366 
</span><span class="uncovered0"><a name="line2367"></a>2367             if var.is_a?(Range)
</span><span class="uncovered1"><a name="line2368"></a>2368               expanded &lt;&lt; var.first
</span><span class="uncovered0"><a name="line2369"></a>2369               expanded &lt;&lt; var.last
</span><span class="uncovered1"><a name="line2370"></a>2370             else
</span><span class="uncovered0"><a name="line2371"></a>2371               expanded &lt;&lt; var
</span><span class="uncovered1"><a name="line2372"></a>2372             end
</span><span class="uncovered0"><a name="line2373"></a>2373           end
</span><span class="uncovered1"><a name="line2374"></a>2374 
</span><span class="uncovered0"><a name="line2375"></a>2375           expanded
</span><span class="uncovered1"><a name="line2376"></a>2376         end
</span><span class="inferred0"><a name="line2377"></a>2377 
</span><span class="marked1"><a name="line2378"></a>2378         def quote_bound_value(value) #:nodoc:
</span><span class="uncovered0"><a name="line2379"></a>2379           if value.respond_to?(:map) &amp;&amp; !value.acts_like?(:string)
</span><span class="uncovered1"><a name="line2380"></a>2380             if value.respond_to?(:empty?) &amp;&amp; value.empty?
</span><span class="uncovered0"><a name="line2381"></a>2381               connection.quote(nil)
</span><span class="uncovered1"><a name="line2382"></a>2382             else
</span><span class="uncovered0"><a name="line2383"></a>2383               value.map { |v| connection.quote(v) }.join(',')
</span><span class="uncovered1"><a name="line2384"></a>2384             end
</span><span class="uncovered0"><a name="line2385"></a>2385           else
</span><span class="uncovered1"><a name="line2386"></a>2386             connection.quote(value)
</span><span class="uncovered0"><a name="line2387"></a>2387           end
</span><span class="uncovered1"><a name="line2388"></a>2388         end
</span><span class="inferred0"><a name="line2389"></a>2389 
</span><span class="marked1"><a name="line2390"></a>2390         def raise_if_bind_arity_mismatch(statement, expected, provided) #:nodoc:
</span><span class="uncovered0"><a name="line2391"></a>2391           unless expected == provided
</span><span class="uncovered1"><a name="line2392"></a>2392             raise PreparedStatementInvalid, &quot;wrong number of bind variables (#{provided} for #{expected}) in: #{statement}&quot;
</span><span class="uncovered0"><a name="line2393"></a>2393           end
</span><span class="uncovered1"><a name="line2394"></a>2394         end
</span><span class="inferred0"><a name="line2395"></a>2395 
</span><span class="marked1"><a name="line2396"></a>2396         VALID_FIND_OPTIONS = [ :conditions, :include, :joins, :limit, :offset,
</span><span class="inferred0"><a name="line2397"></a>2397                                :order, :select, :readonly, :group, :having, :from, :lock ]
</span><span class="inferred1"><a name="line2398"></a>2398 
</span><span class="marked0"><a name="line2399"></a>2399         def validate_find_options(options) #:nodoc:
</span><span class="uncovered1"><a name="line2400"></a>2400           options.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="uncovered0"><a name="line2401"></a>2401         end
</span><span class="inferred1"><a name="line2402"></a>2402 
</span><span class="marked0"><a name="line2403"></a>2403         def set_readonly_option!(options) #:nodoc:
</span><span class="uncovered1"><a name="line2404"></a>2404           # Inherit :readonly from finder scope if set.  Otherwise,
</span><span class="uncovered0"><a name="line2405"></a>2405           # if :joins is not blank then :readonly defaults to true.
</span><span class="uncovered1"><a name="line2406"></a>2406           unless options.has_key?(:readonly)
</span><span class="uncovered0"><a name="line2407"></a>2407             if scoped_readonly = scope(:find, :readonly)
</span><span class="uncovered1"><a name="line2408"></a>2408               options[:readonly] = scoped_readonly
</span><span class="uncovered0"><a name="line2409"></a>2409             elsif !options[:joins].blank? &amp;&amp; !options[:select]
</span><span class="uncovered1"><a name="line2410"></a>2410               options[:readonly] = true
</span><span class="uncovered0"><a name="line2411"></a>2411             end
</span><span class="uncovered1"><a name="line2412"></a>2412           end
</span><span class="uncovered0"><a name="line2413"></a>2413         end
</span><span class="inferred1"><a name="line2414"></a>2414 
</span><span class="marked0"><a name="line2415"></a>2415         def encode_quoted_value(value) #:nodoc:
</span><span class="uncovered1"><a name="line2416"></a>2416           quoted_value = connection.quote(value)
</span><span class="uncovered0"><a name="line2417"></a>2417           quoted_value = &quot;'#{quoted_value[1..-2].gsub(/\'/, &quot;\\\\'&quot;)}'&quot; if quoted_value.include?(&quot;\\\'&quot;) # (for ruby mode) &quot;
</span><span class="uncovered1"><a name="line2418"></a>2418           quoted_value
</span><span class="uncovered0"><a name="line2419"></a>2419         end
</span><span class="uncovered1"><a name="line2420"></a>2420     end
</span><span class="inferred0"><a name="line2421"></a>2421 
</span><span class="marked1"><a name="line2422"></a>2422     public
</span><span class="inferred0"><a name="line2423"></a>2423       # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
</span><span class="inferred1"><a name="line2424"></a>2424       # attributes but not yet saved (pass a hash with key names matching the associated table column names).
</span><span class="inferred0"><a name="line2425"></a>2425       # In both instances, valid attribute keys are determined by the column names of the associated table --
</span><span class="inferred1"><a name="line2426"></a>2426       # hence you can't have attributes that aren't part of the table columns.
</span><span class="marked0"><a name="line2427"></a>2427       def initialize(attributes = nil)
</span><span class="uncovered1"><a name="line2428"></a>2428         @attributes = attributes_from_column_definition
</span><span class="uncovered0"><a name="line2429"></a>2429         @attributes_cache = {}
</span><span class="uncovered1"><a name="line2430"></a>2430         @new_record = true
</span><span class="uncovered0"><a name="line2431"></a>2431         ensure_proper_type
</span><span class="uncovered1"><a name="line2432"></a>2432         self.attributes = attributes unless attributes.nil?
</span><span class="uncovered0"><a name="line2433"></a>2433         self.class.send(:scope, :create).each { |att,value| self.send(&quot;#{att}=&quot;, value) } if self.class.send(:scoped?, :create)
</span><span class="uncovered1"><a name="line2434"></a>2434         result = yield self if block_given?
</span><span class="uncovered0"><a name="line2435"></a>2435         callback(:after_initialize) if respond_to_without_attributes?(:after_initialize)
</span><span class="uncovered1"><a name="line2436"></a>2436         result
</span><span class="uncovered0"><a name="line2437"></a>2437       end
</span><span class="inferred1"><a name="line2438"></a>2438 
</span><span class="inferred0"><a name="line2439"></a>2439       # A model instance's primary key is always available as model.id
</span><span class="inferred1"><a name="line2440"></a>2440       # whether you name it the default 'id' or set it to something else.
</span><span class="marked0"><a name="line2441"></a>2441       def id
</span><span class="uncovered1"><a name="line2442"></a>2442         attr_name = self.class.primary_key
</span><span class="uncovered0"><a name="line2443"></a>2443         column = column_for_attribute(attr_name)
</span><span class="uncovered1"><a name="line2444"></a>2444 
</span><span class="uncovered0"><a name="line2445"></a>2445         self.class.send(:define_read_method, :id, attr_name, column)
</span><span class="uncovered1"><a name="line2446"></a>2446         # now that the method exists, call it
</span><span class="uncovered0"><a name="line2447"></a>2447         self.send attr_name.to_sym
</span><span class="uncovered1"><a name="line2448"></a>2448 
</span><span class="uncovered0"><a name="line2449"></a>2449       end
</span><span class="inferred1"><a name="line2450"></a>2450 
</span><span class="inferred0"><a name="line2451"></a>2451       # Returns a String, which Action Pack uses for constructing an URL to this
</span><span class="inferred1"><a name="line2452"></a>2452       # object. The default implementation returns this record's id as a String,
</span><span class="inferred0"><a name="line2453"></a>2453       # or nil if this record's unsaved.
</span><span class="inferred1"><a name="line2454"></a>2454       #
</span><span class="inferred0"><a name="line2455"></a>2455       # For example, suppose that you have a User model, and that you have a
</span><span class="inferred1"><a name="line2456"></a>2456       # &lt;tt&gt;map.resources :users&lt;/tt&gt; route. Normally, +user_path+ will
</span><span class="inferred0"><a name="line2457"></a>2457       # construct a path with the user object's 'id' in it:
</span><span class="inferred1"><a name="line2458"></a>2458       #
</span><span class="inferred0"><a name="line2459"></a>2459       #   user = User.find_by_name('Phusion')
</span><span class="inferred1"><a name="line2460"></a>2460       #   user_path(user)  # =&gt; &quot;/users/1&quot;
</span><span class="inferred0"><a name="line2461"></a>2461       #
</span><span class="inferred1"><a name="line2462"></a>2462       # You can override +to_param+ in your model to make +user_path+ construct
</span><span class="inferred0"><a name="line2463"></a>2463       # a path using the user's name instead of the user's id:
</span><span class="inferred1"><a name="line2464"></a>2464       #
</span><span class="inferred0"><a name="line2465"></a>2465       #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2466"></a>2466       #     def to_param  # overridden
</span><span class="inferred0"><a name="line2467"></a>2467       #       name
</span><span class="inferred1"><a name="line2468"></a>2468       #     end
</span><span class="inferred0"><a name="line2469"></a>2469       #   end
</span><span class="inferred1"><a name="line2470"></a>2470       #   
</span><span class="inferred0"><a name="line2471"></a>2471       #   user = User.find_by_name('Phusion')
</span><span class="inferred1"><a name="line2472"></a>2472       #   user_path(user)  # =&gt; &quot;/users/Phusion&quot;
</span><span class="marked0"><a name="line2473"></a>2473       def to_param
</span><span class="uncovered1"><a name="line2474"></a>2474         # We can't use alias_method here, because method 'id' optimizes itself on the fly.
</span><span class="uncovered0"><a name="line2475"></a>2475         (id = self.id) ? id.to_s : nil # Be sure to stringify the id for routes
</span><span class="uncovered1"><a name="line2476"></a>2476       end
</span><span class="inferred0"><a name="line2477"></a>2477 
</span><span class="inferred1"><a name="line2478"></a>2478       # Returns a cache key that can be used to identify this record.
</span><span class="inferred0"><a name="line2479"></a>2479       #
</span><span class="inferred1"><a name="line2480"></a>2480       # ==== Examples
</span><span class="inferred0"><a name="line2481"></a>2481       #
</span><span class="inferred1"><a name="line2482"></a>2482       #   Product.new.cache_key     # =&gt; &quot;products/new&quot;
</span><span class="inferred0"><a name="line2483"></a>2483       #   Product.find(5).cache_key # =&gt; &quot;products/5&quot; (updated_at not available)
</span><span class="inferred1"><a name="line2484"></a>2484       #   Person.find(5).cache_key  # =&gt; &quot;people/5-20071224150000&quot; (updated_at available)
</span><span class="marked0"><a name="line2485"></a>2485       def cache_key
</span><span class="uncovered1"><a name="line2486"></a>2486         case
</span><span class="uncovered0"><a name="line2487"></a>2487         when new_record?
</span><span class="uncovered1"><a name="line2488"></a>2488           &quot;#{self.class.model_name.cache_key}/new&quot;
</span><span class="uncovered0"><a name="line2489"></a>2489         when timestamp = self[:updated_at]
</span><span class="uncovered1"><a name="line2490"></a>2490           &quot;#{self.class.model_name.cache_key}/#{id}-#{timestamp.to_s(:number)}&quot;
</span><span class="uncovered0"><a name="line2491"></a>2491         else
</span><span class="uncovered1"><a name="line2492"></a>2492           &quot;#{self.class.model_name.cache_key}/#{id}&quot;
</span><span class="uncovered0"><a name="line2493"></a>2493         end
</span><span class="uncovered1"><a name="line2494"></a>2494       end
</span><span class="inferred0"><a name="line2495"></a>2495 
</span><span class="marked1"><a name="line2496"></a>2496       def id_before_type_cast #:nodoc:
</span><span class="uncovered0"><a name="line2497"></a>2497         read_attribute_before_type_cast(self.class.primary_key)
</span><span class="uncovered1"><a name="line2498"></a>2498       end
</span><span class="inferred0"><a name="line2499"></a>2499 
</span><span class="marked1"><a name="line2500"></a>2500       def quoted_id #:nodoc:
</span><span class="uncovered0"><a name="line2501"></a>2501         quote_value(id, column_for_attribute(self.class.primary_key))
</span><span class="uncovered1"><a name="line2502"></a>2502       end
</span><span class="inferred0"><a name="line2503"></a>2503 
</span><span class="inferred1"><a name="line2504"></a>2504       # Sets the primary ID.
</span><span class="marked0"><a name="line2505"></a>2505       def id=(value)
</span><span class="uncovered1"><a name="line2506"></a>2506         write_attribute(self.class.primary_key, value)
</span><span class="uncovered0"><a name="line2507"></a>2507       end
</span><span class="inferred1"><a name="line2508"></a>2508 
</span><span class="inferred0"><a name="line2509"></a>2509       # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet; otherwise, returns false.
</span><span class="marked1"><a name="line2510"></a>2510       def new_record?
</span><span class="uncovered0"><a name="line2511"></a>2511         @new_record || false
</span><span class="uncovered1"><a name="line2512"></a>2512       end
</span><span class="inferred0"><a name="line2513"></a>2513 
</span><span class="inferred1"><a name="line2514"></a>2514       # :call-seq:
</span><span class="inferred0"><a name="line2515"></a>2515       #   save(perform_validation = true)
</span><span class="inferred1"><a name="line2516"></a>2516       #
</span><span class="inferred0"><a name="line2517"></a>2517       # Saves the model.
</span><span class="inferred1"><a name="line2518"></a>2518       #
</span><span class="inferred0"><a name="line2519"></a>2519       # If the model is new a record gets created in the database, otherwise
</span><span class="inferred1"><a name="line2520"></a>2520       # the existing record gets updated.
</span><span class="inferred0"><a name="line2521"></a>2521       #
</span><span class="inferred1"><a name="line2522"></a>2522       # If +perform_validation+ is true validations run. If any of them fail
</span><span class="inferred0"><a name="line2523"></a>2523       # the action is cancelled and +save+ returns +false+. If the flag is
</span><span class="inferred1"><a name="line2524"></a>2524       # false validations are bypassed altogether. See
</span><span class="inferred0"><a name="line2525"></a>2525       # ActiveRecord::Validations for more information. 
</span><span class="inferred1"><a name="line2526"></a>2526       #
</span><span class="inferred0"><a name="line2527"></a>2527       # There's a series of callbacks associated with +save+. If any of the
</span><span class="inferred1"><a name="line2528"></a>2528       # &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled and
</span><span class="inferred0"><a name="line2529"></a>2529       # +save+ returns +false+. See ActiveRecord::Callbacks for further
</span><span class="inferred1"><a name="line2530"></a>2530       # details. 
</span><span class="marked0"><a name="line2531"></a>2531       def save
</span><span class="uncovered1"><a name="line2532"></a>2532         create_or_update
</span><span class="uncovered0"><a name="line2533"></a>2533       end
</span><span class="inferred1"><a name="line2534"></a>2534 
</span><span class="inferred0"><a name="line2535"></a>2535       # Saves the model.
</span><span class="inferred1"><a name="line2536"></a>2536       #
</span><span class="inferred0"><a name="line2537"></a>2537       # If the model is new a record gets created in the database, otherwise
</span><span class="inferred1"><a name="line2538"></a>2538       # the existing record gets updated.
</span><span class="inferred0"><a name="line2539"></a>2539       #
</span><span class="inferred1"><a name="line2540"></a>2540       # With &lt;tt&gt;save!&lt;/tt&gt; validations always run. If any of them fail
</span><span class="inferred0"><a name="line2541"></a>2541       # ActiveRecord::RecordInvalid gets raised. See ActiveRecord::Validations
</span><span class="inferred1"><a name="line2542"></a>2542       # for more information. 
</span><span class="inferred0"><a name="line2543"></a>2543       #
</span><span class="inferred1"><a name="line2544"></a>2544       # There's a series of callbacks associated with &lt;tt&gt;save!&lt;/tt&gt;. If any of
</span><span class="inferred0"><a name="line2545"></a>2545       # the &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled
</span><span class="inferred1"><a name="line2546"></a>2546       # and &lt;tt&gt;save!&lt;/tt&gt; raises ActiveRecord::RecordNotSaved. See
</span><span class="inferred0"><a name="line2547"></a>2547       # ActiveRecord::Callbacks for further details. 
</span><span class="marked1"><a name="line2548"></a>2548       def save!
</span><span class="uncovered0"><a name="line2549"></a>2549         create_or_update || raise(RecordNotSaved)
</span><span class="uncovered1"><a name="line2550"></a>2550       end
</span><span class="inferred0"><a name="line2551"></a>2551 
</span><span class="inferred1"><a name="line2552"></a>2552       # Deletes the record in the database and freezes this instance to
</span><span class="inferred0"><a name="line2553"></a>2553       # reflect that no changes should be made (since they can't be
</span><span class="inferred1"><a name="line2554"></a>2554       # persisted). Returns the frozen instance.
</span><span class="inferred0"><a name="line2555"></a>2555       #
</span><span class="inferred1"><a name="line2556"></a>2556       # The row is simply removed with a SQL +DELETE+ statement on the
</span><span class="inferred0"><a name="line2557"></a>2557       # record's primary key, and no callbacks are executed.
</span><span class="inferred1"><a name="line2558"></a>2558       #
</span><span class="inferred0"><a name="line2559"></a>2559       # To enforce the object's +before_destroy+ and +after_destroy+
</span><span class="inferred1"><a name="line2560"></a>2560       # callbacks, Observer methods, or any &lt;tt&gt;:dependent&lt;/tt&gt; association
</span><span class="inferred0"><a name="line2561"></a>2561       # options, use &lt;tt&gt;#destroy&lt;/tt&gt;.
</span><span class="marked1"><a name="line2562"></a>2562       def delete
</span><span class="uncovered0"><a name="line2563"></a>2563         self.class.delete(id) unless new_record?
</span><span class="uncovered1"><a name="line2564"></a>2564         freeze
</span><span class="uncovered0"><a name="line2565"></a>2565       end
</span><span class="inferred1"><a name="line2566"></a>2566 
</span><span class="inferred0"><a name="line2567"></a>2567       # Deletes the record in the database and freezes this instance to reflect that no changes should
</span><span class="inferred1"><a name="line2568"></a>2568       # be made (since they can't be persisted).
</span><span class="marked0"><a name="line2569"></a>2569       def destroy
</span><span class="uncovered1"><a name="line2570"></a>2570         unless new_record?
</span><span class="uncovered0"><a name="line2571"></a>2571           connection.delete(
</span><span class="uncovered1"><a name="line2572"></a>2572             &quot;DELETE FROM #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered0"><a name="line2573"></a>2573             &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quoted_id}&quot;,
</span><span class="uncovered1"><a name="line2574"></a>2574             &quot;#{self.class.name} Destroy&quot;
</span><span class="uncovered0"><a name="line2575"></a>2575           )
</span><span class="uncovered1"><a name="line2576"></a>2576         end
</span><span class="uncovered0"><a name="line2577"></a>2577 
</span><span class="uncovered1"><a name="line2578"></a>2578         freeze
</span><span class="uncovered0"><a name="line2579"></a>2579       end
</span><span class="inferred1"><a name="line2580"></a>2580 
</span><span class="inferred0"><a name="line2581"></a>2581       # Returns a clone of the record that hasn't been assigned an id yet and
</span><span class="inferred1"><a name="line2582"></a>2582       # is treated as a new record.  Note that this is a &quot;shallow&quot; clone:
</span><span class="inferred0"><a name="line2583"></a>2583       # it copies the object's attributes only, not its associations.
</span><span class="inferred1"><a name="line2584"></a>2584       # The extent of a &quot;deep&quot; clone is application-specific and is therefore
</span><span class="inferred0"><a name="line2585"></a>2585       # left to the application to implement according to its need.
</span><span class="marked1"><a name="line2586"></a>2586       def clone
</span><span class="uncovered0"><a name="line2587"></a>2587         attrs = clone_attributes(:read_attribute_before_type_cast)
</span><span class="uncovered1"><a name="line2588"></a>2588         attrs.delete(self.class.primary_key)
</span><span class="uncovered0"><a name="line2589"></a>2589         record = self.class.new
</span><span class="uncovered1"><a name="line2590"></a>2590         record.send :instance_variable_set, '@attributes', attrs
</span><span class="uncovered0"><a name="line2591"></a>2591         record
</span><span class="uncovered1"><a name="line2592"></a>2592       end
</span><span class="inferred0"><a name="line2593"></a>2593 
</span><span class="inferred1"><a name="line2594"></a>2594       # Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to
</span><span class="inferred0"><a name="line2595"></a>2595       # single-table inheritance structures where you want a subclass to appear as the superclass. This can be used along with record
</span><span class="inferred1"><a name="line2596"></a>2596       # identification in Action Pack to allow, say, &lt;tt&gt;Client &lt; Company&lt;/tt&gt; to do something like render &lt;tt&gt;:partial =&gt; @client.becomes(Company)&lt;/tt&gt;
</span><span class="inferred0"><a name="line2597"></a>2597       # to render that instance using the companies/company partial instead of clients/client.
</span><span class="inferred1"><a name="line2598"></a>2598       #
</span><span class="inferred0"><a name="line2599"></a>2599       # Note: The new instance will share a link to the same attributes as the original class. So any change to the attributes in either
</span><span class="inferred1"><a name="line2600"></a>2600       # instance will affect the other.
</span><span class="marked0"><a name="line2601"></a>2601       def becomes(klass)
</span><span class="uncovered1"><a name="line2602"></a>2602         returning klass.new do |became|
</span><span class="uncovered0"><a name="line2603"></a>2603           became.instance_variable_set(&quot;@attributes&quot;, @attributes)
</span><span class="uncovered1"><a name="line2604"></a>2604           became.instance_variable_set(&quot;@attributes_cache&quot;, @attributes_cache)
</span><span class="uncovered0"><a name="line2605"></a>2605           became.instance_variable_set(&quot;@new_record&quot;, new_record?)
</span><span class="uncovered1"><a name="line2606"></a>2606         end
</span><span class="uncovered0"><a name="line2607"></a>2607       end
</span><span class="inferred1"><a name="line2608"></a>2608 
</span><span class="inferred0"><a name="line2609"></a>2609       # Updates a single attribute and saves the record without going through the normal validation procedure.
</span><span class="inferred1"><a name="line2610"></a>2610       # This is especially useful for boolean flags on existing records. The regular +update_attribute+ method
</span><span class="inferred0"><a name="line2611"></a>2611       # in Base is replaced with this when the validations module is mixed in, which it is by default.
</span><span class="marked1"><a name="line2612"></a>2612       def update_attribute(name, value)
</span><span class="uncovered0"><a name="line2613"></a>2613         send(name.to_s + '=', value)
</span><span class="uncovered1"><a name="line2614"></a>2614         save(false)
</span><span class="uncovered0"><a name="line2615"></a>2615       end
</span><span class="inferred1"><a name="line2616"></a>2616 
</span><span class="inferred0"><a name="line2617"></a>2617       # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will
</span><span class="inferred1"><a name="line2618"></a>2618       # fail and false will be returned.
</span><span class="marked0"><a name="line2619"></a>2619       def update_attributes(attributes)
</span><span class="uncovered1"><a name="line2620"></a>2620         self.attributes = attributes
</span><span class="uncovered0"><a name="line2621"></a>2621         save
</span><span class="uncovered1"><a name="line2622"></a>2622       end
</span><span class="inferred0"><a name="line2623"></a>2623 
</span><span class="inferred1"><a name="line2624"></a>2624       # Updates an object just like Base.update_attributes but calls save! instead of save so an exception is raised if the record is invalid.
</span><span class="marked0"><a name="line2625"></a>2625       def update_attributes!(attributes)
</span><span class="uncovered1"><a name="line2626"></a>2626         self.attributes = attributes
</span><span class="uncovered0"><a name="line2627"></a>2627         save!
</span><span class="uncovered1"><a name="line2628"></a>2628       end
</span><span class="inferred0"><a name="line2629"></a>2629 
</span><span class="inferred1"><a name="line2630"></a>2630       # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
</span><span class="inferred0"><a name="line2631"></a>2631       # The increment is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred1"><a name="line2632"></a>2632       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked0"><a name="line2633"></a>2633       def increment(attribute, by = 1)
</span><span class="uncovered1"><a name="line2634"></a>2634         self[attribute] ||= 0
</span><span class="uncovered0"><a name="line2635"></a>2635         self[attribute] += by
</span><span class="uncovered1"><a name="line2636"></a>2636         self
</span><span class="uncovered0"><a name="line2637"></a>2637       end
</span><span class="inferred1"><a name="line2638"></a>2638 
</span><span class="inferred0"><a name="line2639"></a>2639       # Wrapper around +increment+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2640"></a>2640       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2641"></a>2641       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2642"></a>2642       # record could be saved.
</span><span class="marked0"><a name="line2643"></a>2643       def increment!(attribute, by = 1)
</span><span class="uncovered1"><a name="line2644"></a>2644         increment(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2645"></a>2645       end
</span><span class="inferred1"><a name="line2646"></a>2646 
</span><span class="inferred0"><a name="line2647"></a>2647       # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
</span><span class="inferred1"><a name="line2648"></a>2648       # The decrement is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred0"><a name="line2649"></a>2649       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked1"><a name="line2650"></a>2650       def decrement(attribute, by = 1)
</span><span class="uncovered0"><a name="line2651"></a>2651         self[attribute] ||= 0
</span><span class="uncovered1"><a name="line2652"></a>2652         self[attribute] -= by
</span><span class="uncovered0"><a name="line2653"></a>2653         self
</span><span class="uncovered1"><a name="line2654"></a>2654       end
</span><span class="inferred0"><a name="line2655"></a>2655 
</span><span class="inferred1"><a name="line2656"></a>2656       # Wrapper around +decrement+ that saves the record. This method differs from
</span><span class="inferred0"><a name="line2657"></a>2657       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred1"><a name="line2658"></a>2658       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred0"><a name="line2659"></a>2659       # record could be saved.
</span><span class="marked1"><a name="line2660"></a>2660       def decrement!(attribute, by = 1)
</span><span class="uncovered0"><a name="line2661"></a>2661         decrement(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered1"><a name="line2662"></a>2662       end
</span><span class="inferred0"><a name="line2663"></a>2663 
</span><span class="inferred1"><a name="line2664"></a>2664       # Assigns to +attribute+ the boolean opposite of &lt;tt&gt;attribute?&lt;/tt&gt;. So
</span><span class="inferred0"><a name="line2665"></a>2665       # if the predicate returns +true+ the attribute will become +false+. This
</span><span class="inferred1"><a name="line2666"></a>2666       # method toggles directly the underlying value without calling any setter.
</span><span class="inferred0"><a name="line2667"></a>2667       # Returns +self+.
</span><span class="marked1"><a name="line2668"></a>2668       def toggle(attribute)
</span><span class="uncovered0"><a name="line2669"></a>2669         self[attribute] = !send(&quot;#{attribute}?&quot;)
</span><span class="uncovered1"><a name="line2670"></a>2670         self
</span><span class="uncovered0"><a name="line2671"></a>2671       end
</span><span class="inferred1"><a name="line2672"></a>2672 
</span><span class="inferred0"><a name="line2673"></a>2673       # Wrapper around +toggle+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2674"></a>2674       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2675"></a>2675       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2676"></a>2676       # record could be saved.
</span><span class="marked0"><a name="line2677"></a>2677       def toggle!(attribute)
</span><span class="uncovered1"><a name="line2678"></a>2678         toggle(attribute).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2679"></a>2679       end
</span><span class="inferred1"><a name="line2680"></a>2680 
</span><span class="inferred0"><a name="line2681"></a>2681       # Reloads the attributes of this object from the database.
</span><span class="inferred1"><a name="line2682"></a>2682       # The optional options argument is passed to find when reloading so you
</span><span class="inferred0"><a name="line2683"></a>2683       # may do e.g. record.reload(:lock =&gt; true) to reload the same record with
</span><span class="inferred1"><a name="line2684"></a>2684       # an exclusive row lock.
</span><span class="marked0"><a name="line2685"></a>2685       def reload(options = nil)
</span><span class="uncovered1"><a name="line2686"></a>2686         clear_aggregation_cache
</span><span class="uncovered0"><a name="line2687"></a>2687         clear_association_cache
</span><span class="uncovered1"><a name="line2688"></a>2688         @attributes.update(self.class.find(self.id, options).instance_variable_get('@attributes'))
</span><span class="uncovered0"><a name="line2689"></a>2689         @attributes_cache = {}
</span><span class="uncovered1"><a name="line2690"></a>2690         self
</span><span class="uncovered0"><a name="line2691"></a>2691       end
</span><span class="inferred1"><a name="line2692"></a>2692 
</span><span class="inferred0"><a name="line2693"></a>2693       # Returns the value of the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; after it has been typecast (for example,
</span><span class="inferred1"><a name="line2694"></a>2694       # &quot;2004-12-12&quot; in a data column is cast to a date object, like Date.new(2004, 12, 12)).
</span><span class="inferred0"><a name="line2695"></a>2695       # (Alias for the protected read_attribute method).
</span><span class="marked1"><a name="line2696"></a>2696       def [](attr_name)
</span><span class="uncovered0"><a name="line2697"></a>2697         read_attribute(attr_name)
</span><span class="uncovered1"><a name="line2698"></a>2698       end
</span><span class="inferred0"><a name="line2699"></a>2699 
</span><span class="inferred1"><a name="line2700"></a>2700       # Updates the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; with the specified +value+.
</span><span class="inferred0"><a name="line2701"></a>2701       # (Alias for the protected write_attribute method).
</span><span class="marked1"><a name="line2702"></a>2702       def []=(attr_name, value)
</span><span class="uncovered0"><a name="line2703"></a>2703         write_attribute(attr_name, value)
</span><span class="uncovered1"><a name="line2704"></a>2704       end
</span><span class="inferred0"><a name="line2705"></a>2705 
</span><span class="inferred1"><a name="line2706"></a>2706       # Allows you to set all the attributes at once by passing in a hash with keys
</span><span class="inferred0"><a name="line2707"></a>2707       # matching the attribute names (which again matches the column names).
</span><span class="inferred1"><a name="line2708"></a>2708       #
</span><span class="inferred0"><a name="line2709"></a>2709       # If +guard_protected_attributes+ is true (the default), then sensitive
</span><span class="inferred1"><a name="line2710"></a>2710       # attributes can be protected from this form of mass-assignment by using
</span><span class="inferred0"><a name="line2711"></a>2711       # the +attr_protected+ macro. Or you can alternatively specify which
</span><span class="inferred1"><a name="line2712"></a>2712       # attributes *can* be accessed with the +attr_accessible+ macro. Then all the
</span><span class="inferred0"><a name="line2713"></a>2713       # attributes not included in that won't be allowed to be mass-assigned.
</span><span class="inferred1"><a name="line2714"></a>2714       #
</span><span class="inferred0"><a name="line2715"></a>2715       #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2716"></a>2716       #     attr_protected :is_admin
</span><span class="inferred0"><a name="line2717"></a>2717       #   end
</span><span class="inferred1"><a name="line2718"></a>2718       #   
</span><span class="inferred0"><a name="line2719"></a>2719       #   user = User.new
</span><span class="inferred1"><a name="line2720"></a>2720       #   user.attributes = { :username =&gt; 'Phusion', :is_admin =&gt; true }
</span><span class="inferred0"><a name="line2721"></a>2721       #   user.username   # =&gt; &quot;Phusion&quot;
</span><span class="inferred1"><a name="line2722"></a>2722       #   user.is_admin?  # =&gt; false
</span><span class="inferred0"><a name="line2723"></a>2723       #   
</span><span class="inferred1"><a name="line2724"></a>2724       #   user.send(:attributes=, { :username =&gt; 'Phusion', :is_admin =&gt; true }, false)
</span><span class="inferred0"><a name="line2725"></a>2725       #   user.is_admin?  # =&gt; true
</span><span class="marked1"><a name="line2726"></a>2726       def attributes=(new_attributes, guard_protected_attributes = true)
</span><span class="uncovered0"><a name="line2727"></a>2727         return if new_attributes.nil?
</span><span class="uncovered1"><a name="line2728"></a>2728         attributes = new_attributes.dup
</span><span class="uncovered0"><a name="line2729"></a>2729         attributes.stringify_keys!
</span><span class="uncovered1"><a name="line2730"></a>2730 
</span><span class="uncovered0"><a name="line2731"></a>2731         multi_parameter_attributes = []
</span><span class="uncovered1"><a name="line2732"></a>2732         attributes = remove_attributes_protected_from_mass_assignment(attributes) if guard_protected_attributes
</span><span class="uncovered0"><a name="line2733"></a>2733 
</span><span class="uncovered1"><a name="line2734"></a>2734         attributes.each do |k, v|
</span><span class="uncovered0"><a name="line2735"></a>2735           if k.include?(&quot;(&quot;)
</span><span class="uncovered1"><a name="line2736"></a>2736             multi_parameter_attributes &lt;&lt; [ k, v ]
</span><span class="uncovered0"><a name="line2737"></a>2737           else
</span><span class="uncovered1"><a name="line2738"></a>2738             respond_to?(:&quot;#{k}=&quot;) ? send(:&quot;#{k}=&quot;, v) : raise(UnknownAttributeError, &quot;unknown attribute: #{k}&quot;)
</span><span class="uncovered0"><a name="line2739"></a>2739           end
</span><span class="uncovered1"><a name="line2740"></a>2740         end
</span><span class="uncovered0"><a name="line2741"></a>2741 
</span><span class="uncovered1"><a name="line2742"></a>2742         assign_multiparameter_attributes(multi_parameter_attributes)
</span><span class="uncovered0"><a name="line2743"></a>2743       end
</span><span class="inferred1"><a name="line2744"></a>2744 
</span><span class="inferred0"><a name="line2745"></a>2745 
</span><span class="inferred1"><a name="line2746"></a>2746       # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
</span><span class="marked0"><a name="line2747"></a>2747       def attributes
</span><span class="uncovered1"><a name="line2748"></a>2748         self.attribute_names.inject({}) do |attrs, name|
</span><span class="uncovered0"><a name="line2749"></a>2749           attrs[name] = read_attribute(name)
</span><span class="uncovered1"><a name="line2750"></a>2750           attrs
</span><span class="uncovered0"><a name="line2751"></a>2751         end
</span><span class="uncovered1"><a name="line2752"></a>2752       end
</span><span class="inferred0"><a name="line2753"></a>2753 
</span><span class="inferred1"><a name="line2754"></a>2754       # Returns a hash of attributes before typecasting and deserialization.
</span><span class="marked0"><a name="line2755"></a>2755       def attributes_before_type_cast
</span><span class="uncovered1"><a name="line2756"></a>2756         self.attribute_names.inject({}) do |attrs, name|
</span><span class="uncovered0"><a name="line2757"></a>2757           attrs[name] = read_attribute_before_type_cast(name)
</span><span class="uncovered1"><a name="line2758"></a>2758           attrs
</span><span class="uncovered0"><a name="line2759"></a>2759         end
</span><span class="uncovered1"><a name="line2760"></a>2760       end
</span><span class="inferred0"><a name="line2761"></a>2761 
</span><span class="inferred1"><a name="line2762"></a>2762       # Returns an &lt;tt&gt;#inspect&lt;/tt&gt;-like string for the value of the
</span><span class="inferred0"><a name="line2763"></a>2763       # attribute +attr_name+. String attributes are elided after 50
</span><span class="inferred1"><a name="line2764"></a>2764       # characters, and Date and Time attributes are returned in the
</span><span class="inferred0"><a name="line2765"></a>2765       # &lt;tt&gt;:db&lt;/tt&gt; format. Other attributes return the value of
</span><span class="inferred1"><a name="line2766"></a>2766       # &lt;tt&gt;#inspect&lt;/tt&gt; without modification.
</span><span class="inferred0"><a name="line2767"></a>2767       #
</span><span class="inferred1"><a name="line2768"></a>2768       #   person = Person.create!(:name =&gt; &quot;David Heinemeier Hansson &quot; * 3)
</span><span class="inferred0"><a name="line2769"></a>2769       #
</span><span class="inferred1"><a name="line2770"></a>2770       #   person.attribute_for_inspect(:name)
</span><span class="inferred0"><a name="line2771"></a>2771       #   # =&gt; '&quot;David Heinemeier Hansson David Heinemeier Hansson D...&quot;'
</span><span class="inferred1"><a name="line2772"></a>2772       #
</span><span class="inferred0"><a name="line2773"></a>2773       #   person.attribute_for_inspect(:created_at)
</span><span class="inferred1"><a name="line2774"></a>2774       #   # =&gt; '&quot;2009-01-12 04:48:57&quot;'
</span><span class="marked0"><a name="line2775"></a>2775       def attribute_for_inspect(attr_name)
</span><span class="uncovered1"><a name="line2776"></a>2776         value = read_attribute(attr_name)
</span><span class="uncovered0"><a name="line2777"></a>2777 
</span><span class="uncovered1"><a name="line2778"></a>2778         if value.is_a?(String) &amp;&amp; value.length &gt; 50
</span><span class="uncovered0"><a name="line2779"></a>2779           &quot;#{value[0..50]}...&quot;.inspect
</span><span class="uncovered1"><a name="line2780"></a>2780         elsif value.is_a?(Date) || value.is_a?(Time)
</span><span class="uncovered0"><a name="line2781"></a>2781           %(&quot;#{value.to_s(:db)}&quot;)
</span><span class="uncovered1"><a name="line2782"></a>2782         else
</span><span class="uncovered0"><a name="line2783"></a>2783           value.inspect
</span><span class="uncovered1"><a name="line2784"></a>2784         end
</span><span class="uncovered0"><a name="line2785"></a>2785       end
</span><span class="inferred1"><a name="line2786"></a>2786 
</span><span class="inferred0"><a name="line2787"></a>2787       # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither
</span><span class="inferred1"><a name="line2788"></a>2788       # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).
</span><span class="marked0"><a name="line2789"></a>2789       def attribute_present?(attribute)
</span><span class="uncovered1"><a name="line2790"></a>2790         value = read_attribute(attribute)
</span><span class="uncovered0"><a name="line2791"></a>2791         !value.blank?
</span><span class="uncovered1"><a name="line2792"></a>2792       end
</span><span class="inferred0"><a name="line2793"></a>2793 
</span><span class="inferred1"><a name="line2794"></a>2794       # Returns true if the given attribute is in the attributes hash
</span><span class="marked0"><a name="line2795"></a>2795       def has_attribute?(attr_name)
</span><span class="uncovered1"><a name="line2796"></a>2796         @attributes.has_key?(attr_name.to_s)
</span><span class="uncovered0"><a name="line2797"></a>2797       end
</span><span class="inferred1"><a name="line2798"></a>2798 
</span><span class="inferred0"><a name="line2799"></a>2799       # Returns an array of names for the attributes available on this object sorted alphabetically.
</span><span class="marked1"><a name="line2800"></a>2800       def attribute_names
</span><span class="uncovered0"><a name="line2801"></a>2801         @attributes.keys.sort
</span><span class="uncovered1"><a name="line2802"></a>2802       end
</span><span class="inferred0"><a name="line2803"></a>2803 
</span><span class="inferred1"><a name="line2804"></a>2804       # Returns the column object for the named attribute.
</span><span class="marked0"><a name="line2805"></a>2805       def column_for_attribute(name)
</span><span class="uncovered1"><a name="line2806"></a>2806         self.class.columns_hash[name.to_s]
</span><span class="uncovered0"><a name="line2807"></a>2807       end
</span><span class="inferred1"><a name="line2808"></a>2808 
</span><span class="inferred0"><a name="line2809"></a>2809       # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.
</span><span class="marked1"><a name="line2810"></a>2810       def ==(comparison_object)
</span><span class="uncovered0"><a name="line2811"></a>2811         comparison_object.equal?(self) ||
</span><span class="uncovered1"><a name="line2812"></a>2812           (comparison_object.instance_of?(self.class) &amp;&amp;
</span><span class="uncovered0"><a name="line2813"></a>2813             comparison_object.id == id &amp;&amp;
</span><span class="uncovered1"><a name="line2814"></a>2814             !comparison_object.new_record?)
</span><span class="uncovered0"><a name="line2815"></a>2815       end
</span><span class="inferred1"><a name="line2816"></a>2816 
</span><span class="inferred0"><a name="line2817"></a>2817       # Delegates to ==
</span><span class="marked1"><a name="line2818"></a>2818       def eql?(comparison_object)
</span><span class="uncovered0"><a name="line2819"></a>2819         self == (comparison_object)
</span><span class="uncovered1"><a name="line2820"></a>2820       end
</span><span class="inferred0"><a name="line2821"></a>2821 
</span><span class="inferred1"><a name="line2822"></a>2822       # Delegates to id in order to allow two records of the same type and id to work with something like:
</span><span class="inferred0"><a name="line2823"></a>2823       #   [ Person.find(1), Person.find(2), Person.find(3) ] &amp; [ Person.find(1), Person.find(4) ] # =&gt; [ Person.find(1) ]
</span><span class="marked1"><a name="line2824"></a>2824       def hash
</span><span class="uncovered0"><a name="line2825"></a>2825         id.hash
</span><span class="uncovered1"><a name="line2826"></a>2826       end
</span><span class="inferred0"><a name="line2827"></a>2827 
</span><span class="inferred1"><a name="line2828"></a>2828       # Freeze the attributes hash such that associations are still accessible, even on destroyed records.
</span><span class="marked0"><a name="line2829"></a>2829       def freeze
</span><span class="uncovered1"><a name="line2830"></a>2830         @attributes.freeze; self
</span><span class="uncovered0"><a name="line2831"></a>2831       end
</span><span class="inferred1"><a name="line2832"></a>2832 
</span><span class="inferred0"><a name="line2833"></a>2833       # Returns +true+ if the attributes hash has been frozen.
</span><span class="marked1"><a name="line2834"></a>2834       def frozen?
</span><span class="uncovered0"><a name="line2835"></a>2835         @attributes.frozen?
</span><span class="uncovered1"><a name="line2836"></a>2836       end
</span><span class="inferred0"><a name="line2837"></a>2837 
</span><span class="inferred1"><a name="line2838"></a>2838       # Returns +true+ if the record is read only. Records loaded through joins with piggy-back
</span><span class="inferred0"><a name="line2839"></a>2839       # attributes will be marked as read only since they cannot be saved.
</span><span class="marked1"><a name="line2840"></a>2840       def readonly?
</span><span class="uncovered0"><a name="line2841"></a>2841         defined?(@readonly) &amp;&amp; @readonly == true
</span><span class="uncovered1"><a name="line2842"></a>2842       end
</span><span class="inferred0"><a name="line2843"></a>2843 
</span><span class="inferred1"><a name="line2844"></a>2844       # Marks this record as read only.
</span><span class="marked0"><a name="line2845"></a>2845       def readonly!
</span><span class="uncovered1"><a name="line2846"></a>2846         @readonly = true
</span><span class="uncovered0"><a name="line2847"></a>2847       end
</span><span class="inferred1"><a name="line2848"></a>2848 
</span><span class="inferred0"><a name="line2849"></a>2849       # Returns the contents of the record as a nicely formatted string.
</span><span class="marked1"><a name="line2850"></a>2850       def inspect
</span><span class="uncovered0"><a name="line2851"></a>2851         attributes_as_nice_string = self.class.column_names.collect { |name|
</span><span class="uncovered1"><a name="line2852"></a>2852           if has_attribute?(name) || new_record?
</span><span class="uncovered0"><a name="line2853"></a>2853             &quot;#{name}: #{attribute_for_inspect(name)}&quot;
</span><span class="uncovered1"><a name="line2854"></a>2854           end
</span><span class="uncovered0"><a name="line2855"></a>2855         }.compact.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line2856"></a>2856         &quot;#&lt;#{self.class} #{attributes_as_nice_string}&gt;&quot;
</span><span class="uncovered0"><a name="line2857"></a>2857       end
</span><span class="inferred1"><a name="line2858"></a>2858 
</span><span class="marked0"><a name="line2859"></a>2859     private
</span><span class="marked1"><a name="line2860"></a>2860       def create_or_update
</span><span class="uncovered0"><a name="line2861"></a>2861         raise ReadOnlyRecord if readonly?
</span><span class="uncovered1"><a name="line2862"></a>2862         result = new_record? ? create : update
</span><span class="uncovered0"><a name="line2863"></a>2863         result != false
</span><span class="uncovered1"><a name="line2864"></a>2864       end
</span><span class="inferred0"><a name="line2865"></a>2865 
</span><span class="inferred1"><a name="line2866"></a>2866       # Updates the associated record with values matching those of the instance attributes.
</span><span class="inferred0"><a name="line2867"></a>2867       # Returns the number of affected rows.
</span><span class="marked1"><a name="line2868"></a>2868       def update(attribute_names = @attributes.keys)
</span><span class="uncovered0"><a name="line2869"></a>2869         quoted_attributes = attributes_with_quotes(false, false, attribute_names)
</span><span class="uncovered1"><a name="line2870"></a>2870         return 0 if quoted_attributes.empty?
</span><span class="uncovered0"><a name="line2871"></a>2871         connection.update(
</span><span class="uncovered1"><a name="line2872"></a>2872           &quot;UPDATE #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered0"><a name="line2873"></a>2873           &quot;SET #{quoted_comma_pair_list(connection, quoted_attributes)} &quot; +
</span><span class="uncovered1"><a name="line2874"></a>2874           &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quote_value(id)}&quot;,
</span><span class="uncovered0"><a name="line2875"></a>2875           &quot;#{self.class.name} Update&quot;
</span><span class="uncovered1"><a name="line2876"></a>2876         )
</span><span class="uncovered0"><a name="line2877"></a>2877       end
</span><span class="inferred1"><a name="line2878"></a>2878 
</span><span class="inferred0"><a name="line2879"></a>2879       # Creates a record with values matching those of the instance attributes
</span><span class="inferred1"><a name="line2880"></a>2880       # and returns its id.
</span><span class="marked0"><a name="line2881"></a>2881       def create
</span><span class="uncovered1"><a name="line2882"></a>2882         if self.id.nil? &amp;&amp; connection.prefetch_primary_key?(self.class.table_name)
</span><span class="uncovered0"><a name="line2883"></a>2883           self.id = connection.next_sequence_value(self.class.sequence_name)
</span><span class="uncovered1"><a name="line2884"></a>2884         end
</span><span class="uncovered0"><a name="line2885"></a>2885 
</span><span class="uncovered1"><a name="line2886"></a>2886         quoted_attributes = attributes_with_quotes
</span><span class="uncovered0"><a name="line2887"></a>2887 
</span><span class="uncovered1"><a name="line2888"></a>2888         statement = if quoted_attributes.empty?
</span><span class="uncovered0"><a name="line2889"></a>2889           connection.empty_insert_statement(self.class.table_name)
</span><span class="uncovered1"><a name="line2890"></a>2890         else
</span><span class="uncovered0"><a name="line2891"></a>2891           &quot;INSERT INTO #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered1"><a name="line2892"></a>2892           &quot;(#{quoted_column_names.join(', ')}) &quot; +
</span><span class="uncovered0"><a name="line2893"></a>2893           &quot;VALUES(#{quoted_attributes.values.join(', ')})&quot;
</span><span class="uncovered1"><a name="line2894"></a>2894         end
</span><span class="uncovered0"><a name="line2895"></a>2895 
</span><span class="uncovered1"><a name="line2896"></a>2896         self.id = connection.insert(statement, &quot;#{self.class.name} Create&quot;,
</span><span class="uncovered0"><a name="line2897"></a>2897           self.class.primary_key, self.id, self.class.sequence_name)
</span><span class="uncovered1"><a name="line2898"></a>2898 
</span><span class="uncovered0"><a name="line2899"></a>2899         @new_record = false
</span><span class="uncovered1"><a name="line2900"></a>2900         id
</span><span class="uncovered0"><a name="line2901"></a>2901       end
</span><span class="inferred1"><a name="line2902"></a>2902 
</span><span class="inferred0"><a name="line2903"></a>2903       # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendant.
</span><span class="inferred1"><a name="line2904"></a>2904       # Considering the hierarchy Reply &lt; Message &lt; ActiveRecord::Base, this makes it possible to do Reply.new without having to
</span><span class="inferred0"><a name="line2905"></a>2905       # set &lt;tt&gt;Reply[Reply.inheritance_column] = &quot;Reply&quot;&lt;/tt&gt; yourself. No such attribute would be set for objects of the
</span><span class="inferred1"><a name="line2906"></a>2906       # Message class in that example.
</span><span class="marked0"><a name="line2907"></a>2907       def ensure_proper_type
</span><span class="uncovered1"><a name="line2908"></a>2908         unless self.class.descends_from_active_record?
</span><span class="uncovered0"><a name="line2909"></a>2909           write_attribute(self.class.inheritance_column, self.class.sti_name)
</span><span class="uncovered1"><a name="line2910"></a>2910         end
</span><span class="uncovered0"><a name="line2911"></a>2911       end
</span><span class="inferred1"><a name="line2912"></a>2912 
</span><span class="marked0"><a name="line2913"></a>2913       def convert_number_column_value(value)
</span><span class="uncovered1"><a name="line2914"></a>2914         if value == false
</span><span class="uncovered0"><a name="line2915"></a>2915           0
</span><span class="uncovered1"><a name="line2916"></a>2916         elsif value == true
</span><span class="uncovered0"><a name="line2917"></a>2917           1
</span><span class="uncovered1"><a name="line2918"></a>2918         elsif value.is_a?(String) &amp;&amp; value.blank?
</span><span class="uncovered0"><a name="line2919"></a>2919           nil
</span><span class="uncovered1"><a name="line2920"></a>2920         else
</span><span class="uncovered0"><a name="line2921"></a>2921           value
</span><span class="uncovered1"><a name="line2922"></a>2922         end
</span><span class="uncovered0"><a name="line2923"></a>2923       end
</span><span class="inferred1"><a name="line2924"></a>2924 
</span><span class="marked0"><a name="line2925"></a>2925       def remove_attributes_protected_from_mass_assignment(attributes)
</span><span class="uncovered1"><a name="line2926"></a>2926         safe_attributes =
</span><span class="uncovered0"><a name="line2927"></a>2927           if self.class.accessible_attributes.nil? &amp;&amp; self.class.protected_attributes.nil?
</span><span class="uncovered1"><a name="line2928"></a>2928             attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2929"></a>2929           elsif self.class.protected_attributes.nil?
</span><span class="uncovered1"><a name="line2930"></a>2930             attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, &quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2931"></a>2931           elsif self.class.accessible_attributes.nil?
</span><span class="uncovered1"><a name="line2932"></a>2932             attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2933"></a>2933           else
</span><span class="uncovered1"><a name="line2934"></a>2934             raise &quot;Declare either attr_protected or attr_accessible for #{self.class}, but not both.&quot;
</span><span class="uncovered0"><a name="line2935"></a>2935           end
</span><span class="uncovered1"><a name="line2936"></a>2936 
</span><span class="uncovered0"><a name="line2937"></a>2937         removed_attributes = attributes.keys - safe_attributes.keys
</span><span class="uncovered1"><a name="line2938"></a>2938 
</span><span class="uncovered0"><a name="line2939"></a>2939         if removed_attributes.any?
</span><span class="uncovered1"><a name="line2940"></a>2940           log_protected_attribute_removal(removed_attributes)
</span><span class="uncovered0"><a name="line2941"></a>2941         end
</span><span class="uncovered1"><a name="line2942"></a>2942 
</span><span class="uncovered0"><a name="line2943"></a>2943         safe_attributes
</span><span class="uncovered1"><a name="line2944"></a>2944       end
</span><span class="inferred0"><a name="line2945"></a>2945 
</span><span class="inferred1"><a name="line2946"></a>2946       # Removes attributes which have been marked as readonly.
</span><span class="marked0"><a name="line2947"></a>2947       def remove_readonly_attributes(attributes)
</span><span class="uncovered1"><a name="line2948"></a>2948         unless self.class.readonly_attributes.nil?
</span><span class="uncovered0"><a name="line2949"></a>2949           attributes.delete_if { |key, value| self.class.readonly_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) }
</span><span class="uncovered1"><a name="line2950"></a>2950         else
</span><span class="uncovered0"><a name="line2951"></a>2951           attributes
</span><span class="uncovered1"><a name="line2952"></a>2952         end
</span><span class="uncovered0"><a name="line2953"></a>2953       end
</span><span class="inferred1"><a name="line2954"></a>2954 
</span><span class="marked0"><a name="line2955"></a>2955       def log_protected_attribute_removal(*attributes)
</span><span class="uncovered1"><a name="line2956"></a>2956         logger.debug &quot;WARNING: Can't mass-assign these protected attributes: #{attributes.join(', ')}&quot;
</span><span class="uncovered0"><a name="line2957"></a>2957       end
</span><span class="inferred1"><a name="line2958"></a>2958 
</span><span class="inferred0"><a name="line2959"></a>2959       # The primary key and inheritance column can never be set by mass-assignment for security reasons.
</span><span class="marked1"><a name="line2960"></a>2960       def attributes_protected_by_default
</span><span class="uncovered0"><a name="line2961"></a>2961         default = [ self.class.primary_key, self.class.inheritance_column ]
</span><span class="uncovered1"><a name="line2962"></a>2962         default &lt;&lt; 'id' unless self.class.primary_key.eql? 'id'
</span><span class="uncovered0"><a name="line2963"></a>2963         default
</span><span class="uncovered1"><a name="line2964"></a>2964       end
</span><span class="inferred0"><a name="line2965"></a>2965 
</span><span class="inferred1"><a name="line2966"></a>2966       # Returns a copy of the attributes hash where all the values have been safely quoted for use in
</span><span class="inferred0"><a name="line2967"></a>2967       # an SQL statement.
</span><span class="marked1"><a name="line2968"></a>2968       def attributes_with_quotes(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)
</span><span class="uncovered0"><a name="line2969"></a>2969         quoted = {}
</span><span class="uncovered1"><a name="line2970"></a>2970         connection = self.class.connection
</span><span class="uncovered0"><a name="line2971"></a>2971         attribute_names.each do |name|
</span><span class="uncovered1"><a name="line2972"></a>2972           if (column = column_for_attribute(name)) &amp;&amp; (include_primary_key || !column.primary)
</span><span class="uncovered0"><a name="line2973"></a>2973             value = read_attribute(name)
</span><span class="uncovered1"><a name="line2974"></a>2974 
</span><span class="uncovered0"><a name="line2975"></a>2975             # We need explicit to_yaml because quote() does not properly convert Time/Date fields to YAML.
</span><span class="uncovered1"><a name="line2976"></a>2976             if value &amp;&amp; self.class.serialized_attributes.has_key?(name) &amp;&amp; (value.acts_like?(:date) || value.acts_like?(:time))
</span><span class="uncovered0"><a name="line2977"></a>2977               value = value.to_yaml
</span><span class="uncovered1"><a name="line2978"></a>2978             end
</span><span class="uncovered0"><a name="line2979"></a>2979 
</span><span class="uncovered1"><a name="line2980"></a>2980             quoted[name] = connection.quote(value, column)
</span><span class="uncovered0"><a name="line2981"></a>2981           end
</span><span class="uncovered1"><a name="line2982"></a>2982         end
</span><span class="uncovered0"><a name="line2983"></a>2983         include_readonly_attributes ? quoted : remove_readonly_attributes(quoted)
</span><span class="uncovered1"><a name="line2984"></a>2984       end
</span><span class="inferred0"><a name="line2985"></a>2985 
</span><span class="inferred1"><a name="line2986"></a>2986       # Quote strings appropriately for SQL statements.
</span><span class="marked0"><a name="line2987"></a>2987       def quote_value(value, column = nil)
</span><span class="uncovered1"><a name="line2988"></a>2988         self.class.connection.quote(value, column)
</span><span class="uncovered0"><a name="line2989"></a>2989       end
</span><span class="inferred1"><a name="line2990"></a>2990 
</span><span class="inferred0"><a name="line2991"></a>2991       # Interpolate custom SQL string in instance context.
</span><span class="inferred1"><a name="line2992"></a>2992       # Optional record argument is meant for custom insert_sql.
</span><span class="marked0"><a name="line2993"></a>2993       def interpolate_sql(sql, record = nil)
</span><span class="uncovered1"><a name="line2994"></a>2994         instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line2995"></a>2995       end
</span><span class="inferred1"><a name="line2996"></a>2996 
</span><span class="inferred0"><a name="line2997"></a>2997       # Initializes the attributes array with keys matching the columns from the linked table and
</span><span class="inferred1"><a name="line2998"></a>2998       # the values matching the corresponding default value of that column, so
</span><span class="inferred0"><a name="line2999"></a>2999       # that a new instance, or one populated from a passed-in Hash, still has all the attributes
</span><span class="inferred1"><a name="line3000"></a>3000       # that instances loaded from the database would.
</span><span class="marked0"><a name="line3001"></a>3001       def attributes_from_column_definition
</span><span class="uncovered1"><a name="line3002"></a>3002         self.class.columns.inject({}) do |attributes, column|
</span><span class="uncovered0"><a name="line3003"></a>3003           attributes[column.name] = column.default unless column.name == self.class.primary_key
</span><span class="uncovered1"><a name="line3004"></a>3004           attributes
</span><span class="uncovered0"><a name="line3005"></a>3005         end
</span><span class="uncovered1"><a name="line3006"></a>3006       end
</span><span class="inferred0"><a name="line3007"></a>3007 
</span><span class="inferred1"><a name="line3008"></a>3008       # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
</span><span class="inferred0"><a name="line3009"></a>3009       # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
</span><span class="inferred1"><a name="line3010"></a>3010       # So having the pairs written_on(1) = &quot;2004&quot;, written_on(2) = &quot;6&quot;, written_on(3) = &quot;24&quot;, will instantiate
</span><span class="inferred0"><a name="line3011"></a>3011       # written_on (a date type) with Date.new(&quot;2004&quot;, &quot;6&quot;, &quot;24&quot;). You can also specify a typecast character in the
</span><span class="inferred1"><a name="line3012"></a>3012       # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,
</span><span class="inferred0"><a name="line3013"></a>3013       # s for String, and a for Array. If all the values for a given attribute are empty, the attribute will be set to nil.
</span><span class="marked1"><a name="line3014"></a>3014       def assign_multiparameter_attributes(pairs)
</span><span class="uncovered0"><a name="line3015"></a>3015         execute_callstack_for_multiparameter_attributes(
</span><span class="uncovered1"><a name="line3016"></a>3016           extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="uncovered0"><a name="line3017"></a>3017         )
</span><span class="uncovered1"><a name="line3018"></a>3018       end
</span><span class="inferred0"><a name="line3019"></a>3019 
</span><span class="marked1"><a name="line3020"></a>3020       def instantiate_time_object(name, values)
</span><span class="uncovered0"><a name="line3021"></a>3021         if self.class.send(:create_time_zone_conversion_attribute?, name, column_for_attribute(name))
</span><span class="uncovered1"><a name="line3022"></a>3022           Time.zone.local(*values)
</span><span class="uncovered0"><a name="line3023"></a>3023         else
</span><span class="uncovered1"><a name="line3024"></a>3024           Time.time_with_datetime_fallback(@@default_timezone, *values)
</span><span class="uncovered0"><a name="line3025"></a>3025         end
</span><span class="uncovered1"><a name="line3026"></a>3026       end
</span><span class="inferred0"><a name="line3027"></a>3027 
</span><span class="marked1"><a name="line3028"></a>3028       def execute_callstack_for_multiparameter_attributes(callstack)
</span><span class="uncovered0"><a name="line3029"></a>3029         errors = []
</span><span class="uncovered1"><a name="line3030"></a>3030         callstack.each do |name, values|
</span><span class="uncovered0"><a name="line3031"></a>3031           klass = (self.class.reflect_on_aggregation(name.to_sym) || column_for_attribute(name)).klass
</span><span class="uncovered1"><a name="line3032"></a>3032           if values.empty?
</span><span class="uncovered0"><a name="line3033"></a>3033             send(name + &quot;=&quot;, nil)
</span><span class="uncovered1"><a name="line3034"></a>3034           else
</span><span class="uncovered0"><a name="line3035"></a>3035             begin
</span><span class="uncovered1"><a name="line3036"></a>3036               value = if Time == klass
</span><span class="uncovered0"><a name="line3037"></a>3037                 instantiate_time_object(name, values)
</span><span class="uncovered1"><a name="line3038"></a>3038               elsif Date == klass
</span><span class="uncovered0"><a name="line3039"></a>3039                 begin
</span><span class="uncovered1"><a name="line3040"></a>3040                   Date.new(*values)
</span><span class="uncovered0"><a name="line3041"></a>3041                 rescue ArgumentError =&gt; ex # if Date.new raises an exception on an invalid date
</span><span class="uncovered1"><a name="line3042"></a>3042                   instantiate_time_object(name, values).to_date # we instantiate Time object and convert it back to a date thus using Time's logic in handling invalid dates
</span><span class="uncovered0"><a name="line3043"></a>3043                 end
</span><span class="uncovered1"><a name="line3044"></a>3044               else
</span><span class="uncovered0"><a name="line3045"></a>3045                 klass.new(*values)
</span><span class="uncovered1"><a name="line3046"></a>3046               end
</span><span class="uncovered0"><a name="line3047"></a>3047 
</span><span class="uncovered1"><a name="line3048"></a>3048               send(name + &quot;=&quot;, value)
</span><span class="uncovered0"><a name="line3049"></a>3049             rescue =&gt; ex
</span><span class="uncovered1"><a name="line3050"></a>3050               errors &lt;&lt; AttributeAssignmentError.new(&quot;error on assignment #{values.inspect} to #{name}&quot;, ex, name)
</span><span class="uncovered0"><a name="line3051"></a>3051             end
</span><span class="uncovered1"><a name="line3052"></a>3052           end
</span><span class="uncovered0"><a name="line3053"></a>3053         end
</span><span class="uncovered1"><a name="line3054"></a>3054         unless errors.empty?
</span><span class="uncovered0"><a name="line3055"></a>3055           raise MultiparameterAssignmentErrors.new(errors), &quot;#{errors.size} error(s) on assignment of multiparameter attributes&quot;
</span><span class="uncovered1"><a name="line3056"></a>3056         end
</span><span class="uncovered0"><a name="line3057"></a>3057       end
</span><span class="inferred1"><a name="line3058"></a>3058 
</span><span class="marked0"><a name="line3059"></a>3059       def extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="uncovered1"><a name="line3060"></a>3060         attributes = { }
</span><span class="uncovered0"><a name="line3061"></a>3061 
</span><span class="uncovered1"><a name="line3062"></a>3062         for pair in pairs
</span><span class="uncovered0"><a name="line3063"></a>3063           multiparameter_name, value = pair
</span><span class="uncovered1"><a name="line3064"></a>3064           attribute_name = multiparameter_name.split(&quot;(&quot;).first
</span><span class="uncovered0"><a name="line3065"></a>3065           attributes[attribute_name] = [] unless attributes.include?(attribute_name)
</span><span class="uncovered1"><a name="line3066"></a>3066 
</span><span class="uncovered0"><a name="line3067"></a>3067           unless value.empty?
</span><span class="uncovered1"><a name="line3068"></a>3068             attributes[attribute_name] &lt;&lt;
</span><span class="uncovered0"><a name="line3069"></a>3069               [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]
</span><span class="uncovered1"><a name="line3070"></a>3070           end
</span><span class="uncovered0"><a name="line3071"></a>3071         end
</span><span class="uncovered1"><a name="line3072"></a>3072 
</span><span class="uncovered0"><a name="line3073"></a>3073         attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }
</span><span class="uncovered1"><a name="line3074"></a>3074       end
</span><span class="inferred0"><a name="line3075"></a>3075 
</span><span class="marked1"><a name="line3076"></a>3076       def type_cast_attribute_value(multiparameter_name, value)
</span><span class="uncovered0"><a name="line3077"></a>3077         multiparameter_name =~ /\([0-9]*([a-z])\)/ ? value.send(&quot;to_&quot; + $1) : value
</span><span class="uncovered1"><a name="line3078"></a>3078       end
</span><span class="inferred0"><a name="line3079"></a>3079 
</span><span class="marked1"><a name="line3080"></a>3080       def find_parameter_position(multiparameter_name)
</span><span class="uncovered0"><a name="line3081"></a>3081         multiparameter_name.scan(/\(([0-9]*).*\)/).first.first
</span><span class="uncovered1"><a name="line3082"></a>3082       end
</span><span class="inferred0"><a name="line3083"></a>3083 
</span><span class="inferred1"><a name="line3084"></a>3084       # Returns a comma-separated pair list, like &quot;key1 = val1, key2 = val2&quot;.
</span><span class="marked0"><a name="line3085"></a>3085       def comma_pair_list(hash)
</span><span class="uncovered1"><a name="line3086"></a>3086         hash.inject([]) { |list, pair| list &lt;&lt; &quot;#{pair.first} = #{pair.last}&quot; }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line3087"></a>3087       end
</span><span class="inferred1"><a name="line3088"></a>3088 
</span><span class="marked0"><a name="line3089"></a>3089       def quoted_column_names(attributes = attributes_with_quotes)
</span><span class="uncovered1"><a name="line3090"></a>3090         connection = self.class.connection
</span><span class="uncovered0"><a name="line3091"></a>3091         attributes.keys.collect do |column_name|
</span><span class="uncovered1"><a name="line3092"></a>3092           connection.quote_column_name(column_name)
</span><span class="uncovered0"><a name="line3093"></a>3093         end
</span><span class="uncovered1"><a name="line3094"></a>3094       end
</span><span class="inferred0"><a name="line3095"></a>3095 
</span><span class="marked1"><a name="line3096"></a>3096       def self.quoted_table_name
</span><span class="uncovered0"><a name="line3097"></a>3097         self.connection.quote_table_name(self.table_name)
</span><span class="uncovered1"><a name="line3098"></a>3098       end
</span><span class="inferred0"><a name="line3099"></a>3099 
</span><span class="marked1"><a name="line3100"></a>3100       def quote_columns(quoter, hash)
</span><span class="uncovered0"><a name="line3101"></a>3101         hash.inject({}) do |quoted, (name, value)|
</span><span class="uncovered1"><a name="line3102"></a>3102           quoted[quoter.quote_column_name(name)] = value
</span><span class="uncovered0"><a name="line3103"></a>3103           quoted
</span><span class="uncovered1"><a name="line3104"></a>3104         end
</span><span class="uncovered0"><a name="line3105"></a>3105       end
</span><span class="inferred1"><a name="line3106"></a>3106 
</span><span class="marked0"><a name="line3107"></a>3107       def quoted_comma_pair_list(quoter, hash)
</span><span class="uncovered1"><a name="line3108"></a>3108         comma_pair_list(quote_columns(quoter, hash))
</span><span class="uncovered0"><a name="line3109"></a>3109       end
</span><span class="inferred1"><a name="line3110"></a>3110 
</span><span class="marked0"><a name="line3111"></a>3111       def object_from_yaml(string)
</span><span class="uncovered1"><a name="line3112"></a>3112         return string unless string.is_a?(String) &amp;&amp; string =~ /^---/
</span><span class="uncovered0"><a name="line3113"></a>3113         YAML::load(string) rescue string
</span><span class="uncovered1"><a name="line3114"></a>3114       end
</span><span class="inferred0"><a name="line3115"></a>3115 
</span><span class="marked1"><a name="line3116"></a>3116       def clone_attributes(reader_method = :read_attribute, attributes = {})
</span><span class="uncovered0"><a name="line3117"></a>3117         self.attribute_names.inject(attributes) do |attrs, name|
</span><span class="uncovered1"><a name="line3118"></a>3118           attrs[name] = clone_attribute_value(reader_method, name)
</span><span class="uncovered0"><a name="line3119"></a>3119           attrs
</span><span class="uncovered1"><a name="line3120"></a>3120         end
</span><span class="uncovered0"><a name="line3121"></a>3121       end
</span><span class="inferred1"><a name="line3122"></a>3122 
</span><span class="marked0"><a name="line3123"></a>3123       def clone_attribute_value(reader_method, attribute_name)
</span><span class="uncovered1"><a name="line3124"></a>3124         value = send(reader_method, attribute_name)
</span><span class="uncovered0"><a name="line3125"></a>3125         value.duplicable? ? value.clone : value
</span><span class="uncovered1"><a name="line3126"></a>3126       rescue TypeError, NoMethodError
</span><span class="uncovered0"><a name="line3127"></a>3127         value
</span><span class="uncovered1"><a name="line3128"></a>3128       end
</span><span class="uncovered0"><a name="line3129"></a>3129   end
</span><span class="inferred1"><a name="line3130"></a>3130 
</span><span class="marked0"><a name="line3131"></a>3131   Base.class_eval do
</span><span class="marked1"><a name="line3132"></a>3132     extend QueryCache::ClassMethods
</span><span class="marked0"><a name="line3133"></a>3133     include Validations
</span><span class="marked1"><a name="line3134"></a>3134     include Locking::Optimistic, Locking::Pessimistic
</span><span class="marked0"><a name="line3135"></a>3135     include AttributeMethods
</span><span class="marked1"><a name="line3136"></a>3136     include Dirty
</span><span class="marked0"><a name="line3137"></a>3137     include Callbacks, Observing, Timestamp
</span><span class="marked1"><a name="line3138"></a>3138     include Associations, AssociationPreload, NamedScope
</span><span class="inferred0"><a name="line3139"></a>3139 
</span><span class="inferred1"><a name="line3140"></a>3140     # AutosaveAssociation needs to be included before Transactions, because we want
</span><span class="inferred0"><a name="line3141"></a>3141     # #save_with_autosave_associations to be wrapped inside a transaction.
</span><span class="marked1"><a name="line3142"></a>3142     include AutosaveAssociation, NestedAttributes
</span><span class="inferred0"><a name="line3143"></a>3143 
</span><span class="marked1"><a name="line3144"></a>3144     include Aggregations, Transactions, Reflection, Calculations, Serialization
</span><span class="inferred0"><a name="line3145"></a>3145   end
</span><span class="inferred1"><a name="line3146"></a>3146 end
</span><span class="inferred0"><a name="line3147"></a>3147 
</span><span class="inferred1"><a name="line3148"></a>3148 # TODO: Remove this and make it work with LAZY flag
</span><span class="marked0"><a name="line3149"></a>3149 require 'active_record/connection_adapters/abstract_adapter'
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
