<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.0/lib/active_record/validations.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Apr 10 14:55:48 -0500 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_3_0-lib-active_record-validations_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.0/lib/active_record/validations.rb</a>
        </td>
      <td class='lines_total'><tt>1061</tt>
        </td>
      <td class='lines_code'><tt>398</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>63.6%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='64'/>
                  <td class='uncovered' width='36'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>19.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='19'/>
                  <td class='uncovered' width='81'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>   1 module ActiveRecord
</span><span class="inferred0"><a name="line2"></a>   2   # Raised by &lt;tt&gt;save!&lt;/tt&gt; and &lt;tt&gt;create!&lt;/tt&gt; when the record is invalid.  Use the
</span><span class="inferred1"><a name="line3"></a>   3   # +record+ method to retrieve the record which did not validate.
</span><span class="inferred0"><a name="line4"></a>   4   #   begin
</span><span class="inferred1"><a name="line5"></a>   5   #     complex_operation_that_calls_save!_internally
</span><span class="inferred0"><a name="line6"></a>   6   #   rescue ActiveRecord::RecordInvalid =&gt; invalid
</span><span class="inferred1"><a name="line7"></a>   7   #     puts invalid.record.errors
</span><span class="inferred0"><a name="line8"></a>   8   #   end
</span><span class="marked1"><a name="line9"></a>   9   class RecordInvalid &lt; ActiveRecordError
</span><span class="marked0"><a name="line10"></a>  10     attr_reader :record
</span><span class="marked1"><a name="line11"></a>  11     def initialize(record)
</span><span class="uncovered0"><a name="line12"></a>  12       @record = record
</span><span class="uncovered1"><a name="line13"></a>  13       super(&quot;Validation failed: #{@record.errors.full_messages.join(&quot;, &quot;)}&quot;)
</span><span class="uncovered0"><a name="line14"></a>  14     end
</span><span class="uncovered1"><a name="line15"></a>  15   end
</span><span class="inferred0"><a name="line16"></a>  16 
</span><span class="inferred1"><a name="line17"></a>  17   # Active Record validation is reported to and from this object, which is used by Base#save to
</span><span class="inferred0"><a name="line18"></a>  18   # determine whether the object is in a valid state to be saved. See usage example in Validations.
</span><span class="marked1"><a name="line19"></a>  19   class Errors
</span><span class="marked0"><a name="line20"></a>  20     include Enumerable
</span><span class="inferred1"><a name="line21"></a>  21     
</span><span class="marked0"><a name="line22"></a>  22     class &lt;&lt; self
</span><span class="marked1"><a name="line23"></a>  23       def default_error_messages
</span><span class="uncovered0"><a name="line24"></a>  24         ActiveSupport::Deprecation.warn(&quot;ActiveRecord::Errors.default_error_messages has been deprecated. Please use I18n.translate('activerecord.errors.messages').&quot;)
</span><span class="uncovered1"><a name="line25"></a>  25         I18n.translate 'activerecord.errors.messages'
</span><span class="uncovered0"><a name="line26"></a>  26       end
</span><span class="uncovered1"><a name="line27"></a>  27     end
</span><span class="inferred0"><a name="line28"></a>  28 
</span><span class="marked1"><a name="line29"></a>  29     def initialize(base) # :nodoc:
</span><span class="uncovered0"><a name="line30"></a>  30       @base, @errors = base, {}
</span><span class="uncovered1"><a name="line31"></a>  31     end
</span><span class="inferred0"><a name="line32"></a>  32 
</span><span class="inferred1"><a name="line33"></a>  33     # Adds an error to the base object instead of any particular attribute. This is used
</span><span class="inferred0"><a name="line34"></a>  34     # to report errors that don't tie to any specific attribute, but rather to the object
</span><span class="inferred1"><a name="line35"></a>  35     # as a whole. These error messages don't get prepended with any field name when iterating
</span><span class="inferred0"><a name="line36"></a>  36     # with +each_full+, so they should be complete sentences.
</span><span class="marked1"><a name="line37"></a>  37     def add_to_base(msg)
</span><span class="uncovered0"><a name="line38"></a>  38       add(:base, msg)
</span><span class="uncovered1"><a name="line39"></a>  39     end
</span><span class="inferred0"><a name="line40"></a>  40 
</span><span class="inferred1"><a name="line41"></a>  41     # Adds an error message (+messsage+) to the +attribute+, which will be returned on a call to &lt;tt&gt;on(attribute)&lt;/tt&gt;
</span><span class="inferred0"><a name="line42"></a>  42     # for the same attribute and ensure that this error object returns false when asked if &lt;tt&gt;empty?&lt;/tt&gt;. More than one
</span><span class="inferred1"><a name="line43"></a>  43     # error can be added to the same +attribute+ in which case an array will be returned on a call to &lt;tt&gt;on(attribute)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line44"></a>  44     # If no +messsage+ is supplied, :invalid is assumed.
</span><span class="inferred1"><a name="line45"></a>  45     # If +message+ is a Symbol, it will be translated, using the appropriate scope (see translate_error).
</span><span class="marked0"><a name="line46"></a>  46     def add(attribute, message = nil, options = {})
</span><span class="uncovered1"><a name="line47"></a>  47       message ||= :invalid
</span><span class="uncovered0"><a name="line48"></a>  48       message = generate_message(attribute, message, options) if message.is_a?(Symbol)
</span><span class="uncovered1"><a name="line49"></a>  49       @errors[attribute.to_s] ||= []
</span><span class="uncovered0"><a name="line50"></a>  50       @errors[attribute.to_s] &lt;&lt; message
</span><span class="uncovered1"><a name="line51"></a>  51     end
</span><span class="inferred0"><a name="line52"></a>  52 
</span><span class="inferred1"><a name="line53"></a>  53     # Will add an error message to each of the attributes in +attributes+ that is empty.
</span><span class="marked0"><a name="line54"></a>  54     def add_on_empty(attributes, custom_message = nil)
</span><span class="uncovered1"><a name="line55"></a>  55       for attr in [attributes].flatten
</span><span class="uncovered0"><a name="line56"></a>  56         value = @base.respond_to?(attr.to_s) ? @base.send(attr.to_s) : @base[attr.to_s]
</span><span class="uncovered1"><a name="line57"></a>  57         is_empty = value.respond_to?(:empty?) ? value.empty? : false
</span><span class="uncovered0"><a name="line58"></a>  58         add(attr, :empty, :default =&gt; custom_message) unless !value.nil? &amp;&amp; !is_empty
</span><span class="uncovered1"><a name="line59"></a>  59       end
</span><span class="uncovered0"><a name="line60"></a>  60     end
</span><span class="inferred1"><a name="line61"></a>  61 
</span><span class="inferred0"><a name="line62"></a>  62     # Will add an error message to each of the attributes in +attributes+ that is blank (using Object#blank?).
</span><span class="marked1"><a name="line63"></a>  63     def add_on_blank(attributes, custom_message = nil)
</span><span class="uncovered0"><a name="line64"></a>  64       for attr in [attributes].flatten
</span><span class="uncovered1"><a name="line65"></a>  65         value = @base.respond_to?(attr.to_s) ? @base.send(attr.to_s) : @base[attr.to_s]
</span><span class="uncovered0"><a name="line66"></a>  66         add(attr, :blank, :default =&gt; custom_message) if value.blank?
</span><span class="uncovered1"><a name="line67"></a>  67       end
</span><span class="uncovered0"><a name="line68"></a>  68     end
</span><span class="inferred1"><a name="line69"></a>  69     
</span><span class="inferred0"><a name="line70"></a>  70     # Translates an error message in it's default scope (&lt;tt&gt;activerecord.errrors.messages&lt;/tt&gt;).
</span><span class="inferred1"><a name="line71"></a>  71     # Error messages are first looked up in &lt;tt&gt;models.MODEL.attributes.ATTRIBUTE.MESSAGE&lt;/tt&gt;, if it's not there, 
</span><span class="inferred0"><a name="line72"></a>  72     # it's looked up in &lt;tt&gt;models.MODEL.MESSAGE&lt;/tt&gt; and if that is not there it returns the translation of the 
</span><span class="inferred1"><a name="line73"></a>  73     # default message (e.g. &lt;tt&gt;activerecord.errors.messages.MESSAGE&lt;/tt&gt;). The translated model name, 
</span><span class="inferred0"><a name="line74"></a>  74     # translated attribute name and the value are available for interpolation.
</span><span class="inferred1"><a name="line75"></a>  75     #
</span><span class="inferred0"><a name="line76"></a>  76     # When using inheritence in your models, it will check all the inherited models too, but only if the model itself
</span><span class="inferred1"><a name="line77"></a>  77     # hasn't been found. Say you have &lt;tt&gt;class Admin &lt; User; end&lt;/tt&gt; and you wanted the translation for the &lt;tt&gt;:blank&lt;/tt&gt;
</span><span class="inferred0"><a name="line78"></a>  78     # error +message+ for the &lt;tt&gt;title&lt;/tt&gt; +attribute+, it looks for these translations:
</span><span class="inferred1"><a name="line79"></a>  79     # 
</span><span class="inferred0"><a name="line80"></a>  80     # &lt;ol&gt;
</span><span class="inferred1"><a name="line81"></a>  81     # &lt;li&gt;&lt;tt&gt;activerecord.errors.models.admin.attributes.title.blank&lt;/tt&gt;&lt;/li&gt;
</span><span class="inferred0"><a name="line82"></a>  82     # &lt;li&gt;&lt;tt&gt;activerecord.errors.models.admin.blank&lt;/tt&gt;&lt;/li&gt;
</span><span class="inferred1"><a name="line83"></a>  83     # &lt;li&gt;&lt;tt&gt;activerecord.errors.models.user.attributes.title.blank&lt;/tt&gt;&lt;/li&gt;
</span><span class="inferred0"><a name="line84"></a>  84     # &lt;li&gt;&lt;tt&gt;activerecord.errors.models.user.blank&lt;/tt&gt;&lt;/li&gt;
</span><span class="inferred1"><a name="line85"></a>  85     # &lt;li&gt;&lt;tt&gt;activerecord.errors.messages.blank&lt;/tt&gt;&lt;/li&gt;
</span><span class="inferred0"><a name="line86"></a>  86     # &lt;li&gt;any default you provided through the +options+ hash (in the activerecord.errors scope)&lt;/li&gt;
</span><span class="inferred1"><a name="line87"></a>  87     # &lt;/ol&gt;
</span><span class="marked0"><a name="line88"></a>  88     def generate_message(attribute, message = :invalid, options = {})
</span><span class="uncovered1"><a name="line89"></a>  89 
</span><span class="uncovered0"><a name="line90"></a>  90       message, options[:default] = options[:default], message if options[:default].is_a?(Symbol)
</span><span class="uncovered1"><a name="line91"></a>  91 
</span><span class="uncovered0"><a name="line92"></a>  92       defaults = @base.class.self_and_descendents_from_active_record.map do |klass| 
</span><span class="uncovered1"><a name="line93"></a>  93         [ :&quot;models.#{klass.name.underscore}.attributes.#{attribute}.#{message}&quot;, 
</span><span class="uncovered0"><a name="line94"></a>  94           :&quot;models.#{klass.name.underscore}.#{message}&quot; ]
</span><span class="uncovered1"><a name="line95"></a>  95       end
</span><span class="uncovered0"><a name="line96"></a>  96       
</span><span class="uncovered1"><a name="line97"></a>  97       defaults &lt;&lt; options.delete(:default)
</span><span class="uncovered0"><a name="line98"></a>  98       defaults = defaults.compact.flatten &lt;&lt; :&quot;messages.#{message}&quot;
</span><span class="uncovered1"><a name="line99"></a>  99 
</span><span class="uncovered0"><a name="line100"></a> 100       key = defaults.shift
</span><span class="uncovered1"><a name="line101"></a> 101       value = @base.respond_to?(attribute) ? @base.send(attribute) : nil
</span><span class="uncovered0"><a name="line102"></a> 102 
</span><span class="uncovered1"><a name="line103"></a> 103       options = { :default =&gt; defaults,
</span><span class="uncovered0"><a name="line104"></a> 104         :model =&gt; @base.class.human_name,
</span><span class="uncovered1"><a name="line105"></a> 105         :attribute =&gt; @base.class.human_attribute_name(attribute.to_s),
</span><span class="uncovered0"><a name="line106"></a> 106         :value =&gt; value,
</span><span class="uncovered1"><a name="line107"></a> 107         :scope =&gt; [:activerecord, :errors]
</span><span class="uncovered0"><a name="line108"></a> 108       }.merge(options)
</span><span class="uncovered1"><a name="line109"></a> 109 
</span><span class="uncovered0"><a name="line110"></a> 110       I18n.translate(key, options)
</span><span class="uncovered1"><a name="line111"></a> 111     end
</span><span class="inferred0"><a name="line112"></a> 112 
</span><span class="inferred1"><a name="line113"></a> 113     # Returns true if the specified +attribute+ has errors associated with it.
</span><span class="inferred0"><a name="line114"></a> 114     #
</span><span class="inferred1"><a name="line115"></a> 115     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line116"></a> 116     #     validates_presence_of :name, :address, :email
</span><span class="inferred1"><a name="line117"></a> 117     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred0"><a name="line118"></a> 118     #   end
</span><span class="inferred1"><a name="line119"></a> 119     #
</span><span class="inferred0"><a name="line120"></a> 120     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred1"><a name="line121"></a> 121     #   company.errors.invalid?(:name)      # =&gt; true
</span><span class="inferred0"><a name="line122"></a> 122     #   company.errors.invalid?(:address)   # =&gt; false
</span><span class="marked1"><a name="line123"></a> 123     def invalid?(attribute)
</span><span class="uncovered0"><a name="line124"></a> 124       !@errors[attribute.to_s].nil?
</span><span class="uncovered1"><a name="line125"></a> 125     end
</span><span class="inferred0"><a name="line126"></a> 126 
</span><span class="inferred1"><a name="line127"></a> 127     # Returns +nil+, if no errors are associated with the specified +attribute+.
</span><span class="inferred0"><a name="line128"></a> 128     # Returns the error message, if one error is associated with the specified +attribute+.
</span><span class="inferred1"><a name="line129"></a> 129     # Returns an array of error messages, if more than one error is associated with the specified +attribute+.
</span><span class="inferred0"><a name="line130"></a> 130     #
</span><span class="inferred1"><a name="line131"></a> 131     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line132"></a> 132     #     validates_presence_of :name, :address, :email
</span><span class="inferred1"><a name="line133"></a> 133     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred0"><a name="line134"></a> 134     #   end
</span><span class="inferred1"><a name="line135"></a> 135     #
</span><span class="inferred0"><a name="line136"></a> 136     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred1"><a name="line137"></a> 137     #   company.errors.on(:name)      # =&gt; [&quot;is too short (minimum is 5 characters)&quot;, &quot;can't be blank&quot;]
</span><span class="inferred0"><a name="line138"></a> 138     #   company.errors.on(:email)     # =&gt; &quot;can't be blank&quot;
</span><span class="inferred1"><a name="line139"></a> 139     #   company.errors.on(:address)   # =&gt; nil
</span><span class="marked0"><a name="line140"></a> 140     def on(attribute)
</span><span class="uncovered1"><a name="line141"></a> 141       errors = @errors[attribute.to_s]
</span><span class="uncovered0"><a name="line142"></a> 142       return nil if errors.nil?
</span><span class="uncovered1"><a name="line143"></a> 143       errors.size == 1 ? errors.first : errors
</span><span class="uncovered0"><a name="line144"></a> 144     end
</span><span class="inferred1"><a name="line145"></a> 145 
</span><span class="marked0"><a name="line146"></a> 146     alias :[] :on
</span><span class="inferred1"><a name="line147"></a> 147 
</span><span class="inferred0"><a name="line148"></a> 148     # Returns errors assigned to the base object through +add_to_base+ according to the normal rules of &lt;tt&gt;on(attribute)&lt;/tt&gt;.
</span><span class="marked1"><a name="line149"></a> 149     def on_base
</span><span class="uncovered0"><a name="line150"></a> 150       on(:base)
</span><span class="uncovered1"><a name="line151"></a> 151     end
</span><span class="inferred0"><a name="line152"></a> 152 
</span><span class="inferred1"><a name="line153"></a> 153     # Yields each attribute and associated message per error added.
</span><span class="inferred0"><a name="line154"></a> 154     #
</span><span class="inferred1"><a name="line155"></a> 155     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line156"></a> 156     #     validates_presence_of :name, :address, :email
</span><span class="inferred1"><a name="line157"></a> 157     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred0"><a name="line158"></a> 158     #   end
</span><span class="inferred1"><a name="line159"></a> 159     #
</span><span class="inferred0"><a name="line160"></a> 160     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred1"><a name="line161"></a> 161     #   company.errors.each{|attr,msg| puts &quot;#{attr} - #{msg}&quot; }
</span><span class="inferred0"><a name="line162"></a> 162     #   # =&gt; name - is too short (minimum is 5 characters)
</span><span class="inferred1"><a name="line163"></a> 163     #   #    name - can't be blank
</span><span class="inferred0"><a name="line164"></a> 164     #   #    address - can't be blank
</span><span class="marked1"><a name="line165"></a> 165     def each
</span><span class="uncovered0"><a name="line166"></a> 166       @errors.each_key { |attr| @errors[attr].each { |msg| yield attr, msg } }
</span><span class="uncovered1"><a name="line167"></a> 167     end
</span><span class="inferred0"><a name="line168"></a> 168 
</span><span class="inferred1"><a name="line169"></a> 169     # Yields each full error message added. So &lt;tt&gt;Person.errors.add(&quot;first_name&quot;, &quot;can't be empty&quot;)&lt;/tt&gt; will be returned
</span><span class="inferred0"><a name="line170"></a> 170     # through iteration as &quot;First name can't be empty&quot;.
</span><span class="inferred1"><a name="line171"></a> 171     #
</span><span class="inferred0"><a name="line172"></a> 172     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line173"></a> 173     #     validates_presence_of :name, :address, :email
</span><span class="inferred0"><a name="line174"></a> 174     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred1"><a name="line175"></a> 175     #   end
</span><span class="inferred0"><a name="line176"></a> 176     #
</span><span class="inferred1"><a name="line177"></a> 177     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred0"><a name="line178"></a> 178     #   company.errors.each_full{|msg| puts msg }
</span><span class="inferred1"><a name="line179"></a> 179     #   # =&gt; Name is too short (minimum is 5 characters)
</span><span class="inferred0"><a name="line180"></a> 180     #   #    Name can't be blank
</span><span class="inferred1"><a name="line181"></a> 181     #   #    Address can't be blank
</span><span class="marked0"><a name="line182"></a> 182     def each_full
</span><span class="uncovered1"><a name="line183"></a> 183       full_messages.each { |msg| yield msg }
</span><span class="uncovered0"><a name="line184"></a> 184     end
</span><span class="inferred1"><a name="line185"></a> 185 
</span><span class="inferred0"><a name="line186"></a> 186     # Returns all the full error messages in an array.
</span><span class="inferred1"><a name="line187"></a> 187     #
</span><span class="inferred0"><a name="line188"></a> 188     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line189"></a> 189     #     validates_presence_of :name, :address, :email
</span><span class="inferred0"><a name="line190"></a> 190     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred1"><a name="line191"></a> 191     #   end
</span><span class="inferred0"><a name="line192"></a> 192     #
</span><span class="inferred1"><a name="line193"></a> 193     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred0"><a name="line194"></a> 194     #   company.errors.full_messages # =&gt;
</span><span class="inferred1"><a name="line195"></a> 195     #     [&quot;Name is too short (minimum is 5 characters)&quot;, &quot;Name can't be blank&quot;, &quot;Address can't be blank&quot;]
</span><span class="marked0"><a name="line196"></a> 196     def full_messages(options = {})
</span><span class="uncovered1"><a name="line197"></a> 197       full_messages = []
</span><span class="uncovered0"><a name="line198"></a> 198 
</span><span class="uncovered1"><a name="line199"></a> 199       @errors.each_key do |attr|
</span><span class="uncovered0"><a name="line200"></a> 200         @errors[attr].each do |message|
</span><span class="uncovered1"><a name="line201"></a> 201           next unless message
</span><span class="uncovered0"><a name="line202"></a> 202 
</span><span class="uncovered1"><a name="line203"></a> 203           if attr == &quot;base&quot;
</span><span class="uncovered0"><a name="line204"></a> 204             full_messages &lt;&lt; message
</span><span class="uncovered1"><a name="line205"></a> 205           else
</span><span class="uncovered0"><a name="line206"></a> 206             attr_name = @base.class.human_attribute_name(attr)
</span><span class="uncovered1"><a name="line207"></a> 207             full_messages &lt;&lt; attr_name + I18n.t('activerecord.errors.format.separator', :default =&gt; ' ') + message
</span><span class="uncovered0"><a name="line208"></a> 208           end
</span><span class="uncovered1"><a name="line209"></a> 209         end
</span><span class="uncovered0"><a name="line210"></a> 210       end
</span><span class="uncovered1"><a name="line211"></a> 211       full_messages
</span><span class="uncovered0"><a name="line212"></a> 212     end 
</span><span class="inferred1"><a name="line213"></a> 213 
</span><span class="inferred0"><a name="line214"></a> 214     # Returns true if no errors have been added.
</span><span class="marked1"><a name="line215"></a> 215     def empty?
</span><span class="uncovered0"><a name="line216"></a> 216       @errors.empty?
</span><span class="uncovered1"><a name="line217"></a> 217     end
</span><span class="inferred0"><a name="line218"></a> 218 
</span><span class="inferred1"><a name="line219"></a> 219     # Removes all errors that have been added.
</span><span class="marked0"><a name="line220"></a> 220     def clear
</span><span class="uncovered1"><a name="line221"></a> 221       @errors = {}
</span><span class="uncovered0"><a name="line222"></a> 222     end
</span><span class="inferred1"><a name="line223"></a> 223 
</span><span class="inferred0"><a name="line224"></a> 224     # Returns the total number of errors added. Two errors added to the same attribute will be counted as such.
</span><span class="marked1"><a name="line225"></a> 225     def size
</span><span class="uncovered0"><a name="line226"></a> 226       @errors.values.inject(0) { |error_count, attribute| error_count + attribute.size }
</span><span class="uncovered1"><a name="line227"></a> 227     end
</span><span class="inferred0"><a name="line228"></a> 228 
</span><span class="marked1"><a name="line229"></a> 229     alias_method :count, :size
</span><span class="marked0"><a name="line230"></a> 230     alias_method :length, :size
</span><span class="inferred1"><a name="line231"></a> 231 
</span><span class="inferred0"><a name="line232"></a> 232     # Returns an XML representation of this error object.
</span><span class="inferred1"><a name="line233"></a> 233     #
</span><span class="inferred0"><a name="line234"></a> 234     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line235"></a> 235     #     validates_presence_of :name, :address, :email
</span><span class="inferred0"><a name="line236"></a> 236     #     validates_length_of :name, :in =&gt; 5..30
</span><span class="inferred1"><a name="line237"></a> 237     #   end
</span><span class="inferred0"><a name="line238"></a> 238     #
</span><span class="inferred1"><a name="line239"></a> 239     #   company = Company.create(:address =&gt; '123 First St.')
</span><span class="inferred0"><a name="line240"></a> 240     #   company.errors.to_xml
</span><span class="inferred1"><a name="line241"></a> 241     #   # =&gt;  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</span><span class="inferred0"><a name="line242"></a> 242     #   #     &lt;errors&gt;
</span><span class="inferred1"><a name="line243"></a> 243     #   #       &lt;error&gt;Name is too short (minimum is 5 characters)&lt;/error&gt;
</span><span class="inferred0"><a name="line244"></a> 244     #   #       &lt;error&gt;Name can't be blank&lt;/error&gt;
</span><span class="inferred1"><a name="line245"></a> 245     #   #       &lt;error&gt;Address can't be blank&lt;/error&gt;
</span><span class="inferred0"><a name="line246"></a> 246     #   #     &lt;/errors&gt;
</span><span class="marked1"><a name="line247"></a> 247     def to_xml(options={})
</span><span class="uncovered0"><a name="line248"></a> 248       options[:root] ||= &quot;errors&quot;
</span><span class="uncovered1"><a name="line249"></a> 249       options[:indent] ||= 2
</span><span class="uncovered0"><a name="line250"></a> 250       options[:builder] ||= Builder::XmlMarkup.new(:indent =&gt; options[:indent])
</span><span class="uncovered1"><a name="line251"></a> 251 
</span><span class="uncovered0"><a name="line252"></a> 252       options[:builder].instruct! unless options.delete(:skip_instruct)
</span><span class="uncovered1"><a name="line253"></a> 253       options[:builder].errors do |e|
</span><span class="uncovered0"><a name="line254"></a> 254         full_messages.each { |msg| e.error(msg) }
</span><span class="uncovered1"><a name="line255"></a> 255       end
</span><span class="uncovered0"><a name="line256"></a> 256     end
</span><span class="uncovered1"><a name="line257"></a> 257     
</span><span class="uncovered0"><a name="line258"></a> 258   end
</span><span class="inferred1"><a name="line259"></a> 259 
</span><span class="inferred0"><a name="line260"></a> 260 
</span><span class="inferred1"><a name="line261"></a> 261   # Please do have a look at ActiveRecord::Validations::ClassMethods for a higher level of validations.
</span><span class="inferred0"><a name="line262"></a> 262   #
</span><span class="inferred1"><a name="line263"></a> 263   # Active Records implement validation by overwriting Base#validate (or the variations, +validate_on_create+ and
</span><span class="inferred0"><a name="line264"></a> 264   # +validate_on_update+). Each of these methods can inspect the state of the object, which usually means ensuring
</span><span class="inferred1"><a name="line265"></a> 265   # that a number of attributes have a certain value (such as not empty, within a given range, matching a certain regular expression).
</span><span class="inferred0"><a name="line266"></a> 266   #
</span><span class="inferred1"><a name="line267"></a> 267   # Example:
</span><span class="inferred0"><a name="line268"></a> 268   #
</span><span class="inferred1"><a name="line269"></a> 269   #   class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line270"></a> 270   #     protected
</span><span class="inferred1"><a name="line271"></a> 271   #       def validate
</span><span class="inferred0"><a name="line272"></a> 272   #         errors.add_on_empty %w( first_name last_name )
</span><span class="inferred1"><a name="line273"></a> 273   #         errors.add(&quot;phone_number&quot;, &quot;has invalid format&quot;) unless phone_number =~ /[0-9]*/
</span><span class="inferred0"><a name="line274"></a> 274   #       end
</span><span class="inferred1"><a name="line275"></a> 275   #
</span><span class="inferred0"><a name="line276"></a> 276   #       def validate_on_create # is only run the first time a new object is saved
</span><span class="inferred1"><a name="line277"></a> 277   #         unless valid_discount?(membership_discount)
</span><span class="inferred0"><a name="line278"></a> 278   #           errors.add(&quot;membership_discount&quot;, &quot;has expired&quot;)
</span><span class="inferred1"><a name="line279"></a> 279   #         end
</span><span class="inferred0"><a name="line280"></a> 280   #       end
</span><span class="inferred1"><a name="line281"></a> 281   #
</span><span class="inferred0"><a name="line282"></a> 282   #       def validate_on_update
</span><span class="inferred1"><a name="line283"></a> 283   #         errors.add_to_base(&quot;No changes have occurred&quot;) if unchanged_attributes?
</span><span class="inferred0"><a name="line284"></a> 284   #       end
</span><span class="inferred1"><a name="line285"></a> 285   #   end
</span><span class="inferred0"><a name="line286"></a> 286   #
</span><span class="inferred1"><a name="line287"></a> 287   #   person = Person.new(&quot;first_name&quot; =&gt; &quot;David&quot;, &quot;phone_number&quot; =&gt; &quot;what?&quot;)
</span><span class="inferred0"><a name="line288"></a> 288   #   person.save                         # =&gt; false (and doesn't do the save)
</span><span class="inferred1"><a name="line289"></a> 289   #   person.errors.empty?                # =&gt; false
</span><span class="inferred0"><a name="line290"></a> 290   #   person.errors.count                 # =&gt; 2
</span><span class="inferred1"><a name="line291"></a> 291   #   person.errors.on &quot;last_name&quot;        # =&gt; &quot;can't be empty&quot;
</span><span class="inferred0"><a name="line292"></a> 292   #   person.errors.on &quot;phone_number&quot;     # =&gt; &quot;has invalid format&quot;
</span><span class="inferred1"><a name="line293"></a> 293   #   person.errors.each_full { |msg| puts msg }
</span><span class="inferred0"><a name="line294"></a> 294   #                                       # =&gt; &quot;Last name can't be empty\n&quot; +
</span><span class="inferred1"><a name="line295"></a> 295   #                                       #    &quot;Phone number has invalid format&quot;
</span><span class="inferred0"><a name="line296"></a> 296   #
</span><span class="inferred1"><a name="line297"></a> 297   #   person.attributes = { &quot;last_name&quot; =&gt; &quot;Heinemeier&quot;, &quot;phone_number&quot; =&gt; &quot;555-555&quot; }
</span><span class="inferred0"><a name="line298"></a> 298   #   person.save # =&gt; true (and person is now saved in the database)
</span><span class="inferred1"><a name="line299"></a> 299   #
</span><span class="inferred0"><a name="line300"></a> 300   # An Errors object is automatically created for every Active Record.
</span><span class="marked1"><a name="line301"></a> 301   module Validations
</span><span class="marked0"><a name="line302"></a> 302     VALIDATIONS = %w( validate validate_on_create validate_on_update )
</span><span class="inferred1"><a name="line303"></a> 303 
</span><span class="marked0"><a name="line304"></a> 304     def self.included(base) # :nodoc:
</span><span class="marked1"><a name="line305"></a> 305       base.extend ClassMethods
</span><span class="marked0"><a name="line306"></a> 306       base.class_eval do
</span><span class="marked1"><a name="line307"></a> 307         alias_method_chain :save, :validation
</span><span class="marked0"><a name="line308"></a> 308         alias_method_chain :save!, :validation
</span><span class="inferred1"><a name="line309"></a> 309       end
</span><span class="inferred0"><a name="line310"></a> 310 
</span><span class="marked1"><a name="line311"></a> 311       base.send :include, ActiveSupport::Callbacks
</span><span class="marked0"><a name="line312"></a> 312       base.define_callbacks *VALIDATIONS
</span><span class="inferred1"><a name="line313"></a> 313     end
</span><span class="inferred0"><a name="line314"></a> 314 
</span><span class="inferred1"><a name="line315"></a> 315     # Active Record classes can implement validations in several ways. The highest level, easiest to read,
</span><span class="inferred0"><a name="line316"></a> 316     # and recommended approach is to use the declarative &lt;tt&gt;validates_..._of&lt;/tt&gt; class methods (and
</span><span class="inferred1"><a name="line317"></a> 317     # +validates_associated+) documented below. These are sufficient for most model validations.
</span><span class="inferred0"><a name="line318"></a> 318     #
</span><span class="inferred1"><a name="line319"></a> 319     # Slightly lower level is +validates_each+. It provides some of the same options as the purely declarative
</span><span class="inferred0"><a name="line320"></a> 320     # validation methods, but like all the lower-level approaches it requires manually adding to the errors collection
</span><span class="inferred1"><a name="line321"></a> 321     # when the record is invalid.
</span><span class="inferred0"><a name="line322"></a> 322     #
</span><span class="inferred1"><a name="line323"></a> 323     # At a yet lower level, a model can use the class methods +validate+, +validate_on_create+ and +validate_on_update+
</span><span class="inferred0"><a name="line324"></a> 324     # to add validation methods or blocks. These are ActiveSupport::Callbacks and follow the same rules of inheritance
</span><span class="inferred1"><a name="line325"></a> 325     # and chaining.
</span><span class="inferred0"><a name="line326"></a> 326     #
</span><span class="inferred1"><a name="line327"></a> 327     # The lowest level style is to define the instance methods +validate+, +validate_on_create+ and +validate_on_update+
</span><span class="inferred0"><a name="line328"></a> 328     # as documented in ActiveRecord::Validations.
</span><span class="inferred1"><a name="line329"></a> 329     #
</span><span class="inferred0"><a name="line330"></a> 330     # == +validate+, +validate_on_create+ and +validate_on_update+ Class Methods
</span><span class="inferred1"><a name="line331"></a> 331     #
</span><span class="inferred0"><a name="line332"></a> 332     # Calls to these methods add a validation method or block to the class. Again, this approach is recommended
</span><span class="inferred1"><a name="line333"></a> 333     # only when the higher-level methods documented below (&lt;tt&gt;validates_..._of&lt;/tt&gt; and +validates_associated+) are
</span><span class="inferred0"><a name="line334"></a> 334     # insufficient to handle the required validation.
</span><span class="inferred1"><a name="line335"></a> 335     #
</span><span class="inferred0"><a name="line336"></a> 336     # This can be done with a symbol pointing to a method:
</span><span class="inferred1"><a name="line337"></a> 337     #
</span><span class="inferred0"><a name="line338"></a> 338     #   class Comment &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line339"></a> 339     #     validate :must_be_friends
</span><span class="inferred0"><a name="line340"></a> 340     #
</span><span class="inferred1"><a name="line341"></a> 341     #     def must_be_friends
</span><span class="inferred0"><a name="line342"></a> 342     #       errors.add_to_base(&quot;Must be friends to leave a comment&quot;) unless commenter.friend_of?(commentee)
</span><span class="inferred1"><a name="line343"></a> 343     #     end
</span><span class="inferred0"><a name="line344"></a> 344     #   end
</span><span class="inferred1"><a name="line345"></a> 345     #
</span><span class="inferred0"><a name="line346"></a> 346     # Or with a block which is passed the current record to be validated:
</span><span class="inferred1"><a name="line347"></a> 347     #
</span><span class="inferred0"><a name="line348"></a> 348     #   class Comment &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line349"></a> 349     #     validate do |comment|
</span><span class="inferred0"><a name="line350"></a> 350     #       comment.must_be_friends
</span><span class="inferred1"><a name="line351"></a> 351     #     end
</span><span class="inferred0"><a name="line352"></a> 352     #
</span><span class="inferred1"><a name="line353"></a> 353     #     def must_be_friends
</span><span class="inferred0"><a name="line354"></a> 354     #       errors.add_to_base(&quot;Must be friends to leave a comment&quot;) unless commenter.friend_of?(commentee)
</span><span class="inferred1"><a name="line355"></a> 355     #     end
</span><span class="inferred0"><a name="line356"></a> 356     #   end
</span><span class="inferred1"><a name="line357"></a> 357     #
</span><span class="inferred0"><a name="line358"></a> 358     # This usage applies to +validate_on_create+ and +validate_on_update+ as well.
</span><span class="marked1"><a name="line359"></a> 359     module ClassMethods
</span><span class="marked0"><a name="line360"></a> 360       DEFAULT_VALIDATION_OPTIONS = {
</span><span class="inferred1"><a name="line361"></a> 361         :on =&gt; :save,
</span><span class="inferred0"><a name="line362"></a> 362         :allow_nil =&gt; false,
</span><span class="inferred1"><a name="line363"></a> 363         :allow_blank =&gt; false,
</span><span class="inferred0"><a name="line364"></a> 364         :message =&gt; nil
</span><span class="inferred1"><a name="line365"></a> 365       }.freeze
</span><span class="inferred0"><a name="line366"></a> 366 
</span><span class="marked1"><a name="line367"></a> 367       ALL_RANGE_OPTIONS = [ :is, :within, :in, :minimum, :maximum ].freeze
</span><span class="marked0"><a name="line368"></a> 368       ALL_NUMERICALITY_CHECKS = { :greater_than =&gt; '&gt;', :greater_than_or_equal_to =&gt; '&gt;=',
</span><span class="inferred1"><a name="line369"></a> 369                                   :equal_to =&gt; '==', :less_than =&gt; '&lt;', :less_than_or_equal_to =&gt; '&lt;=',
</span><span class="inferred0"><a name="line370"></a> 370                                   :odd =&gt; 'odd?', :even =&gt; 'even?' }.freeze
</span><span class="inferred1"><a name="line371"></a> 371 
</span><span class="inferred0"><a name="line372"></a> 372       # Validates each attribute against a block.
</span><span class="inferred1"><a name="line373"></a> 373       #
</span><span class="inferred0"><a name="line374"></a> 374       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line375"></a> 375       #     validates_each :first_name, :last_name do |record, attr, value|
</span><span class="inferred0"><a name="line376"></a> 376       #       record.errors.add attr, 'starts with z.' if value[0] == ?z
</span><span class="inferred1"><a name="line377"></a> 377       #     end
</span><span class="inferred0"><a name="line378"></a> 378       #   end
</span><span class="inferred1"><a name="line379"></a> 379       #
</span><span class="inferred0"><a name="line380"></a> 380       # Options:
</span><span class="inferred1"><a name="line381"></a> 381       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred0"><a name="line382"></a> 382       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - Skip validation if attribute is +nil+.
</span><span class="inferred1"><a name="line383"></a> 383       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - Skip validation if attribute is blank.
</span><span class="inferred0"><a name="line384"></a> 384       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line385"></a> 385       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line386"></a> 386       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line387"></a> 387       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line388"></a> 388       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line389"></a> 389       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked0"><a name="line390"></a> 390       def validates_each(*attrs)
</span><span class="uncovered1"><a name="line391"></a> 391         options = attrs.extract_options!.symbolize_keys
</span><span class="uncovered0"><a name="line392"></a> 392         attrs   = attrs.flatten
</span><span class="uncovered1"><a name="line393"></a> 393 
</span><span class="uncovered0"><a name="line394"></a> 394         # Declare the validation.
</span><span class="uncovered1"><a name="line395"></a> 395         send(validation_method(options[:on] || :save), options) do |record|
</span><span class="uncovered0"><a name="line396"></a> 396           attrs.each do |attr|
</span><span class="uncovered1"><a name="line397"></a> 397             value = record.send(attr)
</span><span class="uncovered0"><a name="line398"></a> 398             next if (value.nil? &amp;&amp; options[:allow_nil]) || (value.blank? &amp;&amp; options[:allow_blank])
</span><span class="uncovered1"><a name="line399"></a> 399             yield record, attr, value
</span><span class="uncovered0"><a name="line400"></a> 400           end
</span><span class="uncovered1"><a name="line401"></a> 401         end
</span><span class="uncovered0"><a name="line402"></a> 402       end
</span><span class="inferred1"><a name="line403"></a> 403 
</span><span class="inferred0"><a name="line404"></a> 404       # Encapsulates the pattern of wanting to validate a password or email address field with a confirmation. Example:
</span><span class="inferred1"><a name="line405"></a> 405       #
</span><span class="inferred0"><a name="line406"></a> 406       #   Model:
</span><span class="inferred1"><a name="line407"></a> 407       #     class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line408"></a> 408       #       validates_confirmation_of :user_name, :password
</span><span class="inferred1"><a name="line409"></a> 409       #       validates_confirmation_of :email_address, :message =&gt; &quot;should match confirmation&quot;
</span><span class="inferred0"><a name="line410"></a> 410       #     end
</span><span class="inferred1"><a name="line411"></a> 411       #
</span><span class="inferred0"><a name="line412"></a> 412       #   View:
</span><span class="inferred1"><a name="line413"></a> 413       #     &lt;%= password_field &quot;person&quot;, &quot;password&quot; %&gt;
</span><span class="inferred0"><a name="line414"></a> 414       #     &lt;%= password_field &quot;person&quot;, &quot;password_confirmation&quot; %&gt;
</span><span class="inferred1"><a name="line415"></a> 415       #
</span><span class="inferred0"><a name="line416"></a> 416       # The added +password_confirmation+ attribute is virtual; it exists only as an in-memory attribute for validating the password.
</span><span class="inferred1"><a name="line417"></a> 417       # To achieve this, the validation adds accessors to the model for the confirmation attribute. NOTE: This check is performed
</span><span class="inferred0"><a name="line418"></a> 418       # only if +password_confirmation+ is not +nil+, and by default only on save. To require confirmation, make sure to add a presence
</span><span class="inferred1"><a name="line419"></a> 419       # check for the confirmation attribute:
</span><span class="inferred0"><a name="line420"></a> 420       #
</span><span class="inferred1"><a name="line421"></a> 421       #   validates_presence_of :password_confirmation, :if =&gt; :password_changed?
</span><span class="inferred0"><a name="line422"></a> 422       #
</span><span class="inferred1"><a name="line423"></a> 423       # Configuration options:
</span><span class="inferred0"><a name="line424"></a> 424       # * &lt;tt&gt;:message&lt;/tt&gt; - A custom error message (default is: &quot;doesn't match confirmation&quot;).
</span><span class="inferred1"><a name="line425"></a> 425       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred0"><a name="line426"></a> 426       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line427"></a> 427       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line428"></a> 428       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line429"></a> 429       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line430"></a> 430       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line431"></a> 431       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked0"><a name="line432"></a> 432       def validates_confirmation_of(*attr_names)
</span><span class="uncovered1"><a name="line433"></a> 433         configuration = { :on =&gt; :save }
</span><span class="uncovered0"><a name="line434"></a> 434         configuration.update(attr_names.extract_options!)
</span><span class="uncovered1"><a name="line435"></a> 435 
</span><span class="uncovered0"><a name="line436"></a> 436         attr_accessor(*(attr_names.map { |n| &quot;#{n}_confirmation&quot; }))
</span><span class="uncovered1"><a name="line437"></a> 437 
</span><span class="uncovered0"><a name="line438"></a> 438         validates_each(attr_names, configuration) do |record, attr_name, value|
</span><span class="uncovered1"><a name="line439"></a> 439           unless record.send(&quot;#{attr_name}_confirmation&quot;).nil? or value == record.send(&quot;#{attr_name}_confirmation&quot;)
</span><span class="uncovered0"><a name="line440"></a> 440             record.errors.add(attr_name, :confirmation, :default =&gt; configuration[:message]) 
</span><span class="uncovered1"><a name="line441"></a> 441           end
</span><span class="uncovered0"><a name="line442"></a> 442         end
</span><span class="uncovered1"><a name="line443"></a> 443       end
</span><span class="inferred0"><a name="line444"></a> 444 
</span><span class="inferred1"><a name="line445"></a> 445       # Encapsulates the pattern of wanting to validate the acceptance of a terms of service check box (or similar agreement). Example:
</span><span class="inferred0"><a name="line446"></a> 446       #
</span><span class="inferred1"><a name="line447"></a> 447       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line448"></a> 448       #     validates_acceptance_of :terms_of_service
</span><span class="inferred1"><a name="line449"></a> 449       #     validates_acceptance_of :eula, :message =&gt; &quot;must be abided&quot;
</span><span class="inferred0"><a name="line450"></a> 450       #   end
</span><span class="inferred1"><a name="line451"></a> 451       #
</span><span class="inferred0"><a name="line452"></a> 452       # If the database column does not exist, the +terms_of_service+ attribute is entirely virtual. This check is
</span><span class="inferred1"><a name="line453"></a> 453       # performed only if +terms_of_service+ is not +nil+ and by default on save.
</span><span class="inferred0"><a name="line454"></a> 454       #
</span><span class="inferred1"><a name="line455"></a> 455       # Configuration options:
</span><span class="inferred0"><a name="line456"></a> 456       # * &lt;tt&gt;:message&lt;/tt&gt; - A custom error message (default is: &quot;must be accepted&quot;).
</span><span class="inferred1"><a name="line457"></a> 457       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred0"><a name="line458"></a> 458       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - Skip validation if attribute is +nil+ (default is true).
</span><span class="inferred1"><a name="line459"></a> 459       # * &lt;tt&gt;:accept&lt;/tt&gt; - Specifies value that is considered accepted.  The default value is a string &quot;1&quot;, which
</span><span class="inferred0"><a name="line460"></a> 460       #   makes it easy to relate to an HTML checkbox. This should be set to +true+ if you are validating a database
</span><span class="inferred1"><a name="line461"></a> 461       #   column, since the attribute is typecast from &quot;1&quot; to +true+ before validation.
</span><span class="inferred0"><a name="line462"></a> 462       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line463"></a> 463       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line464"></a> 464       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line465"></a> 465       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line466"></a> 466       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line467"></a> 467       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked0"><a name="line468"></a> 468       def validates_acceptance_of(*attr_names)
</span><span class="uncovered1"><a name="line469"></a> 469         configuration = { :on =&gt; :save, :allow_nil =&gt; true, :accept =&gt; &quot;1&quot; }
</span><span class="uncovered0"><a name="line470"></a> 470         configuration.update(attr_names.extract_options!)
</span><span class="uncovered1"><a name="line471"></a> 471 
</span><span class="uncovered0"><a name="line472"></a> 472         db_cols = begin
</span><span class="uncovered1"><a name="line473"></a> 473           column_names
</span><span class="uncovered0"><a name="line474"></a> 474         rescue Exception # To ignore both statement and connection errors
</span><span class="uncovered1"><a name="line475"></a> 475           []
</span><span class="uncovered0"><a name="line476"></a> 476         end
</span><span class="uncovered1"><a name="line477"></a> 477         names = attr_names.reject { |name| db_cols.include?(name.to_s) }
</span><span class="uncovered0"><a name="line478"></a> 478         attr_accessor(*names)
</span><span class="uncovered1"><a name="line479"></a> 479 
</span><span class="uncovered0"><a name="line480"></a> 480         validates_each(attr_names,configuration) do |record, attr_name, value|
</span><span class="uncovered1"><a name="line481"></a> 481           unless value == configuration[:accept]
</span><span class="uncovered0"><a name="line482"></a> 482             record.errors.add(attr_name, :accepted, :default =&gt; configuration[:message]) 
</span><span class="uncovered1"><a name="line483"></a> 483           end
</span><span class="uncovered0"><a name="line484"></a> 484         end
</span><span class="uncovered1"><a name="line485"></a> 485       end
</span><span class="inferred0"><a name="line486"></a> 486 
</span><span class="inferred1"><a name="line487"></a> 487       # Validates that the specified attributes are not blank (as defined by Object#blank?). Happens by default on save. Example:
</span><span class="inferred0"><a name="line488"></a> 488       #
</span><span class="inferred1"><a name="line489"></a> 489       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line490"></a> 490       #     validates_presence_of :first_name
</span><span class="inferred1"><a name="line491"></a> 491       #   end
</span><span class="inferred0"><a name="line492"></a> 492       #
</span><span class="inferred1"><a name="line493"></a> 493       # The first_name attribute must be in the object and it cannot be blank.
</span><span class="inferred0"><a name="line494"></a> 494       #
</span><span class="inferred1"><a name="line495"></a> 495       # If you want to validate the presence of a boolean field (where the real values are true and false),
</span><span class="inferred0"><a name="line496"></a> 496       # you will want to use &lt;tt&gt;validates_inclusion_of :field_name, :in =&gt; [true, false]&lt;/tt&gt;.
</span><span class="inferred1"><a name="line497"></a> 497       #
</span><span class="inferred0"><a name="line498"></a> 498       # This is due to the way Object#blank? handles boolean values: &lt;tt&gt;false.blank? # =&gt; true&lt;/tt&gt;.
</span><span class="inferred1"><a name="line499"></a> 499       #
</span><span class="inferred0"><a name="line500"></a> 500       # Configuration options:
</span><span class="inferred1"><a name="line501"></a> 501       # * &lt;tt&gt;message&lt;/tt&gt; - A custom error message (default is: &quot;can't be blank&quot;).
</span><span class="inferred0"><a name="line502"></a> 502       # * &lt;tt&gt;on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, 
</span><span class="inferred1"><a name="line503"></a> 503       #   &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred0"><a name="line504"></a> 504       # * &lt;tt&gt;if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line505"></a> 505       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).
</span><span class="inferred0"><a name="line506"></a> 506       #   The method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line507"></a> 507       # * &lt;tt&gt;unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line508"></a> 508       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).
</span><span class="inferred1"><a name="line509"></a> 509       #   The method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line510"></a> 510       #
</span><span class="marked1"><a name="line511"></a> 511       def validates_presence_of(*attr_names)
</span><span class="uncovered0"><a name="line512"></a> 512         configuration = { :on =&gt; :save }
</span><span class="uncovered1"><a name="line513"></a> 513         configuration.update(attr_names.extract_options!)
</span><span class="uncovered0"><a name="line514"></a> 514 
</span><span class="uncovered1"><a name="line515"></a> 515         # can't use validates_each here, because it cannot cope with nonexistent attributes,
</span><span class="uncovered0"><a name="line516"></a> 516         # while errors.add_on_empty can
</span><span class="uncovered1"><a name="line517"></a> 517         send(validation_method(configuration[:on]), configuration) do |record|
</span><span class="uncovered0"><a name="line518"></a> 518           record.errors.add_on_blank(attr_names, configuration[:message])
</span><span class="uncovered1"><a name="line519"></a> 519         end
</span><span class="uncovered0"><a name="line520"></a> 520       end
</span><span class="inferred1"><a name="line521"></a> 521 
</span><span class="inferred0"><a name="line522"></a> 522       # Validates that the specified attribute matches the length restrictions supplied. Only one option can be used at a time:
</span><span class="inferred1"><a name="line523"></a> 523       #
</span><span class="inferred0"><a name="line524"></a> 524       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line525"></a> 525       #     validates_length_of :first_name, :maximum=&gt;30
</span><span class="inferred0"><a name="line526"></a> 526       #     validates_length_of :last_name, :maximum=&gt;30, :message=&gt;&quot;less than {{count}} if you don't mind&quot;
</span><span class="inferred1"><a name="line527"></a> 527       #     validates_length_of :fax, :in =&gt; 7..32, :allow_nil =&gt; true
</span><span class="inferred0"><a name="line528"></a> 528       #     validates_length_of :phone, :in =&gt; 7..32, :allow_blank =&gt; true
</span><span class="inferred1"><a name="line529"></a> 529       #     validates_length_of :user_name, :within =&gt; 6..20, :too_long =&gt; &quot;pick a shorter name&quot;, :too_short =&gt; &quot;pick a longer name&quot;
</span><span class="inferred0"><a name="line530"></a> 530       #     validates_length_of :fav_bra_size, :minimum =&gt; 1, :too_short =&gt; &quot;please enter at least {{count}} character&quot;
</span><span class="inferred1"><a name="line531"></a> 531       #     validates_length_of :smurf_leader, :is =&gt; 4, :message =&gt; &quot;papa is spelled with {{count}} characters... don't play me.&quot;
</span><span class="inferred0"><a name="line532"></a> 532       #     validates_length_of :essay, :minimum =&gt; 100, :too_short =&gt; &quot;Your essay must be at least {{count}} words.&quot;), :tokenizer =&gt; lambda {|str| str.scan(/\w+/) }
</span><span class="inferred1"><a name="line533"></a> 533       #   end
</span><span class="inferred0"><a name="line534"></a> 534       #
</span><span class="inferred1"><a name="line535"></a> 535       # Configuration options:
</span><span class="inferred0"><a name="line536"></a> 536       # * &lt;tt&gt;:minimum&lt;/tt&gt; - The minimum size of the attribute.
</span><span class="inferred1"><a name="line537"></a> 537       # * &lt;tt&gt;:maximum&lt;/tt&gt; - The maximum size of the attribute.
</span><span class="inferred0"><a name="line538"></a> 538       # * &lt;tt&gt;:is&lt;/tt&gt; - The exact size of the attribute.
</span><span class="inferred1"><a name="line539"></a> 539       # * &lt;tt&gt;:within&lt;/tt&gt; - A range specifying the minimum and maximum size of the attribute.
</span><span class="inferred0"><a name="line540"></a> 540       # * &lt;tt&gt;:in&lt;/tt&gt; - A synonym(or alias) for &lt;tt&gt;:within&lt;/tt&gt;.
</span><span class="inferred1"><a name="line541"></a> 541       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - Attribute may be +nil+; skip validation.
</span><span class="inferred0"><a name="line542"></a> 542       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - Attribute may be blank; skip validation.
</span><span class="inferred1"><a name="line543"></a> 543       # * &lt;tt&gt;:too_long&lt;/tt&gt; - The error message if the attribute goes over the maximum (default is: &quot;is too long (maximum is {{count}} characters)&quot;).
</span><span class="inferred0"><a name="line544"></a> 544       # * &lt;tt&gt;:too_short&lt;/tt&gt; - The error message if the attribute goes under the minimum (default is: &quot;is too short (min is {{count}} characters)&quot;).
</span><span class="inferred1"><a name="line545"></a> 545       # * &lt;tt&gt;:wrong_length&lt;/tt&gt; - The error message if using the &lt;tt&gt;:is&lt;/tt&gt; method and the attribute is the wrong size (default is: &quot;is the wrong length (should be {{count}} characters)&quot;).
</span><span class="inferred0"><a name="line546"></a> 546       # * &lt;tt&gt;:message&lt;/tt&gt; - The error message to use for a &lt;tt&gt;:minimum&lt;/tt&gt;, &lt;tt&gt;:maximum&lt;/tt&gt;, or &lt;tt&gt;:is&lt;/tt&gt; violation.  An alias of the appropriate &lt;tt&gt;too_long&lt;/tt&gt;/&lt;tt&gt;too_short&lt;/tt&gt;/&lt;tt&gt;wrong_length&lt;/tt&gt; message.
</span><span class="inferred1"><a name="line547"></a> 547       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred0"><a name="line548"></a> 548       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line549"></a> 549       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line550"></a> 550       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line551"></a> 551       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line552"></a> 552       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line553"></a> 553       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line554"></a> 554       # * &lt;tt&gt;:tokenizer&lt;/tt&gt; - Specifies how to split up the attribute string. (e.g. &lt;tt&gt;:tokenizer =&gt; lambda {|str| str.scan(/\w+/)}&lt;/tt&gt; to
</span><span class="inferred1"><a name="line555"></a> 555       #   count words as in above example.)
</span><span class="inferred0"><a name="line556"></a> 556       #   Defaults to &lt;tt&gt;lambda{ |value| value.split(//) }&lt;/tt&gt; which counts individual characters.
</span><span class="marked1"><a name="line557"></a> 557       def validates_length_of(*attrs)
</span><span class="uncovered0"><a name="line558"></a> 558         # Merge given options with defaults.
</span><span class="uncovered1"><a name="line559"></a> 559         options = {
</span><span class="uncovered0"><a name="line560"></a> 560           :tokenizer =&gt; lambda {|value| value.split(//)}
</span><span class="uncovered1"><a name="line561"></a> 561         }.merge(DEFAULT_VALIDATION_OPTIONS)
</span><span class="uncovered0"><a name="line562"></a> 562         options.update(attrs.extract_options!.symbolize_keys)
</span><span class="uncovered1"><a name="line563"></a> 563 
</span><span class="uncovered0"><a name="line564"></a> 564         # Ensure that one and only one range option is specified.
</span><span class="uncovered1"><a name="line565"></a> 565         range_options = ALL_RANGE_OPTIONS &amp; options.keys
</span><span class="uncovered0"><a name="line566"></a> 566         case range_options.size
</span><span class="uncovered1"><a name="line567"></a> 567           when 0
</span><span class="uncovered0"><a name="line568"></a> 568             raise ArgumentError, 'Range unspecified.  Specify the :within, :maximum, :minimum, or :is option.'
</span><span class="uncovered1"><a name="line569"></a> 569           when 1
</span><span class="uncovered0"><a name="line570"></a> 570             # Valid number of options; do nothing.
</span><span class="uncovered1"><a name="line571"></a> 571           else
</span><span class="uncovered0"><a name="line572"></a> 572             raise ArgumentError, 'Too many range options specified.  Choose only one.'
</span><span class="uncovered1"><a name="line573"></a> 573         end
</span><span class="uncovered0"><a name="line574"></a> 574 
</span><span class="uncovered1"><a name="line575"></a> 575         # Get range option and value.
</span><span class="uncovered0"><a name="line576"></a> 576         option = range_options.first
</span><span class="uncovered1"><a name="line577"></a> 577         option_value = options[range_options.first]
</span><span class="uncovered0"><a name="line578"></a> 578         key = {:is =&gt; :wrong_length, :minimum =&gt; :too_short, :maximum =&gt; :too_long}[option]
</span><span class="uncovered1"><a name="line579"></a> 579         custom_message = options[:message] || options[key]
</span><span class="uncovered0"><a name="line580"></a> 580 
</span><span class="uncovered1"><a name="line581"></a> 581         case option
</span><span class="uncovered0"><a name="line582"></a> 582           when :within, :in
</span><span class="uncovered1"><a name="line583"></a> 583             raise ArgumentError, &quot;:#{option} must be a Range&quot; unless option_value.is_a?(Range)
</span><span class="uncovered0"><a name="line584"></a> 584 
</span><span class="uncovered1"><a name="line585"></a> 585             validates_each(attrs, options) do |record, attr, value|
</span><span class="uncovered0"><a name="line586"></a> 586               value = options[:tokenizer].call(value) if value.kind_of?(String)
</span><span class="uncovered1"><a name="line587"></a> 587               if value.nil? or value.size &lt; option_value.begin
</span><span class="uncovered0"><a name="line588"></a> 588                 record.errors.add(attr, :too_short, :default =&gt; custom_message || options[:too_short], :count =&gt; option_value.begin)
</span><span class="uncovered1"><a name="line589"></a> 589               elsif value.size &gt; option_value.end
</span><span class="uncovered0"><a name="line590"></a> 590                 record.errors.add(attr, :too_long, :default =&gt; custom_message || options[:too_long], :count =&gt; option_value.end)
</span><span class="uncovered1"><a name="line591"></a> 591               end
</span><span class="uncovered0"><a name="line592"></a> 592             end
</span><span class="uncovered1"><a name="line593"></a> 593           when :is, :minimum, :maximum
</span><span class="uncovered0"><a name="line594"></a> 594             raise ArgumentError, &quot;:#{option} must be a nonnegative Integer&quot; unless option_value.is_a?(Integer) and option_value &gt;= 0
</span><span class="uncovered1"><a name="line595"></a> 595 
</span><span class="uncovered0"><a name="line596"></a> 596             # Declare different validations per option.
</span><span class="uncovered1"><a name="line597"></a> 597             validity_checks = { :is =&gt; &quot;==&quot;, :minimum =&gt; &quot;&gt;=&quot;, :maximum =&gt; &quot;&lt;=&quot; }
</span><span class="uncovered0"><a name="line598"></a> 598 
</span><span class="uncovered1"><a name="line599"></a> 599             validates_each(attrs, options) do |record, attr, value|
</span><span class="uncovered0"><a name="line600"></a> 600               value = options[:tokenizer].call(value) if value.kind_of?(String)
</span><span class="uncovered1"><a name="line601"></a> 601               unless !value.nil? and value.size.method(validity_checks[option])[option_value]
</span><span class="uncovered0"><a name="line602"></a> 602                 record.errors.add(attr, key, :default =&gt; custom_message, :count =&gt; option_value) 
</span><span class="uncovered1"><a name="line603"></a> 603               end
</span><span class="uncovered0"><a name="line604"></a> 604             end
</span><span class="uncovered1"><a name="line605"></a> 605         end
</span><span class="uncovered0"><a name="line606"></a> 606       end
</span><span class="inferred1"><a name="line607"></a> 607 
</span><span class="marked0"><a name="line608"></a> 608       alias_method :validates_size_of, :validates_length_of
</span><span class="inferred1"><a name="line609"></a> 609 
</span><span class="inferred0"><a name="line610"></a> 610 
</span><span class="inferred1"><a name="line611"></a> 611       # Validates whether the value of the specified attributes are unique across the system. Useful for making sure that only one user
</span><span class="inferred0"><a name="line612"></a> 612       # can be named &quot;davidhh&quot;.
</span><span class="inferred1"><a name="line613"></a> 613       #
</span><span class="inferred0"><a name="line614"></a> 614       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line615"></a> 615       #     validates_uniqueness_of :user_name, :scope =&gt; :account_id
</span><span class="inferred0"><a name="line616"></a> 616       #   end
</span><span class="inferred1"><a name="line617"></a> 617       #
</span><span class="inferred0"><a name="line618"></a> 618       # It can also validate whether the value of the specified attributes are unique based on multiple scope parameters.  For example,
</span><span class="inferred1"><a name="line619"></a> 619       # making sure that a teacher can only be on the schedule once per semester for a particular class.
</span><span class="inferred0"><a name="line620"></a> 620       #
</span><span class="inferred1"><a name="line621"></a> 621       #   class TeacherSchedule &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line622"></a> 622       #     validates_uniqueness_of :teacher_id, :scope =&gt; [:semester_id, :class_id]
</span><span class="inferred1"><a name="line623"></a> 623       #   end
</span><span class="inferred0"><a name="line624"></a> 624       #
</span><span class="inferred1"><a name="line625"></a> 625       # When the record is created, a check is performed to make sure that no record exists in the database with the given value for the specified
</span><span class="inferred0"><a name="line626"></a> 626       # attribute (that maps to a column). When the record is updated, the same check is made but disregarding the record itself.
</span><span class="inferred1"><a name="line627"></a> 627       #
</span><span class="inferred0"><a name="line628"></a> 628       # Configuration options:
</span><span class="inferred1"><a name="line629"></a> 629       # * &lt;tt&gt;:message&lt;/tt&gt; - Specifies a custom error message (default is: &quot;has already been taken&quot;).
</span><span class="inferred0"><a name="line630"></a> 630       # * &lt;tt&gt;:scope&lt;/tt&gt; - One or more columns by which to limit the scope of the uniqueness constraint.
</span><span class="inferred1"><a name="line631"></a> 631       # * &lt;tt&gt;:case_sensitive&lt;/tt&gt; - Looks for an exact match. Ignored by non-text columns (+true+ by default).
</span><span class="inferred0"><a name="line632"></a> 632       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - If set to true, skips this validation if the attribute is +nil+ (default is +false+).
</span><span class="inferred1"><a name="line633"></a> 633       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - If set to true, skips this validation if the attribute is blank (default is +false+).
</span><span class="inferred0"><a name="line634"></a> 634       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line635"></a> 635       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line636"></a> 636       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line637"></a> 637       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line638"></a> 638       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line639"></a> 639       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line640"></a> 640       #
</span><span class="inferred1"><a name="line641"></a> 641       # === Concurrency and integrity
</span><span class="inferred0"><a name="line642"></a> 642       #
</span><span class="inferred1"><a name="line643"></a> 643       # Using this validation method in conjunction with ActiveRecord::Base#save
</span><span class="inferred0"><a name="line644"></a> 644       # does not guarantee the absence of duplicate record insertions, because
</span><span class="inferred1"><a name="line645"></a> 645       # uniqueness checks on the application level are inherently prone to race
</span><span class="inferred0"><a name="line646"></a> 646       # conditions. For example, suppose that two users try to post a Comment at
</span><span class="inferred1"><a name="line647"></a> 647       # the same time, and a Comment's title must be unique. At the database-level,
</span><span class="inferred0"><a name="line648"></a> 648       # the actions performed by these users could be interleaved in the following manner:
</span><span class="inferred1"><a name="line649"></a> 649       #
</span><span class="inferred0"><a name="line650"></a> 650       #               User 1                 |               User 2
</span><span class="inferred1"><a name="line651"></a> 651       #  ------------------------------------+--------------------------------------
</span><span class="inferred0"><a name="line652"></a> 652       #  # User 1 checks whether there's     |
</span><span class="inferred1"><a name="line653"></a> 653       #  # already a comment with the title  |
</span><span class="inferred0"><a name="line654"></a> 654       #  # 'My Post'. This is not the case.  |
</span><span class="inferred1"><a name="line655"></a> 655       #  SELECT * FROM comments              |
</span><span class="inferred0"><a name="line656"></a> 656       #  WHERE title = 'My Post'             |
</span><span class="inferred1"><a name="line657"></a> 657       #                                      |
</span><span class="inferred0"><a name="line658"></a> 658       #                                      | # User 2 does the same thing and also
</span><span class="inferred1"><a name="line659"></a> 659       #                                      | # infers that his title is unique.
</span><span class="inferred0"><a name="line660"></a> 660       #                                      | SELECT * FROM comments
</span><span class="inferred1"><a name="line661"></a> 661       #                                      | WHERE title = 'My Post'
</span><span class="inferred0"><a name="line662"></a> 662       #                                      |
</span><span class="inferred1"><a name="line663"></a> 663       #  # User 1 inserts his comment.       |
</span><span class="inferred0"><a name="line664"></a> 664       #  INSERT INTO comments                |
</span><span class="inferred1"><a name="line665"></a> 665       #  (title, content) VALUES             |
</span><span class="inferred0"><a name="line666"></a> 666       #  ('My Post', 'hi!')                  |
</span><span class="inferred1"><a name="line667"></a> 667       #                                      |
</span><span class="inferred0"><a name="line668"></a> 668       #                                      | # User 2 does the same thing.
</span><span class="inferred1"><a name="line669"></a> 669       #                                      | INSERT INTO comments
</span><span class="inferred0"><a name="line670"></a> 670       #                                      | (title, content) VALUES
</span><span class="inferred1"><a name="line671"></a> 671       #                                      | ('My Post', 'hello!')
</span><span class="inferred0"><a name="line672"></a> 672       #                                      |
</span><span class="inferred1"><a name="line673"></a> 673       #                                      | # ^^^^^^
</span><span class="inferred0"><a name="line674"></a> 674       #                                      | # Boom! We now have a duplicate
</span><span class="inferred1"><a name="line675"></a> 675       #                                      | # title!
</span><span class="inferred0"><a name="line676"></a> 676       #
</span><span class="inferred1"><a name="line677"></a> 677       # This could even happen if you use transactions with the 'serializable'
</span><span class="inferred0"><a name="line678"></a> 678       # isolation level. There are several ways to get around this problem:
</span><span class="inferred1"><a name="line679"></a> 679       # - By locking the database table before validating, and unlocking it after
</span><span class="inferred0"><a name="line680"></a> 680       #   saving. However, table locking is very expensive, and thus not
</span><span class="inferred1"><a name="line681"></a> 681       #   recommended.
</span><span class="inferred0"><a name="line682"></a> 682       # - By locking a lock file before validating, and unlocking it after saving.
</span><span class="inferred1"><a name="line683"></a> 683       #   This does not work if you've scaled your Rails application across
</span><span class="inferred0"><a name="line684"></a> 684       #   multiple web servers (because they cannot share lock files, or cannot
</span><span class="inferred1"><a name="line685"></a> 685       #   do that efficiently), and thus not recommended.
</span><span class="inferred0"><a name="line686"></a> 686       # - Creating a unique index on the field, by using
</span><span class="inferred1"><a name="line687"></a> 687       #   ActiveRecord::ConnectionAdapters::SchemaStatements#add_index. In the
</span><span class="inferred0"><a name="line688"></a> 688       #   rare case that a race condition occurs, the database will guarantee
</span><span class="inferred1"><a name="line689"></a> 689       #   the field's uniqueness.
</span><span class="inferred0"><a name="line690"></a> 690       #   
</span><span class="inferred1"><a name="line691"></a> 691       #   When the database catches such a duplicate insertion,
</span><span class="inferred0"><a name="line692"></a> 692       #   ActiveRecord::Base#save will raise an ActiveRecord::StatementInvalid
</span><span class="inferred1"><a name="line693"></a> 693       #   exception. You can either choose to let this error propagate (which
</span><span class="inferred0"><a name="line694"></a> 694       #   will result in the default Rails exception page being shown), or you
</span><span class="inferred1"><a name="line695"></a> 695       #   can catch it and restart the transaction (e.g. by telling the user
</span><span class="inferred0"><a name="line696"></a> 696       #   that the title already exists, and asking him to re-enter the title).
</span><span class="inferred1"><a name="line697"></a> 697       #   This technique is also known as optimistic concurrency control:
</span><span class="inferred0"><a name="line698"></a> 698       #   http://en.wikipedia.org/wiki/Optimistic_concurrency_control
</span><span class="inferred1"><a name="line699"></a> 699       #   
</span><span class="inferred0"><a name="line700"></a> 700       #   Active Record currently provides no way to distinguish unique
</span><span class="inferred1"><a name="line701"></a> 701       #   index constraint errors from other types of database errors, so you
</span><span class="inferred0"><a name="line702"></a> 702       #   will have to parse the (database-specific) exception message to detect
</span><span class="inferred1"><a name="line703"></a> 703       #   such a case.
</span><span class="marked0"><a name="line704"></a> 704       def validates_uniqueness_of(*attr_names)
</span><span class="uncovered1"><a name="line705"></a> 705         configuration = { :case_sensitive =&gt; true }
</span><span class="uncovered0"><a name="line706"></a> 706         configuration.update(attr_names.extract_options!)
</span><span class="uncovered1"><a name="line707"></a> 707 
</span><span class="uncovered0"><a name="line708"></a> 708         validates_each(attr_names,configuration) do |record, attr_name, value|
</span><span class="uncovered1"><a name="line709"></a> 709           # The check for an existing value should be run from a class that
</span><span class="uncovered0"><a name="line710"></a> 710           # isn't abstract. This means working down from the current class
</span><span class="uncovered1"><a name="line711"></a> 711           # (self), to the first non-abstract class. Since classes don't know
</span><span class="uncovered0"><a name="line712"></a> 712           # their subclasses, we have to build the hierarchy between self and
</span><span class="uncovered1"><a name="line713"></a> 713           # the record's class.
</span><span class="uncovered0"><a name="line714"></a> 714           class_hierarchy = [record.class]
</span><span class="uncovered1"><a name="line715"></a> 715           while class_hierarchy.first != self
</span><span class="uncovered0"><a name="line716"></a> 716             class_hierarchy.insert(0, class_hierarchy.first.superclass)
</span><span class="uncovered1"><a name="line717"></a> 717           end
</span><span class="uncovered0"><a name="line718"></a> 718 
</span><span class="uncovered1"><a name="line719"></a> 719           # Now we can work our way down the tree to the first non-abstract
</span><span class="uncovered0"><a name="line720"></a> 720           # class (which has a database table to query from).
</span><span class="uncovered1"><a name="line721"></a> 721           finder_class = class_hierarchy.detect { |klass| !klass.abstract_class? }
</span><span class="uncovered0"><a name="line722"></a> 722 
</span><span class="uncovered1"><a name="line723"></a> 723           is_text_column = finder_class.columns_hash[attr_name.to_s].text?
</span><span class="uncovered0"><a name="line724"></a> 724 
</span><span class="uncovered1"><a name="line725"></a> 725           if value.nil?
</span><span class="uncovered0"><a name="line726"></a> 726             comparison_operator = &quot;IS ?&quot;
</span><span class="uncovered1"><a name="line727"></a> 727           elsif is_text_column
</span><span class="uncovered0"><a name="line728"></a> 728             comparison_operator = &quot;#{connection.case_sensitive_equality_operator} ?&quot;
</span><span class="uncovered1"><a name="line729"></a> 729             value = value.to_s
</span><span class="uncovered0"><a name="line730"></a> 730           else
</span><span class="uncovered1"><a name="line731"></a> 731             comparison_operator = &quot;= ?&quot;
</span><span class="uncovered0"><a name="line732"></a> 732           end
</span><span class="uncovered1"><a name="line733"></a> 733 
</span><span class="uncovered0"><a name="line734"></a> 734           sql_attribute = &quot;#{record.class.quoted_table_name}.#{connection.quote_column_name(attr_name)}&quot;
</span><span class="uncovered1"><a name="line735"></a> 735 
</span><span class="uncovered0"><a name="line736"></a> 736           if value.nil? || (configuration[:case_sensitive] || !is_text_column)
</span><span class="uncovered1"><a name="line737"></a> 737             condition_sql = &quot;#{sql_attribute} #{comparison_operator}&quot;
</span><span class="uncovered0"><a name="line738"></a> 738             condition_params = [value]
</span><span class="uncovered1"><a name="line739"></a> 739           else
</span><span class="uncovered0"><a name="line740"></a> 740             condition_sql = &quot;LOWER(#{sql_attribute}) #{comparison_operator}&quot;
</span><span class="uncovered1"><a name="line741"></a> 741             condition_params = [value.mb_chars.downcase]
</span><span class="uncovered0"><a name="line742"></a> 742           end
</span><span class="uncovered1"><a name="line743"></a> 743 
</span><span class="uncovered0"><a name="line744"></a> 744           if scope = configuration[:scope]
</span><span class="uncovered1"><a name="line745"></a> 745             Array(scope).map do |scope_item|
</span><span class="uncovered0"><a name="line746"></a> 746               scope_value = record.send(scope_item)
</span><span class="uncovered1"><a name="line747"></a> 747               condition_sql &lt;&lt; &quot; AND #{record.class.quoted_table_name}.#{scope_item} #{attribute_condition(scope_value)}&quot;
</span><span class="uncovered0"><a name="line748"></a> 748               condition_params &lt;&lt; scope_value
</span><span class="uncovered1"><a name="line749"></a> 749             end
</span><span class="uncovered0"><a name="line750"></a> 750           end
</span><span class="uncovered1"><a name="line751"></a> 751 
</span><span class="uncovered0"><a name="line752"></a> 752           unless record.new_record?
</span><span class="uncovered1"><a name="line753"></a> 753             condition_sql &lt;&lt; &quot; AND #{record.class.quoted_table_name}.#{record.class.primary_key} &lt;&gt; ?&quot;
</span><span class="uncovered0"><a name="line754"></a> 754             condition_params &lt;&lt; record.send(:id)
</span><span class="uncovered1"><a name="line755"></a> 755           end
</span><span class="uncovered0"><a name="line756"></a> 756 
</span><span class="uncovered1"><a name="line757"></a> 757           finder_class.with_exclusive_scope do
</span><span class="uncovered0"><a name="line758"></a> 758             if finder_class.exists?([condition_sql, *condition_params])
</span><span class="uncovered1"><a name="line759"></a> 759               record.errors.add(attr_name, :taken, :default =&gt; configuration[:message], :value =&gt; value)
</span><span class="uncovered0"><a name="line760"></a> 760             end
</span><span class="uncovered1"><a name="line761"></a> 761           end
</span><span class="uncovered0"><a name="line762"></a> 762         end
</span><span class="uncovered1"><a name="line763"></a> 763       end
</span><span class="inferred0"><a name="line764"></a> 764 
</span><span class="inferred1"><a name="line765"></a> 765 
</span><span class="inferred0"><a name="line766"></a> 766       # Validates whether the value of the specified attribute is of the correct form by matching it against the regular expression
</span><span class="inferred1"><a name="line767"></a> 767       # provided.
</span><span class="inferred0"><a name="line768"></a> 768       #
</span><span class="inferred1"><a name="line769"></a> 769       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line770"></a> 770       #     validates_format_of :email, :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i, :on =&gt; :create
</span><span class="inferred1"><a name="line771"></a> 771       #   end
</span><span class="inferred0"><a name="line772"></a> 772       #
</span><span class="inferred1"><a name="line773"></a> 773       # Note: use &lt;tt&gt;\A&lt;/tt&gt; and &lt;tt&gt;\Z&lt;/tt&gt; to match the start and end of the string, &lt;tt&gt;^&lt;/tt&gt; and &lt;tt&gt;$&lt;/tt&gt; match the start/end of a line.
</span><span class="inferred0"><a name="line774"></a> 774       #
</span><span class="inferred1"><a name="line775"></a> 775       # A regular expression must be provided or else an exception will be raised.
</span><span class="inferred0"><a name="line776"></a> 776       #
</span><span class="inferred1"><a name="line777"></a> 777       # Configuration options:
</span><span class="inferred0"><a name="line778"></a> 778       # * &lt;tt&gt;:message&lt;/tt&gt; - A custom error message (default is: &quot;is invalid&quot;).
</span><span class="inferred1"><a name="line779"></a> 779       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - If set to true, skips this validation if the attribute is +nil+ (default is +false+).
</span><span class="inferred0"><a name="line780"></a> 780       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - If set to true, skips this validation if the attribute is blank (default is +false+).
</span><span class="inferred1"><a name="line781"></a> 781       # * &lt;tt&gt;:with&lt;/tt&gt; - The regular expression used to validate the format with (note: must be supplied!).
</span><span class="inferred0"><a name="line782"></a> 782       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred1"><a name="line783"></a> 783       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line784"></a> 784       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line785"></a> 785       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line786"></a> 786       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line787"></a> 787       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line788"></a> 788       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked1"><a name="line789"></a> 789       def validates_format_of(*attr_names)
</span><span class="uncovered0"><a name="line790"></a> 790         configuration = { :on =&gt; :save, :with =&gt; nil }
</span><span class="uncovered1"><a name="line791"></a> 791         configuration.update(attr_names.extract_options!)
</span><span class="uncovered0"><a name="line792"></a> 792 
</span><span class="uncovered1"><a name="line793"></a> 793         raise(ArgumentError, &quot;A regular expression must be supplied as the :with option of the configuration hash&quot;) unless configuration[:with].is_a?(Regexp)
</span><span class="uncovered0"><a name="line794"></a> 794 
</span><span class="uncovered1"><a name="line795"></a> 795         validates_each(attr_names, configuration) do |record, attr_name, value|
</span><span class="uncovered0"><a name="line796"></a> 796           unless value.to_s =~ configuration[:with]
</span><span class="uncovered1"><a name="line797"></a> 797             record.errors.add(attr_name, :invalid, :default =&gt; configuration[:message], :value =&gt; value) 
</span><span class="uncovered0"><a name="line798"></a> 798           end
</span><span class="uncovered1"><a name="line799"></a> 799         end
</span><span class="uncovered0"><a name="line800"></a> 800       end
</span><span class="inferred1"><a name="line801"></a> 801 
</span><span class="inferred0"><a name="line802"></a> 802       # Validates whether the value of the specified attribute is available in a particular enumerable object.
</span><span class="inferred1"><a name="line803"></a> 803       #
</span><span class="inferred0"><a name="line804"></a> 804       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line805"></a> 805       #     validates_inclusion_of :gender, :in =&gt; %w( m f ), :message =&gt; &quot;woah! what are you then!??!!&quot;
</span><span class="inferred0"><a name="line806"></a> 806       #     validates_inclusion_of :age, :in =&gt; 0..99
</span><span class="inferred1"><a name="line807"></a> 807       #     validates_inclusion_of :format, :in =&gt; %w( jpg gif png ), :message =&gt; &quot;extension {{value}} is not included in the list&quot;
</span><span class="inferred0"><a name="line808"></a> 808       #   end
</span><span class="inferred1"><a name="line809"></a> 809       #
</span><span class="inferred0"><a name="line810"></a> 810       # Configuration options:
</span><span class="inferred1"><a name="line811"></a> 811       # * &lt;tt&gt;:in&lt;/tt&gt; - An enumerable object of available items.
</span><span class="inferred0"><a name="line812"></a> 812       # * &lt;tt&gt;:message&lt;/tt&gt; - Specifies a custom error message (default is: &quot;is not included in the list&quot;).
</span><span class="inferred1"><a name="line813"></a> 813       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - If set to true, skips this validation if the attribute is +nil+ (default is +false+).
</span><span class="inferred0"><a name="line814"></a> 814       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - If set to true, skips this validation if the attribute is blank (default is +false+).
</span><span class="inferred1"><a name="line815"></a> 815       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line816"></a> 816       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line817"></a> 817       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line818"></a> 818       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line819"></a> 819       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line820"></a> 820       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked1"><a name="line821"></a> 821       def validates_inclusion_of(*attr_names)
</span><span class="uncovered0"><a name="line822"></a> 822         configuration = { :on =&gt; :save }
</span><span class="uncovered1"><a name="line823"></a> 823         configuration.update(attr_names.extract_options!)
</span><span class="uncovered0"><a name="line824"></a> 824 
</span><span class="uncovered1"><a name="line825"></a> 825         enum = configuration[:in] || configuration[:within]
</span><span class="uncovered0"><a name="line826"></a> 826 
</span><span class="uncovered1"><a name="line827"></a> 827         raise(ArgumentError, &quot;An object with the method include? is required must be supplied as the :in option of the configuration hash&quot;) unless enum.respond_to?(:include?)
</span><span class="uncovered0"><a name="line828"></a> 828 
</span><span class="uncovered1"><a name="line829"></a> 829         validates_each(attr_names, configuration) do |record, attr_name, value|
</span><span class="uncovered0"><a name="line830"></a> 830           unless enum.include?(value)
</span><span class="uncovered1"><a name="line831"></a> 831             record.errors.add(attr_name, :inclusion, :default =&gt; configuration[:message], :value =&gt; value) 
</span><span class="uncovered0"><a name="line832"></a> 832           end
</span><span class="uncovered1"><a name="line833"></a> 833         end
</span><span class="uncovered0"><a name="line834"></a> 834       end
</span><span class="inferred1"><a name="line835"></a> 835 
</span><span class="inferred0"><a name="line836"></a> 836       # Validates that the value of the specified attribute is not in a particular enumerable object.
</span><span class="inferred1"><a name="line837"></a> 837       #
</span><span class="inferred0"><a name="line838"></a> 838       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line839"></a> 839       #     validates_exclusion_of :username, :in =&gt; %w( admin superuser ), :message =&gt; &quot;You don't belong here&quot;
</span><span class="inferred0"><a name="line840"></a> 840       #     validates_exclusion_of :age, :in =&gt; 30..60, :message =&gt; &quot;This site is only for under 30 and over 60&quot;
</span><span class="inferred1"><a name="line841"></a> 841       #     validates_exclusion_of :format, :in =&gt; %w( mov avi ), :message =&gt; &quot;extension {{value}} is not allowed&quot;
</span><span class="inferred0"><a name="line842"></a> 842       #   end
</span><span class="inferred1"><a name="line843"></a> 843       #
</span><span class="inferred0"><a name="line844"></a> 844       # Configuration options:
</span><span class="inferred1"><a name="line845"></a> 845       # * &lt;tt&gt;:in&lt;/tt&gt; - An enumerable object of items that the value shouldn't be part of.
</span><span class="inferred0"><a name="line846"></a> 846       # * &lt;tt&gt;:message&lt;/tt&gt; - Specifies a custom error message (default is: &quot;is reserved&quot;).
</span><span class="inferred1"><a name="line847"></a> 847       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - If set to true, skips this validation if the attribute is +nil+ (default is +false+).
</span><span class="inferred0"><a name="line848"></a> 848       # * &lt;tt&gt;:allow_blank&lt;/tt&gt; - If set to true, skips this validation if the attribute is blank (default is +false+).
</span><span class="inferred1"><a name="line849"></a> 849       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line850"></a> 850       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line851"></a> 851       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line852"></a> 852       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line853"></a> 853       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line854"></a> 854       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked1"><a name="line855"></a> 855       def validates_exclusion_of(*attr_names)
</span><span class="uncovered0"><a name="line856"></a> 856         configuration = { :on =&gt; :save }
</span><span class="uncovered1"><a name="line857"></a> 857         configuration.update(attr_names.extract_options!)
</span><span class="uncovered0"><a name="line858"></a> 858 
</span><span class="uncovered1"><a name="line859"></a> 859         enum = configuration[:in] || configuration[:within]
</span><span class="uncovered0"><a name="line860"></a> 860 
</span><span class="uncovered1"><a name="line861"></a> 861         raise(ArgumentError, &quot;An object with the method include? is required must be supplied as the :in option of the configuration hash&quot;) unless enum.respond_to?(:include?)
</span><span class="uncovered0"><a name="line862"></a> 862 
</span><span class="uncovered1"><a name="line863"></a> 863         validates_each(attr_names, configuration) do |record, attr_name, value|
</span><span class="uncovered0"><a name="line864"></a> 864           if enum.include?(value)
</span><span class="uncovered1"><a name="line865"></a> 865             record.errors.add(attr_name, :exclusion, :default =&gt; configuration[:message], :value =&gt; value) 
</span><span class="uncovered0"><a name="line866"></a> 866           end
</span><span class="uncovered1"><a name="line867"></a> 867         end
</span><span class="uncovered0"><a name="line868"></a> 868       end
</span><span class="inferred1"><a name="line869"></a> 869 
</span><span class="inferred0"><a name="line870"></a> 870       # Validates whether the associated object or objects are all valid themselves. Works with any kind of association.
</span><span class="inferred1"><a name="line871"></a> 871       #
</span><span class="inferred0"><a name="line872"></a> 872       #   class Book &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line873"></a> 873       #     has_many :pages
</span><span class="inferred0"><a name="line874"></a> 874       #     belongs_to :library
</span><span class="inferred1"><a name="line875"></a> 875       #
</span><span class="inferred0"><a name="line876"></a> 876       #     validates_associated :pages, :library
</span><span class="inferred1"><a name="line877"></a> 877       #   end
</span><span class="inferred0"><a name="line878"></a> 878       #
</span><span class="inferred1"><a name="line879"></a> 879       # Warning: If, after the above definition, you then wrote:
</span><span class="inferred0"><a name="line880"></a> 880       #
</span><span class="inferred1"><a name="line881"></a> 881       #   class Page &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line882"></a> 882       #     belongs_to :book
</span><span class="inferred1"><a name="line883"></a> 883       #
</span><span class="inferred0"><a name="line884"></a> 884       #     validates_associated :book
</span><span class="inferred1"><a name="line885"></a> 885       #   end
</span><span class="inferred0"><a name="line886"></a> 886       #
</span><span class="inferred1"><a name="line887"></a> 887       # this would specify a circular dependency and cause infinite recursion.
</span><span class="inferred0"><a name="line888"></a> 888       #
</span><span class="inferred1"><a name="line889"></a> 889       # NOTE: This validation will not fail if the association hasn't been assigned. If you want to ensure that the association
</span><span class="inferred0"><a name="line890"></a> 890       # is both present and guaranteed to be valid, you also need to use +validates_presence_of+.
</span><span class="inferred1"><a name="line891"></a> 891       #
</span><span class="inferred0"><a name="line892"></a> 892       # Configuration options:
</span><span class="inferred1"><a name="line893"></a> 893       # * &lt;tt&gt;:message&lt;/tt&gt; - A custom error message (default is: &quot;is invalid&quot;)
</span><span class="inferred0"><a name="line894"></a> 894       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred1"><a name="line895"></a> 895       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line896"></a> 896       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line897"></a> 897       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred0"><a name="line898"></a> 898       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line899"></a> 899       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line900"></a> 900       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked1"><a name="line901"></a> 901       def validates_associated(*attr_names)
</span><span class="uncovered0"><a name="line902"></a> 902         configuration = { :on =&gt; :save }
</span><span class="uncovered1"><a name="line903"></a> 903         configuration.update(attr_names.extract_options!)
</span><span class="uncovered0"><a name="line904"></a> 904 
</span><span class="uncovered1"><a name="line905"></a> 905         validates_each(attr_names, configuration) do |record, attr_name, value|
</span><span class="uncovered0"><a name="line906"></a> 906           unless (value.is_a?(Array) ? value : [value]).collect { |r| r.nil? || r.valid? }.all?
</span><span class="uncovered1"><a name="line907"></a> 907             record.errors.add(attr_name, :invalid, :default =&gt; configuration[:message], :value =&gt; value)
</span><span class="uncovered0"><a name="line908"></a> 908           end
</span><span class="uncovered1"><a name="line909"></a> 909         end
</span><span class="uncovered0"><a name="line910"></a> 910       end
</span><span class="inferred1"><a name="line911"></a> 911 
</span><span class="inferred0"><a name="line912"></a> 912       # Validates whether the value of the specified attribute is numeric by trying to convert it to
</span><span class="inferred1"><a name="line913"></a> 913       # a float with Kernel.Float (if &lt;tt&gt;only_integer&lt;/tt&gt; is false) or applying it to the regular expression
</span><span class="inferred0"><a name="line914"></a> 914       # &lt;tt&gt;/\A[\+\-]?\d+\Z/&lt;/tt&gt; (if &lt;tt&gt;only_integer&lt;/tt&gt; is set to true).
</span><span class="inferred1"><a name="line915"></a> 915       #
</span><span class="inferred0"><a name="line916"></a> 916       #   class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line917"></a> 917       #     validates_numericality_of :value, :on =&gt; :create
</span><span class="inferred0"><a name="line918"></a> 918       #   end
</span><span class="inferred1"><a name="line919"></a> 919       #
</span><span class="inferred0"><a name="line920"></a> 920       # Configuration options:
</span><span class="inferred1"><a name="line921"></a> 921       # * &lt;tt&gt;:message&lt;/tt&gt; - A custom error message (default is: &quot;is not a number&quot;).
</span><span class="inferred0"><a name="line922"></a> 922       # * &lt;tt&gt;:on&lt;/tt&gt; - Specifies when this validation is active (default is &lt;tt&gt;:save&lt;/tt&gt;, other options &lt;tt&gt;:create&lt;/tt&gt;, &lt;tt&gt;:update&lt;/tt&gt;).
</span><span class="inferred1"><a name="line923"></a> 923       # * &lt;tt&gt;:only_integer&lt;/tt&gt; - Specifies whether the value has to be an integer, e.g. an integral value (default is +false+).
</span><span class="inferred0"><a name="line924"></a> 924       # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - Skip validation if attribute is +nil+ (default is +false+). Notice that for fixnum and float columns empty strings are converted to +nil+.
</span><span class="inferred1"><a name="line925"></a> 925       # * &lt;tt&gt;:greater_than&lt;/tt&gt; - Specifies the value must be greater than the supplied value.
</span><span class="inferred0"><a name="line926"></a> 926       # * &lt;tt&gt;:greater_than_or_equal_to&lt;/tt&gt; - Specifies the value must be greater than or equal the supplied value.
</span><span class="inferred1"><a name="line927"></a> 927       # * &lt;tt&gt;:equal_to&lt;/tt&gt; - Specifies the value must be equal to the supplied value.
</span><span class="inferred0"><a name="line928"></a> 928       # * &lt;tt&gt;:less_than&lt;/tt&gt; - Specifies the value must be less than the supplied value.
</span><span class="inferred1"><a name="line929"></a> 929       # * &lt;tt&gt;:less_than_or_equal_to&lt;/tt&gt; - Specifies the value must be less than or equal the supplied value.
</span><span class="inferred0"><a name="line930"></a> 930       # * &lt;tt&gt;:odd&lt;/tt&gt; - Specifies the value must be an odd number.
</span><span class="inferred1"><a name="line931"></a> 931       # * &lt;tt&gt;:even&lt;/tt&gt; - Specifies the value must be an even number.
</span><span class="inferred0"><a name="line932"></a> 932       # * &lt;tt&gt;:if&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred1"><a name="line933"></a> 933       #   occur (e.g. &lt;tt&gt;:if =&gt; :allow_validation&lt;/tt&gt;, or &lt;tt&gt;:if =&gt; Proc.new { |user| user.signup_step &gt; 2 }&lt;/tt&gt;).  The
</span><span class="inferred0"><a name="line934"></a> 934       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="inferred1"><a name="line935"></a> 935       # * &lt;tt&gt;:unless&lt;/tt&gt; - Specifies a method, proc or string to call to determine if the validation should
</span><span class="inferred0"><a name="line936"></a> 936       #   not occur (e.g. &lt;tt&gt;:unless =&gt; :skip_validation&lt;/tt&gt;, or &lt;tt&gt;:unless =&gt; Proc.new { |user| user.signup_step &lt;= 2 }&lt;/tt&gt;).  The
</span><span class="inferred1"><a name="line937"></a> 937       #   method, proc or string should return or evaluate to a true or false value.
</span><span class="marked0"><a name="line938"></a> 938       def validates_numericality_of(*attr_names)
</span><span class="uncovered1"><a name="line939"></a> 939         configuration = { :on =&gt; :save, :only_integer =&gt; false, :allow_nil =&gt; false }
</span><span class="uncovered0"><a name="line940"></a> 940         configuration.update(attr_names.extract_options!)
</span><span class="uncovered1"><a name="line941"></a> 941 
</span><span class="uncovered0"><a name="line942"></a> 942 
</span><span class="uncovered1"><a name="line943"></a> 943         numericality_options = ALL_NUMERICALITY_CHECKS.keys &amp; configuration.keys
</span><span class="uncovered0"><a name="line944"></a> 944 
</span><span class="uncovered1"><a name="line945"></a> 945         (numericality_options - [ :odd, :even ]).each do |option|
</span><span class="uncovered0"><a name="line946"></a> 946           raise ArgumentError, &quot;:#{option} must be a number&quot; unless configuration[option].is_a?(Numeric)
</span><span class="uncovered1"><a name="line947"></a> 947         end
</span><span class="uncovered0"><a name="line948"></a> 948 
</span><span class="uncovered1"><a name="line949"></a> 949         validates_each(attr_names,configuration) do |record, attr_name, value|
</span><span class="uncovered0"><a name="line950"></a> 950           raw_value = record.send(&quot;#{attr_name}_before_type_cast&quot;) || value
</span><span class="uncovered1"><a name="line951"></a> 951 
</span><span class="uncovered0"><a name="line952"></a> 952           next if configuration[:allow_nil] and raw_value.nil?
</span><span class="uncovered1"><a name="line953"></a> 953 
</span><span class="uncovered0"><a name="line954"></a> 954           if configuration[:only_integer]
</span><span class="uncovered1"><a name="line955"></a> 955             unless raw_value.to_s =~ /\A[+-]?\d+\Z/
</span><span class="uncovered0"><a name="line956"></a> 956               record.errors.add(attr_name, :not_a_number, :value =&gt; raw_value, :default =&gt; configuration[:message])
</span><span class="uncovered1"><a name="line957"></a> 957               next
</span><span class="uncovered0"><a name="line958"></a> 958             end
</span><span class="uncovered1"><a name="line959"></a> 959             raw_value = raw_value.to_i
</span><span class="uncovered0"><a name="line960"></a> 960           else
</span><span class="uncovered1"><a name="line961"></a> 961             begin
</span><span class="uncovered0"><a name="line962"></a> 962               raw_value = Kernel.Float(raw_value)
</span><span class="uncovered1"><a name="line963"></a> 963             rescue ArgumentError, TypeError
</span><span class="uncovered0"><a name="line964"></a> 964               record.errors.add(attr_name, :not_a_number, :value =&gt; raw_value, :default =&gt; configuration[:message])
</span><span class="uncovered1"><a name="line965"></a> 965               next
</span><span class="uncovered0"><a name="line966"></a> 966             end
</span><span class="uncovered1"><a name="line967"></a> 967           end
</span><span class="uncovered0"><a name="line968"></a> 968 
</span><span class="uncovered1"><a name="line969"></a> 969           numericality_options.each do |option|
</span><span class="uncovered0"><a name="line970"></a> 970             case option
</span><span class="uncovered1"><a name="line971"></a> 971               when :odd, :even
</span><span class="uncovered0"><a name="line972"></a> 972                 unless raw_value.to_i.method(ALL_NUMERICALITY_CHECKS[option])[]
</span><span class="uncovered1"><a name="line973"></a> 973                   record.errors.add(attr_name, option, :value =&gt; raw_value, :default =&gt; configuration[:message]) 
</span><span class="uncovered0"><a name="line974"></a> 974                 end
</span><span class="uncovered1"><a name="line975"></a> 975               else
</span><span class="uncovered0"><a name="line976"></a> 976                 record.errors.add(attr_name, option, :default =&gt; configuration[:message], :value =&gt; raw_value, :count =&gt; configuration[option]) unless raw_value.method(ALL_NUMERICALITY_CHECKS[option])[configuration[option]]
</span><span class="uncovered1"><a name="line977"></a> 977             end
</span><span class="uncovered0"><a name="line978"></a> 978           end
</span><span class="uncovered1"><a name="line979"></a> 979         end
</span><span class="uncovered0"><a name="line980"></a> 980       end
</span><span class="inferred1"><a name="line981"></a> 981 
</span><span class="inferred0"><a name="line982"></a> 982       # Creates an object just like Base.create but calls save! instead of save
</span><span class="inferred1"><a name="line983"></a> 983       # so an exception is raised if the record is invalid.
</span><span class="marked0"><a name="line984"></a> 984       def create!(attributes = nil, &amp;block)
</span><span class="uncovered1"><a name="line985"></a> 985         if attributes.is_a?(Array)
</span><span class="uncovered0"><a name="line986"></a> 986           attributes.collect { |attr| create!(attr, &amp;block) }
</span><span class="uncovered1"><a name="line987"></a> 987         else
</span><span class="uncovered0"><a name="line988"></a> 988           object = new(attributes)
</span><span class="uncovered1"><a name="line989"></a> 989           yield(object) if block_given?
</span><span class="uncovered0"><a name="line990"></a> 990           object.save!
</span><span class="uncovered1"><a name="line991"></a> 991           object
</span><span class="uncovered0"><a name="line992"></a> 992         end
</span><span class="uncovered1"><a name="line993"></a> 993       end
</span><span class="inferred0"><a name="line994"></a> 994 
</span><span class="marked1"><a name="line995"></a> 995       private
</span><span class="marked0"><a name="line996"></a> 996         def validation_method(on)
</span><span class="uncovered1"><a name="line997"></a> 997           case on
</span><span class="uncovered0"><a name="line998"></a> 998             when :save   then :validate
</span><span class="uncovered1"><a name="line999"></a> 999             when :create then :validate_on_create
</span><span class="uncovered0"><a name="line1000"></a>1000             when :update then :validate_on_update
</span><span class="uncovered1"><a name="line1001"></a>1001           end
</span><span class="uncovered0"><a name="line1002"></a>1002         end
</span><span class="uncovered1"><a name="line1003"></a>1003     end
</span><span class="inferred0"><a name="line1004"></a>1004 
</span><span class="inferred1"><a name="line1005"></a>1005     # The validation process on save can be skipped by passing false. The regular Base#save method is
</span><span class="inferred0"><a name="line1006"></a>1006     # replaced with this when the validations module is mixed in, which it is by default.
</span><span class="marked1"><a name="line1007"></a>1007     def save_with_validation(perform_validation = true)
</span><span class="uncovered0"><a name="line1008"></a>1008       if perform_validation &amp;&amp; valid? || !perform_validation
</span><span class="uncovered1"><a name="line1009"></a>1009         save_without_validation
</span><span class="uncovered0"><a name="line1010"></a>1010       else
</span><span class="uncovered1"><a name="line1011"></a>1011         false
</span><span class="uncovered0"><a name="line1012"></a>1012       end
</span><span class="uncovered1"><a name="line1013"></a>1013     end
</span><span class="inferred0"><a name="line1014"></a>1014 
</span><span class="inferred1"><a name="line1015"></a>1015     # Attempts to save the record just like Base#save but will raise a RecordInvalid exception instead of returning false
</span><span class="inferred0"><a name="line1016"></a>1016     # if the record is not valid.
</span><span class="marked1"><a name="line1017"></a>1017     def save_with_validation!
</span><span class="uncovered0"><a name="line1018"></a>1018       if valid?
</span><span class="uncovered1"><a name="line1019"></a>1019         save_without_validation!
</span><span class="uncovered0"><a name="line1020"></a>1020       else
</span><span class="uncovered1"><a name="line1021"></a>1021         raise RecordInvalid.new(self)
</span><span class="uncovered0"><a name="line1022"></a>1022       end
</span><span class="uncovered1"><a name="line1023"></a>1023     end
</span><span class="inferred0"><a name="line1024"></a>1024 
</span><span class="inferred1"><a name="line1025"></a>1025     # Runs +validate+ and +validate_on_create+ or +validate_on_update+ and returns true if no errors were added otherwise false.
</span><span class="marked0"><a name="line1026"></a>1026     def valid?
</span><span class="uncovered1"><a name="line1027"></a>1027       errors.clear
</span><span class="uncovered0"><a name="line1028"></a>1028 
</span><span class="uncovered1"><a name="line1029"></a>1029       run_callbacks(:validate)
</span><span class="uncovered0"><a name="line1030"></a>1030       validate
</span><span class="uncovered1"><a name="line1031"></a>1031 
</span><span class="uncovered0"><a name="line1032"></a>1032       if new_record?
</span><span class="uncovered1"><a name="line1033"></a>1033         run_callbacks(:validate_on_create)
</span><span class="uncovered0"><a name="line1034"></a>1034         validate_on_create
</span><span class="uncovered1"><a name="line1035"></a>1035       else
</span><span class="uncovered0"><a name="line1036"></a>1036         run_callbacks(:validate_on_update)
</span><span class="uncovered1"><a name="line1037"></a>1037         validate_on_update
</span><span class="uncovered0"><a name="line1038"></a>1038       end
</span><span class="uncovered1"><a name="line1039"></a>1039 
</span><span class="uncovered0"><a name="line1040"></a>1040       errors.empty?
</span><span class="uncovered1"><a name="line1041"></a>1041     end
</span><span class="inferred0"><a name="line1042"></a>1042 
</span><span class="inferred1"><a name="line1043"></a>1043     # Returns the Errors object that holds all information about attribute error messages.
</span><span class="marked0"><a name="line1044"></a>1044     def errors
</span><span class="uncovered1"><a name="line1045"></a>1045       @errors ||= Errors.new(self)
</span><span class="uncovered0"><a name="line1046"></a>1046     end
</span><span class="inferred1"><a name="line1047"></a>1047 
</span><span class="marked0"><a name="line1048"></a>1048     protected
</span><span class="inferred1"><a name="line1049"></a>1049       # Overwrite this method for validation checks on all saves and use &lt;tt&gt;Errors.add(field, msg)&lt;/tt&gt; for invalid attributes.
</span><span class="marked0"><a name="line1050"></a>1050       def validate
</span><span class="inferred1"><a name="line1051"></a>1051       end
</span><span class="inferred0"><a name="line1052"></a>1052 
</span><span class="inferred1"><a name="line1053"></a>1053       # Overwrite this method for validation checks used only on creation.
</span><span class="marked0"><a name="line1054"></a>1054       def validate_on_create
</span><span class="inferred1"><a name="line1055"></a>1055       end
</span><span class="inferred0"><a name="line1056"></a>1056 
</span><span class="inferred1"><a name="line1057"></a>1057       # Overwrite this method for validation checks used only on updates.
</span><span class="marked0"><a name="line1058"></a>1058       def validate_on_update
</span><span class="inferred1"><a name="line1059"></a>1059       end
</span><span class="inferred0"><a name="line1060"></a>1060   end
</span><span class="inferred1"><a name="line1061"></a>1061 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
